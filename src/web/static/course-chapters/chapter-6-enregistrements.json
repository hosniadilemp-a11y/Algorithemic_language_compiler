{
  "id": "enregistrements",
  "title": "Chapitre 6: Les Enregistrements",
  "sections": [
    {
      "title": "Contexte et problématique",
      "content": "Quand on utilise uniquement des variables simples et des tableaux, on représente difficilement des objets réels complexes.\n\nUn tableau est très utile, mais il impose un type unique pour toutes ses cases.\n\nExemple métier : un étudiant possède un nom, un prénom, un âge, une moyenne, parfois une date de naissance et une adresse. Ces informations sont de types différents.\n\n[[DEF]] L'enregistrement est la structure adaptée pour regrouper des données hétérogènes dans une même entité logique."
    },
    {
      "title": "Définition et vocabulaire formel",
      "content": "Un enregistrement est composé de **champs**.\n\nChaque champ possède :\n- un identificateur (nom du champ),\n- un type (`Entier`, `Reel`, `Chaine`, `Tableau`, ou un autre enregistrement).\n\n### Idée clé du chapitre\nOn passe des types primitifs vers des **types utilisateur** qui modélisent directement le domaine du problème.\n\n[[NOTE]] Avant de déclarer une variable d'un type enregistrement, il faut toujours définir ce type dans la partie `Type`."
    },
    {
      "title": "Syntaxe de définition (forme générale)",
      "content": "La définition se place dans la partie `Type`, avant la partie `Var`.\n\nCette règle est importante: elle évite les déclarations de variables sur des types non connus.",
      "code": "Type <Nom_Type> = Enregistrement\nDebut\n    <Champ_1> : <Type_1>;\n    <Champ_2> : <Type_2>;\n    ...\n    <Champ_N> : <Type_N>;\nFin;"
    },
    {
      "title": "Exemple principal: type Date",
      "content": "Le type `Date` montre la logique de construction d'un enregistrement simple.\n\nLes champs de même type peuvent être groupés sur une seule ligne pour alléger l'écriture, sans changer la signification.",
      "code": "Type Date = Enregistrement\nDebut\n    jour : Entier;\n    mois : Chaine[12];\n    annee : Entier;\nFin;\n\n// Ecriture compacte\nType Date = Enregistrement\nDebut\n    jour, annee : Entier;\n    mois : Chaine[12];\nFin;"
    },
    {
      "title": "Déclaration de variables de type enregistrement",
      "content": "Une fois le type défini, la déclaration se fait comme pour les types de base.\n\nOn peut déclarer une variable ou plusieurs variables du même type.",
      "code": "Var\n    d1, d2 : Date;\n    une_date_naissance : Date;"
    },
    {
      "title": "Accès aux champs: notation pointée",
      "content": "La notation pointée `variable.champ` est la base de la manipulation.\n\nElle sert :\n- en affectation,\n- en lecture,\n- dans les conditions,\n- dans les expressions.\n\n### Exemples de lecture\n`d1.jour`, `d1.mois`, `d1.annee`",
      "code": "d1.jour := 26;\nd1.mois := \"Fevrier\";\nd1.annee := 2026;\nEcrire(d1.jour, \"/\", d1.mois, \"/\", d1.annee);"
    },
    {
      "title": "Exercice guidé: type Temps",
      "content": "Énoncé du cours : définir un type `Temps(heure, minute, seconde)`, lire une variable `T`, puis afficher la conversion en secondes.\n\n### Démarche recommandée\n1. Définir le type `Temps`.\n2. Déclarer une variable `T : Temps`.\n3. Lire les trois champs.\n4. Calculer le total.\n5. Afficher le résultat.\n\n[[ALERT]] Ajouter une validation des bornes (`0<=minute<60`, `0<=seconde<60`) avant le calcul.",
      "code": "Type Temps = Enregistrement\nDebut\n    heure, minute, seconde : Entier;\nFin;\n\nAlgorithme ConversionTemps;\nVar\n    T : Temps;\n    total : Entier;\nDebut\n    Lire(T.heure);\n    Lire(T.minute);\n    Lire(T.seconde);\n\n    Si (T.minute < 0) Ou (T.minute >= 60) Ou\n       (T.seconde < 0) Ou (T.seconde >= 60) Alors\n        Ecrire(\"Temps invalide\");\n    Sinon\n        total := T.heure * 3600 + T.minute * 60 + T.seconde;\n        Ecrire(\"Total secondes = \", total);\n    Fin Si;\nFin."
    },
    {
      "title": "Opération d'affectation entre enregistrements",
      "content": "Si deux variables sont du même type enregistrement, l'affectation globale est autorisée.\n\n`d1 := d2` copie tous les champs de `d2` vers `d1`.",
      "code": "Var\n    d1, d2 : Date;\nDebut\n    d1 := d2;\n    // Equivalent a :\n    // d1.jour := d2.jour;\n    // d1.mois := d2.mois;\n    // d1.annee := d2.annee;\nFin."
    },
    {
      "title": "Opération de comparaison",
      "content": "Dans le cadre de ce cours, la comparaison directe de deux enregistrements est interdite.\n\n[[ALERT]] `Si d1 = d2` est à éviter.\n\nLa méthode correcte est une comparaison champ par champ.",
      "code": "// Interdit (pedagogiquement)\n// Si d1 = d2 Alors ...\n\n// Correct\nSi (d1.jour = d2.jour) ET\n   (d1.mois = d2.mois) ET\n   (d1.annee = d2.annee) Alors\n    Ecrire(\"Dates egales\");\nSinon\n    Ecrire(\"Dates differentes\");\nFin Si;"
    },
    {
      "title": "Tableaux d'enregistrements",
      "content": "Un tableau peut contenir des enregistrements. Chaque case devient un objet structuré complet.\n\nExemple classique : classe d'étudiants.\n\nOn accède à un champ en combinant indice et notation pointée: `Classe[i].nom`.",
      "code": "Type Etudiant = Enregistrement\nDebut\n    matricule : Entier;\n    nom, prenom : Chaine[25];\nFin;\n\nVar\n    Classe[50] : Tableau De Etudiant;\n\nEcrire(Classe[5].nom);"
    },
    {
      "title": "Champs de type tableau",
      "content": "Inversement, un enregistrement peut contenir un tableau comme champ.\n\nCette modélisation est utile quand un objet possède une collection fixe d'éléments (notes, mesures, valeurs mensuelles...).",
      "code": "Type Etudiant = Enregistrement\nDebut\n    nom, prenom : Chaine[25];\n    notes : Tableau[8] De Reel;\nFin;\n\nVar E : Etudiant;\n\nE.notes[3] := 14.5;\nEcrire(E.notes[3]);"
    },
    {
      "title": "Enregistrements imbriqués: principe",
      "content": "Un champ peut lui-même être un enregistrement.\n\nExemple : une `Personne` peut contenir un champ `ne_le : Date` et un champ `adr : Adresse`.\n\n### Règle d'ordre\nDéfinir d'abord les types de base (`Date`, `Adresse`), puis le type composite (`Personne`)."
    },
    {
      "title": "Définition complète des structures imbriquées",
      "content": "Cette forme suit la logique du support LaTeX: sous-types puis type principal.",
      "code": "Type Date = Enregistrement\nDebut\n    jour, mois, annee : Entier;\nFin;\n\nType Adresse = Enregistrement\nDebut\n    commune, wilaya : Chaine[20];\nFin;\n\nType Personne = Enregistrement\nDebut\n    nom : Chaine[25];\n    ne_le : Date;\n    adr : Adresse;\nFin;\n\nVar P : Personne;"
    },
    {
      "title": "Arborescence d'accès dans un enregistrement imbriqué",
      "content": "La manipulation suit une arborescence: objet principal -> sous-objet -> champ final.\n\nExemples d'accès :\n- `P.ne_le.jour`\n- `P.ne_le.annee`\n- `P.adr.commune`\n- `P.adr.wilaya`\n\nCette écriture rend explicite le chemin de donnée, ce qui améliore la lisibilité et la maintenance.",
      "code": "P.nom := \"HOSNI\";\nP.ne_le.jour := 26;\nP.ne_le.mois := 2;\nP.ne_le.annee := 2000;\nP.adr.commune := \"Annaba\";\nP.adr.wilaya := \"Annaba\";\n\nEcrire(P.nom, \" - \", P.ne_le.jour, \"/\", P.ne_le.mois, \"/\", P.ne_le.annee);"
    },
    {
      "title": "Bonnes pratiques de modélisation",
      "content": "- Donner des noms de types explicites (`Date`, `Adresse`, `Personne`).\n- Éviter les abréviations ambiguës pour les champs.\n- Initialiser les champs essentiels avant utilisation.\n- Regrouper les contrôles de validité dans des procédures dédiées.\n- Séparer les types de données de la logique de traitement.\n\n[[NOTE]] Plus la structure est claire, plus les algorithmes de manipulation restent courts et sûrs."
    },
    {
      "title": "Erreurs fréquentes et checklist finale",
      "content": "Erreurs observées en pratique :\n- type non défini avant la déclaration `Var`,\n- confusion entre affectation globale et comparaison,\n- comparaison directe non autorisée,\n- mélange de conventions d'indices dans un champ tableau,\n- oubli d'initialisation dans les structures imbriquées.\n\n### Checklist de fin de chapitre\n1. Type correctement défini dans `Type` ?\n2. Variables bien déclarées dans `Var` ?\n3. Accès aux champs via notation pointée cohérente ?\n4. Comparaisons faites champ par champ ?\n5. Champs sensibles validés avant calcul ?"
    },
    {
      "title": "Exercice 2: Gestion complète des étudiants",
      "content": "On considère les structures `Date` et `Etudiant` (nom, prénom, date de naissance, notes[8]).\n\n### Travail demandé\n1. écrire `Lire_Date`, `Lire_Notes`, `Lire_Etudiant`.\n2. écrire `Calculer_Moyenne`.\n3. écrire `Comparer_Dates` pour ordonner par date de naissance.\n4. Trier un tableau de `N` étudiants (1 <= N <= 50).\n5. Détecter les notes éliminatoires (`< 7`).\n6. Construire un tableau dynamique des étudiants ayant au moins une note éliminatoire.\n7. Afficher les résultats avec des actions dédiées.\n\n### Objectif pédagogique\nCombiner enregistrements imbriqués, tableaux, tris et filtrage dans un mini-projet cohérent."
    },
    {
      "title": "Exercice 3: Gestion de bibliothèque",
      "content": "Concevoir un système avec les structures `Date`, `Livre`, `Emprunt`.\n\n### Travail demandé\n1. Calculer les jours de retard d'un emprunt.\n2. Calculer l'amende (`50 DA` par jour).\n3. Rechercher un livre par ISBN.\n4. Lister tous les emprunts en retard.\n5. Produire le total des amendes ? collecter.\n\n### Objectif pédagogique\nManipuler des enregistrements imbriqués dans un contexte réaliste de gestion."
    },
    {
      "title": "Exercice 4: Carnet de contacts intelligent",
      "content": "Définir les structures `Adresse`, `Telephones`, `Contact` puis développer des traitements métiers.\n\n### Travail demandé\n1. Rechercher des contacts par nom (partiel).\n2. Compter les contacts par ville.\n3. Extraire les contacts d'une catégorie.\n4. Vérifier la validité d'un email (`@` et `.`).\n5. Détecter/fusionner les doublons (nom + prénom).\n6. Générer des statistiques et une liste d'emails invalides.\n\n### Objectif pédagogique\nPasser d'une simple définition de structures ? des opérations analytiques sur collections d'enregistrements."
    }
  ]
}
