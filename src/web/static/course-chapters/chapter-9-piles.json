{
  "id": "piles",
  "title": "Chapitre 9: Les Piles (Stacks)",
  "sections": [
    {
      "title": "1. Introduction : pourquoi les piles ?",
      "content": "Dans plusieurs systèmes, le traitement ne suit pas l'ordre d'arrivée. On traite d'abord le plus récent.\n\nExemples concrets :\n- retour en arrière (undo/redo) ;\n- appels de fonctions imbriqués ;\n- évaluation d'expressions ;\n- parcours récursifs.\n\n### Intuition\nUne pile ressemble à une colonne d'assiettes : on ajoute et on retire toujours au sommet."
    },
    {
      "title": "2. Définition LIFO et vocabulaire",
      "content": "Une pile suit le principe **LIFO** (*Last In, First Out*).\n\n- **Sommet (Top)** : seul point d'accès ;\n- **Empiler (Push)** : ajouter au sommet ;\n- **Dépiler (Pop)** : retirer du sommet.\n\n<div class=\"course-diagram\">\n<svg viewBox=\"0 0 860 260\" role=\"img\" aria-label=\"Pile LIFO\">\n  <defs>\n    <marker id=\"st-top\" markerWidth=\"10\" markerHeight=\"8\" refX=\"9\" refY=\"4\" orient=\"auto\">\n      <path d=\"M0,0 L10,4 L0,8 z\" fill=\"currentColor\"/>\n    </marker>\n  </defs>\n  <rect x=\"180\" y=\"36\" width=\"180\" height=\"188\" rx=\"8\" class=\"diagram-cell\"/>\n  <line x1=\"180\" y1=\"86\" x2=\"360\" y2=\"86\" class=\"diagram-split\"/>\n  <line x1=\"180\" y1=\"136\" x2=\"360\" y2=\"136\" class=\"diagram-split\"/>\n  <line x1=\"180\" y1=\"186\" x2=\"360\" y2=\"186\" class=\"diagram-split\"/>\n  <text x=\"258\" y=\"70\" class=\"diagram-main\">c</text>\n  <text x=\"258\" y=\"120\" class=\"diagram-main\">b</text>\n  <text x=\"258\" y=\"170\" class=\"diagram-main\">a</text>\n  <line x1=\"452\" y1=\"30\" x2=\"362\" y2=\"62\" class=\"diagram-arrow\" marker-end=\"url(#st-top)\"/>\n  <text x=\"468\" y=\"34\" class=\"diagram-title\">Sommet</text>\n  <text x=\"120\" y=\"244\" class=\"diagram-caption\">Dernier empilé = premier dépilé</text>\n</svg>\n</div>"
    },
    {
      "title": "3. Applications essentielles",
      "content": "### 3.1 Vérification syntaxique (compilation)\nLes compilateurs utilisent une pile pour vérifier l'équilibre des parenthèses, crochets et accolades.\n- À chaque ouvrante (`(`, `[`, `{`) : on empile le symbole.\n- À chaque fermante (`)`, `]`, `}`) : on dépile et on vérifie la correspondance.\n- Si on veut dépiler une pile vide, l'expression est incorrecte.\n- À la fin, la pile doit être vide.\nComplexité : `O(n)` en temps et `O(n)` en mémoire dans le pire cas.\n\n### 3.2 Appels de fonctions (stack frames)\nChaque appel de fonction empile un contexte d'exécution appelé *stack frame* :\n- paramètres de la fonction ;\n- variables locales ;\n- adresse de retour.\nQuand la fonction se termine, son frame est dépilé automatiquement.\nCela explique pourquoi la dernière fonction appelée est la première à se terminer.\n\n### 3.3 Récursivité\nLa récursivité repose directement sur la pile d'appels.\nChaque appel récursif empile un nouveau contexte jusqu'au cas de base.\nEnsuite, les retours se font en chaîne par dépilements successifs.\nPiège classique : sans cas de base, la pile grandit indéfiniment (dépassement de pile).\n\n### 3.4 Évaluation d'expressions\nLes piles simplifient les calculs d'expressions :\n- conversion infixée -> postfixée ;\n- Évaluation d'une expression postfixée ;\n- gestion des priorités opératoires et des parenthèses.\nElles permettent un traitement linéaire robuste et facile à implémenter."
    },
    {
      "title": "4. Primitives de manipulation",
      "content": "Le tableau suivant résume les primitives essentielles d'une pile avec leurs préconditions et le coût.\n\n<div class=\"course-table-wrap\"><table class=\"course-table\"><thead><tr><th>Primitive</th><th>Rôle</th><th>Précondition</th><th>Complexité</th><th>Point de vigilance</th></tr></thead><tbody><tr><td><code class=\"course-inline-code\">InitialiserPile(P)</code></td><td>Créer une pile vide</td><td>aucune</td><td>O(1)</td><td>Mettre explicitement <code class=\"course-inline-code\">P := NIL</code></td></tr><tr><td><code class=\"course-inline-code\">Empiler(P, x)</code></td><td>Ajouter <code class=\"course-inline-code\">x</code> au sommet</td><td>mémoire disponible</td><td>O(1)</td><td>Conserver l'ancien sommet via <code class=\"course-inline-code\">suivant</code></td></tr><tr><td><code class=\"course-inline-code\">Depiler(P, x)</code></td><td>Retirer le sommet dans <code class=\"course-inline-code\">x</code></td><td>pile non vide</td><td>O(1)</td><td>Tester <code class=\"course-inline-code\">PileVide</code> puis libérer le maillon retiré</td></tr><tr><td><code class=\"course-inline-code\">SommetPile(P)</code></td><td>Lire le sommet sans retrait</td><td>pile non vide</td><td>O(1)</td><td>Ne pas modifier la structure</td></tr><tr><td><code class=\"course-inline-code\">PileVide(P)</code></td><td>Tester la vacuité</td><td>aucune</td><td>O(1)</td><td>Utiliser ce test avant toute lecture/suppression</td></tr></tbody></table></div>\n\n### À retenir\nToutes les opérations fondamentales d'une pile chaînée sont en temps constant, à condition de manipuler correctement le sommet et la mémoire."
    },
    {
      "title": "5. Représentation en mémoire (liste chaînée)",
      "content": "On représente la pile par une liste chaînée dont la **tête = sommet**.\n\nConséquence directe :\n- `Empiler` = insertion en tête ;\n- `Depiler` = suppression en tête.\n\nCela évite le décalage d'éléments et garde un coût constant O(1)."
    },
    {
      "title": "6. Déclaration des types",
      "content": "Cette déclaration introduit le maillon de pile (`info`, `suivant`) et le pointeur `Sommet`.\n\nLa structure est compacte et suffit pour toutes les primitives LIFO.\nL'accès se fait toujours via `Sommet`, jamais par index.",
      "code": "TYPE ElementOriginal = Entier;\n\nTYPE Pile = ENREGISTREMENT\nDebut\n    info : ElementOriginal;\n    suivant : ^Pile;\nFin;\n\nVAR Sommet : ^Pile;"
    },
    {
      "title": "7. InitialiserPile",
      "content": "Initialiser une pile consiste ? placer le sommet ? `NIL`.\n\nCela garantit un état propre et évite les accès mémoire indéfinis avant le premier `Empiler`.",
      "code": "PROCEDURE InitialiserPile(VAR tete : ^Pile)\nDebut\n    tete := NIL;\nFin;"
    },
    {
      "title": "8. Empiler (Push) : ordre des opérations",
      "content": "`Empiler` ajoute un maillon en tête de la chaîne.\n\n### Invariant après l'opération\nLe nouveau maillon devient le sommet et pointe vers l'ancien sommet.\nComplexité: `O(1)` en temps, `O(1)` en espace supplémentaire (hors allocation du maillon).",
      "code": "PROCEDURE Empiler(VAR tete : ^Pile; val : ElementOriginal)\nVar p : ^Pile;\nDebut\n    p := allouer(taille(Pile));\n    p->info := val;\n    p->suivant := tete;\n    tete := p;\nFin;"
    },
    {
      "title": "9. Dépiler (Pop) : sécurité et libération",
      "content": "Ordre correct :\n1. vérifier que la pile n'est pas vide ;\n2. sauvegarder l'adresse du sommet ;\n3. lire la valeur ;\n4. avancer `tete` ;\n5. libérer l'ancien sommet.\n\n[[ALERT]] Oublier `liberer(p)` provoque une fuite mémoire.",
      "code": "PROCEDURE Depiler(VAR tete : ^Pile; VAR sortie : ElementOriginal)\nVar p : ^Pile;\nDebut\n    Si PileVide(tete) Alors\n        Ecrire('Erreur: pile vide');\n    Sinon\n        p := tete;\n        sortie := tete->info;\n        tete := tete->suivant;\n        liberer(p);\n    Fin Si;\nFin;"
    },
    {
      "title": "10. Consultation : SommetPile et PileVide",
      "content": "Ces primitives de lecture/test évitent les erreurs de logique.\n\n- `SommetPile` lit sans retrait ;\n- `PileVide` sert de garde de sécurité pour toutes les opérations sensibles.",
      "code": "FONCTION SommetPile(tete : ^Pile) : ElementOriginal\nDebut\n    Retourner tete->info;\nFin;\n\nFONCTION PileVide(tete : ^Pile) : Booleen\nDebut\n    Retourner tete = NIL;\nFin;"
    },
    {
      "title": "11. Exercice guidé : création et recherche",
      "content": "<div class=\"course-exercise\">\n  <div class=\"course-exercise-title\"><i class=\"fas fa-puzzle-piece\"></i> Énoncé</div>\n  <p>Créer une pile de <code class=\"course-inline-code\">N</code> entiers puis vérifier l'existence d'une valeur <code class=\"course-inline-code\">val</code>, en utilisant uniquement les primitives de pile.</p>\n  <details class=\"course-solution-details\"><summary>Voir la solution complète</summary>\n<pre class=\"course-solution-code\">Algorithme ExoPile_Creer_Rechercher;\nType Pile = Enregistrement\nDebut\n    info : Entier;\n    suivant : ^Pile;\nFin;\nVar\n    S, Tmp : ^Pile;\n    N, i, x, val : Entier;\n    trouve : Booleen;\n\nProcedure InitialiserPile(Var tete : ^Pile);\nDebut\n    tete := NIL;\nFin;\n\nProcedure Empiler(Var tete : ^Pile; v : Entier);\nVar p : ^Pile;\nDebut\n    p := allouer(taille(Pile));\n    p-&gt;info := v;\n    p-&gt;suivant := tete;\n    tete := p;\nFin;\n\nProcedure Depiler(Var tete : ^Pile; Var v : Entier);\nVar p : ^Pile;\nDebut\n    p := tete;\n    v := p-&gt;info;\n    tete := tete-&gt;suivant;\n    liberer(p);\nFin;\n\nFONCTION PileVide(tete : ^Pile) : Booleen;\nDebut\n    Retourner tete = NIL;\nFin;\n\nDebut\n    InitialiserPile(S);\n    InitialiserPile(Tmp);\n\n    Lire(N);\n    Pour i := 1 a N Faire\n        Lire(x);\n        Empiler(S, x);\n    Fin Pour;\n\n    Lire(val);\n    trouve := Faux;\n\n    Tantque NON PileVide(S) Faire\n        Depiler(S, x);\n        Si x = val Alors\n            trouve := Vrai;\n        Fin Si;\n        Empiler(Tmp, x);\n    Fin Tantque;\n\n    Tantque NON PileVide(Tmp) Faire\n        Depiler(Tmp, x);\n        Empiler(S, x);\n    Fin Tantque;\n\n    Si trouve Alors\n        Ecrire(&#x27;Valeur trouvée&#x27;);\n    Sinon\n        Ecrire(&#x27;Valeur absente&#x27;);\n    Fin Si;\nFin.</pre>\n<button class=\"course-solution-run\" data-code=\"Algorithme ExoPile_Creer_Rechercher;\\nType Pile = Enregistrement\\nDebut\\n    info : Entier;\\n    suivant : ^Pile;\\nFin;\\nVar\\n    S, Tmp : ^Pile;\\n    N, i, x, val : Entier;\\n    trouve : Booleen;\\n\\nProcedure InitialiserPile(Var tete : ^Pile);\\nDebut\\n    tete := NIL;\\nFin;\\n\\nProcedure Empiler(Var tete : ^Pile; v : Entier);\\nVar p : ^Pile;\\nDebut\\n    p := allouer(taille(Pile));\\n    p->info := v;\\n    p->suivant := tete;\\n    tete := p;\\nFin;\\n\\nProcedure Depiler(Var tete : ^Pile; Var v : Entier);\\nVar p : ^Pile;\\nDebut\\n    p := tete;\\n    v := p->info;\\n    tete := tete->suivant;\\n    liberer(p);\\nFin;\\n\\nFONCTION PileVide(tete : ^Pile) : Booleen;\\nDebut\\n    Retourner tete = NIL;\\nFin;\\n\\nDebut\\n    InitialiserPile(S);\\n    InitialiserPile(Tmp);\\n\\n    Lire(N);\\n    Pour i := 1 a N Faire\\n        Lire(x);\\n        Empiler(S, x);\\n    Fin Pour;\\n\\n    Lire(val);\\n    trouve := Faux;\\n\\n    Tantque NON PileVide(S) Faire\\n        Depiler(S, x);\\n        Si x = val Alors\\n            trouve := Vrai;\\n        Fin Si;\\n        Empiler(Tmp, x);\\n    Fin Tantque;\\n\\n    Tantque NON PileVide(Tmp) Faire\\n        Depiler(Tmp, x);\\n        Empiler(S, x);\\n    Fin Tantque;\\n\\n    Si trouve Alors\\n        Ecrire('Valeur trouvée');\\n    Sinon\\n        Ecrire('Valeur absente');\\n    Fin Si;\\nFin.\">Exécuter cette solution</button>\n</details>\n</div>"
    },
    {
      "title": "12. Application : expression infixée vers postfixée",
      "content": "Pour calculer efficacement, on convertit souvent une expression **infixée** (`(a+b)*c`) en **postfixée** (`a b + c *`).\n\nPrincipe :\n- les opérandes vont directement dans la sortie ;\n- les opérateurs passent par une pile selon la priorité ;\n- les parenthèses contrôlent les dépilements."
    },
    {
      "title": "13. Algorithme simplifié : Infixe -> Postfixe",
      "code": "Algorithme InfixeVersPostfixe;\nVar\n    P : PileOperateurs;\n    exp, sortie : Chaine;\n    c : Caractere;\nDebut\n    InitialiserPile(P);\n    sortie := '';\n\n    Pour chaque caractere c de exp Faire\n        Si Operande(c) Alors\n            sortie := sortie + c;\n        Sinon Si c = '(' Alors\n            Empiler(P, c);\n        Sinon Si Operateur(c) Alors\n            Tantque NON PileVide(P) Et Priorite(SommetPile(P)) >= Priorite(c) Faire\n                sortie := sortie + SommetPile(P);\n                Depiler(P, c);\n            Fin Tantque;\n            Empiler(P, c);\n        Sinon Si c = ')' Alors\n            Tantque NON PileVide(P) Et SommetPile(P) <> '(' Faire\n                sortie := sortie + SommetPile(P);\n                Depiler(P, c);\n            Fin Tantque;\n            Depiler(P, c);\n        Fin Si;\n    Fin Pour;\n\n    Tantque NON PileVide(P) Faire\n        Depiler(P, c);\n        sortie := sortie + c;\n    Fin Tantque;\n\n    Ecrire(sortie);\nFin.",
      "content": "Algorithme de conversion infixée -> postfixée.\nLes opérateurs sont temporairement stockés dans la pile selon leur priorité.\nLes parenthèses contrôlent les moments de dépilement vers la sortie."
    },
    {
      "title": "14. Algorithme : évaluation postfixée",
      "code": "Algorithme EvaluerPostfixe;\nVar\n    P : PileEntiers;\n    T : Tableau[1..100] de Caractere;\n    i, x, y, res : Entier;\nDebut\n    InitialiserPile(P);\n\n    Pour i := 1 a N Faire\n        Si Operande(T[i]) Alors\n            Empiler(P, Valeur(T[i]));\n        Sinon\n            Depiler(P, y);\n            Depiler(P, x);\n            res := Evaluer(x, y, T[i]);\n            Empiler(P, res);\n        Fin Si;\n    Fin Pour;\n\n    Depiler(P, res);\n    Ecrire('Résultat=', res);\nFin.",
      "content": "Algorithme d'évaluation postfixée.\nChaque opérande est empilé, puis chaque opérateur dépile deux valeurs, calcule le résultat et l'empile de nouveau.\nCe schéma donne une évaluation linéaire de l'expression."
    },
    {
      "title": "15. Complexité et erreurs fréquentes",
      "content": "| Opération | Complexité | Erreur fréquente |\n| :--- | :--- | :--- |\n| Empiler | O(1) | oublier le chaînage de l'ancien sommet |\n| Depiler | O(1) | dépiler une pile vide |\n| SommetPile | O(1) | lire sans test de vacuité |\n| Recherche (par parcours) | O(n) | oublier de restaurer la pile si on dépile pour chercher |\n\n### Bonnes pratiques\n- Toujours tester `PileVide` avant `Depiler`/`SommetPile`.\n- Libérer chaque maillon retiré.\n- Tester les cas limites : pile vide, un seul élément."
    },
    {
      "title": "16. Exercices supplémentaires (entraînement)",
      "content": "<div class=\"course-exercise\">\n  <div class=\"course-exercise-title\"><i class=\"fas fa-brackets-curly\"></i> Exercice A : parenthèses équilibrées</div>\n  <p>écrire un algorithme qui vérifie si une expression est bien parenthésée.</p>\n  <details class=\"course-solution-details\"><summary>Voir la solution complète</summary>\n<pre class=\"course-solution-code\">Algorithme ParenthesesEquilibrees;\nVar\n    P : PileCaracteres;\n    i : Entier;\n    c, x : Caractere;\n    ok : Booleen;\nDebut\n    InitialiserPile(P);\n    ok := Vrai;\n\n    Pour i := 1 a Longueur(exp) Faire\n        c := exp[i];\n        Si c = &#x27;(&#x27; Alors\n            Empiler(P, c);\n        Sinon Si c = &#x27;)&#x27; Alors\n            Si PileVide(P) Alors\n                ok := Faux;\n            Sinon\n                Depiler(P, x);\n            Fin Si;\n        Fin Si;\n    Fin Pour;\n\n    Si NON PileVide(P) Alors\n        ok := Faux;\n    Fin Si;\n\n    Si ok Alors Ecrire(&#x27;Correcte&#x27;); Sinon Ecrire(&#x27;Incorrecte&#x27;); Fin Si;\nFin.</pre>\n<button class=\"course-solution-run\" data-code=\"Algorithme ParenthesesEquilibrees;\\nVar\\n    P : PileCaracteres;\\n    i : Entier;\\n    c, x : Caractere;\\n    ok : Booleen;\\nDebut\\n    InitialiserPile(P);\\n    ok := Vrai;\\n\\n    Pour i := 1 a Longueur(exp) Faire\\n        c := exp[i];\\n        Si c = '(' Alors\\n            Empiler(P, c);\\n        Sinon Si c = ')' Alors\\n            Si PileVide(P) Alors\\n                ok := Faux;\\n            Sinon\\n                Depiler(P, x);\\n            Fin Si;\\n        Fin Si;\\n    Fin Pour;\\n\\n    Si NON PileVide(P) Alors\\n        ok := Faux;\\n    Fin Si;\\n\\n    Si ok Alors Ecrire('Correcte'); Sinon Ecrire('Incorrecte'); Fin Si;\\nFin.\">Exécuter cette solution</button>\n</details>\n</div>\n\n<div class=\"course-exercise\">\n  <div class=\"course-exercise-title\"><i class=\"fas fa-code\"></i> Exercice B : décodage k[exp]</div>\n  <p>Décoder une chaîne comme <code class=\"course-inline-code\">3[a2[c]]</code> en utilisant des piles.</p>\n  <details class=\"course-solution-details\"><summary>Voir la solution complète</summary>\n<pre class=\"course-solution-code\">Algorithme DecoderChaine;\nVar\n    PNb : PileEntiers;\n    PStr : PileChaines;\n    nb : Entier;\n    c : Caractere;\n    courant, precedent : Chaine;\nDebut\n    InitialiserPile(PNb);\n    InitialiserPile(PStr);\n    nb := 0;\n    courant := &#x27;&#x27;;\n\n    Pour chaque caractere c de s Faire\n        Si EstChiffre(c) Alors\n            nb := nb * 10 + Valeur(c);\n        Sinon Si c = &#x27;[&#x27; Alors\n            Empiler(PNb, nb);\n            Empiler(PStr, courant);\n            nb := 0;\n            courant := &#x27;&#x27;;\n        Sinon Si c = &#x27;]&#x27; Alors\n            Depiler(PNb, nb);\n            Depiler(PStr, precedent);\n            courant := precedent + Repeter(courant, nb);\n        Sinon\n            courant := courant + c;\n        Fin Si;\n    Fin Pour;\n\n    Ecrire(courant);\nFin.</pre>\n<button class=\"course-solution-run\" data-code=\"Algorithme DecoderChaine;\\nVar\\n    PNb : PileEntiers;\\n    PStr : PileChaines;\\n    nb : Entier;\\n    c : Caractere;\\n    courant, precedent : Chaine;\\nDebut\\n    InitialiserPile(PNb);\\n    InitialiserPile(PStr);\\n    nb := 0;\\n    courant := '';\\n\\n    Pour chaque caractere c de s Faire\\n        Si EstChiffre(c) Alors\\n            nb := nb * 10 + Valeur(c);\\n        Sinon Si c = '[' Alors\\n            Empiler(PNb, nb);\\n            Empiler(PStr, courant);\\n            nb := 0;\\n            courant := '';\\n        Sinon Si c = ']' Alors\\n            Depiler(PNb, nb);\\n            Depiler(PStr, precedent);\\n            courant := precedent + Repeter(courant, nb);\\n        Sinon\\n            courant := courant + c;\\n        Fin Si;\\n    Fin Pour;\\n\\n    Ecrire(courant);\\nFin.\">Exécuter cette solution</button>\n</details>\n</div>"
    }
  ]
}
