
{
  "id": "files",
  "title": "Chapitre 10: Les Files (Queues)",
  "sections": [
    {
      "title": "1. Introduction : pourquoi les files ?",
      "content": "Certaines applications exigent un traitement strict dans l'ordre d'arrivée : premier arrivé, premier servi. Ce comportement est naturel dans la vie courante (files d'attente) et se retrouve dans de nombreux systèmes informatiques où l'équité temporelle est cruciale.\n\n### Exemples structurants :\n- **Spooler d'impression** : Lorsque plusieurs utilisateurs envoient des documents à une imprimante réseau, ceux-ci sont mis en file d'attente. Le premier document reçu est imprimé en premier, évitant ainsi les conflits et garantissant un ordre juste.\n- **Ordonnancement de processus** : Dans un système d'exploitation, les processus prêts à être exécutés sont placés dans une file d'attente (ready queue). L'ordonnanceur choisit le suivant selon une politique (FIFO, Round Robin, etc.). La file permet de modéliser l'attente du CPU et d'analyser des métriques comme le temps de réponse.\n- **Guichets et files d'attente réelles** : Banque, supermarché, péage – partout où des clients attendent un service. La discipline FIFO est souvent adoptée pour éviter les injustices (quelqu'un arrivé après ne doit pas passer devant).\n- **Buffers réseau** : Les routeurs et commutateurs stockent temporairement les paquets entrants dans des files avant de les retransmettre. Cela permet d'absorber les pics de trafic et de lisser les variations. En cas de saturation, des stratégies de rejet (drop) ou de priorité entrent en jeu.\n\n### Idée clé\nUne file est adaptée aux flux continus où l'équité temporelle est importante : on ne saute pas les anciens éléments pour traiter les nouveaux. Elle matérialise une attente organisée et prévisible."
    },
    {
      "title": "2. Définition FIFO et vocabulaire",
      "content": "Une file suit le principe **FIFO** (*First In, First Out*), ce qui signifie que l'élément qui a été inséré le premier sera le premier à être retiré. C'est l'inverse d'une pile (LIFO).\n\n- **Enfiler (Enqueue)** : action d'ajouter un élément à la **queue** de la file. L'élément devient le nouveau dernier.\n- **Défiler (Dequeue)** : action de retirer l'élément en **tête** de la file. L'élément suivant devient la nouvelle tête.\n\nLa tête est l'extrémité par laquelle on retire ; la queue est celle par laquelle on ajoute. Ces deux extrémités sont distinctes et ne se croisent jamais dans une file simple.\n\n<div class=\"course-diagram\">\n<svg viewBox=\"0 0 980 230\" role=\"img\" aria-label=\"Principe FIFO\">\n  <rect x=\"170\" y=\"78\" width=\"500\" height=\"70\" rx=\"12\" class=\"diagram-cell\"/>\n  <line x1=\"296\" y1=\"78\" x2=\"296\" y2=\"148\" class=\"diagram-split\"/>\n  <line x1=\"422\" y1=\"78\" x2=\"422\" y2=\"148\" class=\"diagram-split\"/>\n  <line x1=\"548\" y1=\"78\" x2=\"548\" y2=\"148\" class=\"diagram-split\"/>\n  <text x=\"220\" y=\"120\" class=\"diagram-main\">E1</text>\n  <text x=\"346\" y=\"120\" class=\"diagram-main\">E2</text>\n  <text x=\"472\" y=\"120\" class=\"diagram-main\">E3</text>\n  <text x=\"598\" y=\"120\" class=\"diagram-main\">E4</text>\n  <line x1=\"166\" y1=\"114\" x2=\"80\" y2=\"114\" class=\"diagram-arrow\"/>\n  <line x1=\"674\" y1=\"114\" x2=\"760\" y2=\"114\" class=\"diagram-arrow\"/>\n  <text x=\"38\" y=\"118\" class=\"diagram-caption\">Défiler (tête)</text>\n  <text x=\"770\" y=\"118\" class=\"diagram-caption\">Enfiler (queue)</text>\n  <text x=\"292\" y=\"44\" class=\"diagram-title\">Premier entré = premier sorti</text>\n</svg>\n</div>"
    },
    {
      "title": "3. Applications majeures des files",
      "content": "### 3.1 Spooler d'impression\nDans un environnement multi-utilisateur, les impressions sont mises en file d'attente avant d'être transmises à l'imprimante. Le premier document reçu est imprimé en premier, ce qui garantit la cohérence des demandes et évite les conflits d'accès. Si le flux d'entrée dépasse la vitesse d'impression, la file s'allonge : c'est un cas concret d'analyse de charge et de dimensionnement de buffer.\n\n### 3.2 Ordonnancement de processus\nLe système d'exploitation maintient une *ready queue* contenant tous les processus prêts à être exécutés. L'ordonnanceur choisit le prochain processus à élire selon une politique déterminée. La file modélise l'attente du CPU et permet de raisonner sur des indicateurs de performance tels que le temps d'attente moyen, le temps de turnaround et l'équité entre processus.\n\n### 3.3 Guichets et files d'attente réelles\nDans une banque, une caisse de supermarché ou un péage, les clients sont servis dans l'ordre d'arrivée. Cette discipline FIFO est simple à comprendre et perçue comme juste. Ces situations servent de base pour introduire des notions de théorie des files d'attente : temps d'attente moyen, longueur moyenne de la file, taux d'occupation du serveur.\n\n### 3.4 Buffers réseau\nLes routeurs et commutateurs stockent les paquets entrants dans des files avant de les retransmettre sur les liaisons sortantes. Ces files jouent un rôle d'amortissement face aux variations du trafic (bursts). En cas de saturation (file pleine), des politiques de gestion de congestion déterminent quels paquets sont rejetés (tail drop, RED, etc.) ou si des priorités sont appliquées."
    },
    {
      "title": "4. Primitives de manipulation",
      "content": "Le tableau ci-dessous synthétise les opérations essentielles d'une file chaînée. Chaque primitive est conçue pour être simple et efficace, avec une complexité constante O(1) lorsqu'elle est correctement implémentée.\n\n<div class=\"course-table-wrap\"><table class=\"course-table\"><thead><tr><th>Primitive</th><th>Rôle</th><th>Précondition</th><th>Complexité</th><th>Point de vigilance</th></tr></thead><tbody><tr><td><code class=\"course-inline-code\">InitialiserFile(F)</code></td><td>Créer une file vide</td><td>aucune</td><td>O(1)</td><td>Mettre <code class=\"course-inline-code\">tete := NIL</code> et <code class=\"course-inline-code\">queue := NIL</code>. Sans cette initialisation, les pointeurs contiennent des valeurs indéterminées.</td></tr><tr><td><code class=\"course-inline-code\">Enfiler(F, x)</code></td><td>Ajouter en queue</td><td>mémoire disponible</td><td>O(1)</td><td>Cas spécial file vide : il faut mettre à jour les deux pointeurs (tete et queue) pour qu'ils pointent vers le nouveau maillon.</td></tr><tr><td><code class=\"course-inline-code\">Defiler(F, x)</code></td><td>Retirer la tête dans <code class=\"course-inline-code\">x</code></td><td>file non vide</td><td>O(1)</td><td>Si le dernier élément est retiré, il faut remettre <code class=\"course-inline-code\">queue := NIL</code> pour refléter l'état vide.</td></tr><tr><td><code class=\"course-inline-code\">TeteFile(F)</code></td><td>Lire la tête sans retrait</td><td>file non vide</td><td>O(1)</td><td>Toujours vérifier la vacuité avant lecture, sinon accès mémoire illégal.</td></tr><tr><td><code class=\"course-inline-code\">FileVide(F)</code></td><td>Tester la vacuité</td><td>aucune</td><td>O(1)</td><td>Base de sécurité de toutes les opérations ; son résultat conditionne les appels à Defiler et TeteFile.</td></tr></tbody></table></div>"
    },
    {
      "title": "5. Représentation mémoire : tête + queue",
      "content": "Une file chaînée est pilotée par deux pointeurs :\n- `tete` pointe vers le premier élément (celui qui sera défilé en premier).\n- `queue` pointe vers le dernier élément (celui qui a été ajouté en dernier).\n\nCette double référence permet d'ajouter en queue et de retirer en tête en temps constant O(1), sans avoir à parcourir toute la liste.\n\nLa représentation ci-dessous illustre une file vide (les deux pointeurs à NIL) et une file contenant trois éléments (10, 20, 30). Les flèches montrent l'enchaînement des maillons.\n\n<div class=\"course-diagram\">\n<svg viewBox=\"0 0 1120 290\" role=\"img\" aria-label=\"File chaînée avec tête et queue\">\n  <text x=\"76\" y=\"54\" class=\"diagram-title\">File vide</text>\n  <rect x=\"40\" y=\"78\" width=\"340\" height=\"86\" rx=\"10\" class=\"diagram-cell\"/>\n  <text x=\"72\" y=\"116\" class=\"diagram-main\">tete = NIL</text>\n  <text x=\"72\" y=\"148\" class=\"diagram-main\">queue = NIL</text>\n  <line x1=\"470\" y1=\"26\" x2=\"470\" y2=\"264\" class=\"diagram-caption-line\"/>\n  <text x=\"622\" y=\"54\" class=\"diagram-title\">File avec 3 éléments</text>\n  <rect x=\"560\" y=\"96\" width=\"150\" height=\"62\" rx=\"10\" class=\"diagram-node\"/>\n  <line x1=\"640\" y1=\"96\" x2=\"640\" y2=\"158\" class=\"diagram-split\"/>\n  <text x=\"606\" y=\"134\" class=\"diagram-main\">10</text>\n  <rect x=\"760\" y=\"96\" width=\"150\" height=\"62\" rx=\"10\" class=\"diagram-node\"/>\n  <line x1=\"840\" y1=\"96\" x2=\"840\" y2=\"158\" class=\"diagram-split\"/>\n  <text x=\"806\" y=\"134\" class=\"diagram-main\">20</text>\n  <rect x=\"960\" y=\"96\" width=\"150\" height=\"62\" rx=\"10\" class=\"diagram-node\"/>\n  <line x1=\"1040\" y1=\"96\" x2=\"1040\" y2=\"158\" class=\"diagram-split\"/>\n  <text x=\"1006\" y=\"134\" class=\"diagram-main\">30</text>\n  <text x=\"1052\" y=\"134\" class=\"diagram-link\">NIL</text>\n  <line x1=\"712\" y1=\"126\" x2=\"758\" y2=\"126\" class=\"diagram-arrow\"/>\n  <line x1=\"912\" y1=\"126\" x2=\"958\" y2=\"126\" class=\"diagram-arrow\"/>\n  <text x=\"572\" y=\"84\" class=\"diagram-caption\">tete</text>\n  <line x1=\"600\" y1=\"86\" x2=\"600\" y2=\"92\" class=\"diagram-arrow\"/>\n  <text x=\"1002\" y=\"84\" class=\"diagram-caption\">queue</text>\n  <line x1=\"1030\" y1=\"86\" x2=\"1030\" y2=\"92\" class=\"diagram-arrow\"/>\n</svg>\n</div>"
    },
    {
      "title": "6. Déclaration des structures",
      "content": "La séparation entre `ElementFile` et `File` clarifie les responsabilités et améliore la modularité :\n- `ElementFile` décrit un maillon de la chaîne : il contient la valeur (`info`) et un pointeur vers l'élément suivant.\n- `File` encapsule l'état global de la file, avec deux pointeurs : `tete` (premier élément) et `queue` (dernier élément).\n\nCette organisation facilite la réutilisation des primitives et réduit les erreurs de manipulation des pointeurs, car on ne manipule jamais directement les maillons depuis l'extérieur de la file.",
      "code": "TYPE ElementFile = ENREGISTREMENT\nDebut\n    info : Entier;\n    suivant : ^ElementFile;\nFin;\n\nTYPE File = ENREGISTREMENT\nDebut\n    tete : ^ElementFile;\n    queue : ^ElementFile;\nFin;"
    },
    {
      "title": "7. Initialisation",
      "content": "L'initialisation est une étape cruciale pour la fiabilité : elle installe un état cohérent avant toute opération. Sans elle, les pointeurs `tete` et `queue` contiennent des valeurs aléatoires (ordures mémoire), ce qui rendrait les opérations ultérieures imprévisibles.\n\n**Invariant de départ** : `F.tete = NIL` et `F.queue = NIL`. Si cet invariant n'est pas respecté, les opérations `Enfiler` et `Defiler` ne peuvent pas distinguer correctement une file vide d'une file non vide.",
      "code": "PROCEDURE InitialiserFile(VAR F : File)\nDebut\n    F.tete := NIL;\n    F.queue := NIL;\nFin;"
    },
    {
      "title": "8. Enfiler (ajout à la queue)",
      "content": "L'opération d'ajout doit être réalisée avec soin pour maintenir la cohérence des deux pointeurs. Voici les étapes à suivre :\n1. Allouer un nouveau maillon `p`.\n2. Remplir son champ `info` avec la valeur `E` et mettre `suivant` à NIL (il sera le dernier élément).\n3. Si la file est vide (`F.tete = NIL`), alors la nouvelle tête et la nouvelle queue sont toutes les deux `p`.\n4. Sinon, accrocher le nouveau maillon à la suite de l'ancienne queue : `F.queue->suivant := p`.\n5. Dans tous les cas, mettre à jour la queue : `F.queue := p`.\n\n### Cas critique\nQuand la file est vide, il ne faut pas oublier de modifier également `tete`. L'oubli de cette mise à jour rendrait la file inutilisable (tête resterait NIL).",
      "code": "PROCEDURE Enfiler(VAR F : File; E : Entier)\nVar p : ^ElementFile;\nDebut\n    p := allouer(taille(ElementFile));\n    p->info := E;\n    p->suivant := NIL;\n\n    Si F.tete = NIL Alors\n        F.tete := p;\n    Sinon\n        F.queue->suivant := p;\n    Fin Si;\n\n    F.queue := p;\nFin;"
    },
    {
      "title": "9. Defiler (retrait de la tête)",
      "content": "Le retrait est symétrique à l'ajout mais nécessite aussi une gestion des cas particuliers :\n1. Vérifier que la file n'est pas vide (à l'aide de `FileVide`).\n2. Sauvegarder l'adresse de la tête actuelle dans une variable temporaire `p`.\n3. Lire la valeur de `p->info` pour la stocker dans le paramètre de sortie `sortie`.\n4. Avancer la tête : `F.tete := F.tete->suivant`.\n5. Si après ce déplacement la tête devient NIL, cela signifie que la file est devenue vide : il faut alors mettre `F.queue := NIL` pour respecter l'invariant.\n6. Libérer la mémoire de l'ancien maillon `p`.\n\nL'oubli de remettre `queue` à NIL quand la file devient vide est une erreur fréquente qui laisse `queue` pointer vers un élément libéré, source de bugs difficiles à détecter.",
      "code": "PROCEDURE Defiler(VAR F : File; VAR sortie : Entier)\nVar p : ^ElementFile;\nDebut\n    Si FileVide(F) Alors\n        Ecrire('Erreur: file vide');\n    Sinon\n        p := F.tete;\n        sortie := p->info;\n        F.tete := F.tete->suivant;\n        Si F.tete = NIL Alors\n            F.queue := NIL;\n        Fin Si;\n        liberer(p);\n    Fin Si;\nFin;"
    },
    {
      "title": "10. TeteFile et FileVide",
      "content": "Ces deux primitives jouent un rôle essentiel pour **sécuriser** les accès à la file.\n\n- `FileVide(F)` retourne Vrai si la file est vide (i.e., `F.tete = NIL`). Elle doit être utilisée avant tout appel à `Defiler` ou `TeteFile` pour éviter des erreurs.\n- `TeteFile(F)` retourne la valeur de l'élément en tête sans modifier la file. Elle suppose que la file n'est pas vide (c'est à l'appelant de vérifier).\n\nBonne pratique : toujours tester `FileVide` avant `TeteFile` et `Defiler`. Cela rend le code plus robuste et auto-documenté.",
      "code": "FONCTION TeteFile(F : File) : Entier\nDebut\n    Retourner F.tete->info;\nFin;\n\nFONCTION FileVide(F : File) : Booleen\nDebut\n    Retourner F.tete = NIL;\nFin;"
    },
    {
      "title": "11. Exercice guidé : création et affichage de la position k",
      "content": "<div class=\"course-exercise\">\n  <div class=\"course-exercise-title\"><i class=\"fas fa-puzzle-piece\"></i> Énoncé</div>\n  <p>Écrire un algorithme <code class=\"course-inline-code\">Creation</code> qui lit un entier N, puis N entiers, et les place dans une file. Ensuite, lire un entier k et afficher l'élément situé à la position k (en commençant à 1 pour la tête). Si k dépasse la taille de la file, afficher un message d'erreur. On utilisera uniquement les primitives de la file (pas d'accès direct aux pointeurs).</p>\n  <p><strong>Indice :</strong> Pour atteindre la position k, il faut défiler les k-1 premiers éléments et les remettre en queue, afin de préserver la file. Ainsi, après k-1 rotations, la tête est l'élément recherché.</p>\n  <details class=\"course-solution-details\"><summary>Voir la solution complète</summary>\n<pre class=\"course-solution-code\">Algorithme ExoFile_PositionK;\nType ElementFile = Enregistrement\nDebut\n    info : Entier;\n    suivant : ^ElementFile;\nFin;\nType File = Enregistrement\nDebut\n    tete : ^ElementFile;\n    queue : ^ElementFile;\nFin;\nVar\n    F : File;\n    N, i, x, k, val : Entier;\n\nProcedure InitialiserFile(Var F : File);\nDebut\n    F.tete := NIL;\n    F.queue := NIL;\nFin;\n\nProcedure Enfiler(Var F : File; v : Entier);\nVar p : ^ElementFile;\nDebut\n    p := allouer(taille(ElementFile));\n    p-&gt;info := v;\n    p-&gt;suivant := NIL;\n    Si F.tete = NIL Alors\n        F.tete := p;\n    Sinon\n        F.queue-&gt;suivant := p;\n    Fin Si;\n    F.queue := p;\nFin;\n\nProcedure Defiler(Var F : File; Var v : Entier);\nVar p : ^ElementFile;\nDebut\n    p := F.tete;\n    v := p-&gt;info;\n    F.tete := F.tete-&gt;suivant;\n    Si F.tete = NIL Alors\n        F.queue := NIL;\n    Fin Si;\n    liberer(p);\nFin;\n\nFONCTION FileVide(F : File) : Booleen;\nDebut\n    Retourner F.tete = NIL;\nFin;\n\nDebut\n    InitialiserFile(F);\n    Lire(N);\n    Pour i := 1 a N Faire\n        Lire(x);\n        Enfiler(F, x);\n    Fin Pour;\n\n    Lire(k);\n    i := 1;\n    Tantque (NON FileVide(F)) Et (i &lt; k) Faire\n        Defiler(F, val);\n        Enfiler(F, val);\n        i := i + 1;\n    Fin Tantque;\n\n    Si FileVide(F) Alors\n        Ecrire('Position inexistante');\n    Sinon\n        Ecrire('Element position ', k, ' = ', F.tete-&gt;info);\n    Fin Si;\nFin.</pre>\n<button class=\"course-solution-run\" data-code=\"Algorithme ExoFile_PositionK;\\nType ElementFile = Enregistrement\\nDebut\\n    info : Entier;\\n    suivant : ^ElementFile;\\nFin;\\nType File = Enregistrement\\nDebut\\n    tete : ^ElementFile;\\n    queue : ^ElementFile;\\nFin;\\nVar\\n    F : File;\\n    N, i, x, k, val : Entier;\\n\\nProcedure InitialiserFile(Var F : File);\\nDebut\\n    F.tete := NIL;\\n    F.queue := NIL;\\nFin;\\n\\nProcedure Enfiler(Var F : File; v : Entier);\\nVar p : ^ElementFile;\\nDebut\\n    p := allouer(taille(ElementFile));\\n    p->info := v;\\n    p->suivant := NIL;\\n    Si F.tete = NIL Alors\\n        F.tete := p;\\n    Sinon\\n        F.queue->suivant := p;\\n    Fin Si;\\n    F.queue := p;\\nFin;\\n\\nProcedure Defiler(Var F : File; Var v : Entier);\\nVar p : ^ElementFile;\\nDebut\\n    p := F.tete;\\n    v := p->info;\\n    F.tete := F.tete->suivant;\\n    Si F.tete = NIL Alors\\n        F.queue := NIL;\\n    Fin Si;\\n    liberer(p);\\nFin;\\n\\nFONCTION FileVide(F : File) : Booleen;\\nDebut\\n    Retourner F.tete = NIL;\\nFin;\\n\\nDebut\\n    InitialiserFile(F);\\n    Lire(N);\\n    Pour i := 1 a N Faire\\n        Lire(x);\\n        Enfiler(F, x);\\n    Fin Pour;\\n\\n    Lire(k);\\n    i := 1;\\n    Tantque (NON FileVide(F)) Et (i < k) Faire\\n        Defiler(F, val);\\n        Enfiler(F, val);\\n        i := i + 1;\\n    Fin Tantque;\\n\\n    Si FileVide(F) Alors\\n        Ecrire('Position inexistante');\\n    Sinon\\n        Ecrire('Element position ', k, ' = ', F.tete->info);\\n    Fin Si;\\nFin.\">Exécuter cette solution</button>\n</details>\n</div>"
    },
    {
      "title": "12. Exercice guidé : inversion d'une file avec une pile",
      "content": "<div class=\"course-exercise\">\n  <div class=\"course-exercise-title\"><i class=\"fas fa-random\"></i> Énoncé</div>\n  <p>Écrire un algorithme qui inverse l'ordre des éléments d'une file en utilisant uniquement les opérations de file et une pile auxiliaire. On ne doit pas utiliser de tableau ni d'accès direct aux maillons.</p>\n  <p><strong>Principe :</strong> On dépile tous les éléments de la file et on les empile dans une pile. Puis on dépile la pile et on ré-enfile chaque élément. Comme une pile est LIFO, l'ordre se trouvera inversé.</p>\n  <details class=\"course-solution-details\"><summary>Voir la solution complète</summary>\n<pre class=\"course-solution-code\">Algorithme InverserFile;\nVar\n    F : File;\n    P : ^Pile;\n    x : Entier;\nDebut\n    Tantque NON FileVide(F) Faire\n        Defiler(F, x);\n        Empiler(P, x);\n    Fin Tantque;\n\n    Tantque NON PileVide(P) Faire\n        Depiler(P, x);\n        Enfiler(F, x);\n    Fin Tantque;\nFin.</pre>\n<button class=\"course-solution-run\" data-code=\"Algorithme InverserFile;\\nVar\\n    F : File;\\n    P : ^Pile;\\n    x : Entier;\\nDebut\\n    Tantque NON FileVide(F) Faire\\n        Defiler(F, x);\\n        Empiler(P, x);\\n    Fin Tantque;\\n\\n    Tantque NON PileVide(P) Faire\\n        Depiler(P, x);\\n        Enfiler(F, x);\\n    Fin Tantque;\\nFin.\">Exécuter cette solution</button>\n</details>\n</div>"
    },
    {
      "title": "13. Exercice guidé : file circulaire (tableau)",
      "content": "<div class=\"course-exercise\">\n  <div class=\"course-exercise-title\"><i class=\"fas fa-sync-alt\"></i> Énoncé</div>\n  <p>Implémenter une file circulaire de taille fixe <code class=\"course-inline-code\">N</code> à l'aide d'un tableau. On utilisera les indices <code class=\"course-inline-code\">tete</code> (premier élément), <code class=\"course-inline-code\">queue</code> (dernier élément) et un compteur <code class=\"course-inline-code\">nbElements</code> pour distinguer le cas plein du cas vide. Les indices évoluent modulo N.</p>\n  <p><strong>Explication :</strong> Dans une file circulaire, on réutilise les cases libérées en tête. Lorsqu'on ajoute un élément, on incrémente <code>queue</code> modulo N ; lorsqu'on retire, on incrémente <code>tete</code> modulo N. Le compteur d'éléments évite de confondre file pleine et file vide (qui toutes deux auraient <code>tete == queue</code> si on n'utilisait pas ce compteur).</p>\n  <details class=\"course-solution-details\"><summary>Voir la solution complète</summary>\n<pre class=\"course-solution-code\">Algorithme FileCirculaire;\nConst NMAX = 100;\nType FileC = Enregistrement\nDebut\n    Tab[0..NMAX-1] : Entier;\n    N, tete, queue, nbElements : Entier;\nFin;\nVar\n    F : FileC;\n    x : Entier;\n\nProcedure InitialiserFileCirculaire(Var F : FileC; N : Entier);\nDebut\n    F.N := N;\n    F.tete := 0;\n    F.queue := -1;\n    F.nbElements := 0;\nFin;\n\nProcedure EnfilerCirculaire(Var F : FileC; v : Entier);\nDebut\n    Si F.nbElements = F.N Alors\n        Ecrire('File pleine');\n    Sinon\n        F.queue := (F.queue + 1) mod F.N;\n        F.Tab[F.queue] := v;\n        F.nbElements := F.nbElements + 1;\n    Fin Si;\nFin;\n\nProcedure DefilerCirculaire(Var F : FileC; Var v : Entier);\nDebut\n    Si F.nbElements = 0 Alors\n        Ecrire('File vide');\n    Sinon\n        v := F.Tab[F.tete];\n        F.tete := (F.tete + 1) mod F.N;\n        F.nbElements := F.nbElements - 1;\n    Fin Si;\nFin;\n\nDebut\n    InitialiserFileCirculaire(F, 5);\n    EnfilerCirculaire(F, 10);\n    EnfilerCirculaire(F, 20);\n    EnfilerCirculaire(F, 30);\n    DefilerCirculaire(F, x);\n    Ecrire('Sortie=', x);\nFin.</pre>\n<button class=\"course-solution-run\" data-code=\"Algorithme FileCirculaire;\\nConst NMAX = 100;\\nType FileC = Enregistrement\\nDebut\\n    Tab[0..NMAX-1] : Entier;\\n    N, tete, queue, nbElements : Entier;\\nFin;\\nVar\\n    F : FileC;\\n    x : Entier;\\n\\nProcedure InitialiserFileCirculaire(Var F : FileC; N : Entier);\\nDebut\\n    F.N := N;\\n    F.tete := 0;\\n    F.queue := -1;\\n    F.nbElements := 0;\\nFin;\\n\\nProcedure EnfilerCirculaire(Var F : FileC; v : Entier);\\nDebut\\n    Si F.nbElements = F.N Alors\\n        Ecrire('File pleine');\\n    Sinon\\n        F.queue := (F.queue + 1) mod F.N;\\n        F.Tab[F.queue] := v;\\n        F.nbElements := F.nbElements + 1;\\n    Fin Si;\\nFin;\\n\\nProcedure DefilerCirculaire(Var F : FileC; Var v : Entier);\\nDebut\\n    Si F.nbElements = 0 Alors\\n        Ecrire('File vide');\\n    Sinon\\n        v := F.Tab[F.tete];\\n        F.tete := (F.tete + 1) mod F.N;\\n        F.nbElements := F.nbElements - 1;\\n    Fin Si;\\nFin;\\n\\nDebut\\n    InitialiserFileCirculaire(F, 5);\\n    EnfilerCirculaire(F, 10);\\n    EnfilerCirculaire(F, 20);\\n    EnfilerCirculaire(F, 30);\\n    DefilerCirculaire(F, x);\\n    Ecrire('Sortie=', x);\\nFin.\">Exécuter cette solution</button>\n</details>\n</div>"
    },
    {
      "title": "14. Complexité et pièges fréquents",
      "content": "Le tableau ci-dessous présente les coûts temporels et les erreurs courantes sur les opérations de file. Il est essentiel de bien comprendre ces points pour écrire des algorithmes robustes.\n\n<div class=\"course-table-wrap\"><table class=\"course-table\"><thead><tr><th>Opération</th><th>Complexité</th><th>Piège fréquent</th><th>Bonne pratique</th></tr></thead><tbody><tr><td>Enfiler (liste chaînée)</td><td>O(1)</td><td>oublier de mettre <code class=\"course-inline-code\">queue</code> à jour dans le cas d'une file vide</td><td>mettre à jour `queue` dans tous les cas (file vide et non vide)</td></tr><tr><td>Defiler</td><td>O(1)</td><td>ne pas remettre <code class=\"course-inline-code\">queue := NIL</code> quand la file devient vide</td><td>après retrait, si <code class=\"course-inline-code\">tete = NIL</code> alors <code class=\"course-inline-code\">queue := NIL</code></td></tr><tr><td>TeteFile</td><td>O(1)</td><td>consulter une file vide</td><td>tester <code class=\"course-inline-code\">FileVide(F)</code> avant lecture</td></tr><tr><td>Recherche d'un élément</td><td>O(n)</td><td>oublier de préserver l'ordre en manipulant la file (par exemple, détruire la file en cherchant)</td><td>utiliser une file auxiliaire pour stocker temporairement les éléments, ou restaurer l'ordre après parcours</td></tr></tbody></table></div>\n\n### Lecture pédagogique\n- Les opérations structurelles (`Enfiler`, `Defiler`, `TeteFile`) sont constantes sur une file chaînée, car on dispose des pointeurs directs vers les extrémités.\n- La recherche (ou tout parcours) est linéaire car l'accès est séquentiel : on doit défiler les éléments un par un.\n- Les erreurs les plus fréquentes proviennent des cas limites (file vide, dernier élément) et de la gestion incorrecte des pointeurs. Une bonne pratique est de toujours tester la vacuité et de commenter les invariants."
    },
    {
      "title": "15. Exercices supplémentaires sur les files (4)",
      "content": "Ces exercices renforcent la maîtrise des files FIFO sur des cas classiques de parcours, rotation, fusion et simulation de service. Ils sont conçus pour être résolus uniquement avec les primitives de file.\n\n<div class=\"course-exercise\">\n  <div class=\"course-exercise-title\"><i class=\"fas fa-redo\"></i> Exercice A : rotation de file</div>\n  <p><strong>Objectif :</strong> Effectuer une rotation à droite de <code>k</code> positions sur une file de <code>n</code> éléments. Une rotation à droite consiste à déplacer les éléments de la fin vers le début. Par exemple, une rotation à droite de 2 sur [1,2,3,4,5] donne [4,5,1,2,3].</p>\n  <p><strong>Point d'attention :</strong> Penser à réduire <code>k</code> via <code>k mod n</code> pour éviter les rotations inutiles (si k >= n). On peut réaliser la rotation en défilant et en ré-enfilant les éléments, mais le nombre de déplacements dépend du sens choisi.</p>\n  <details class=\"course-solution-details\"><summary>Voir la solution complète</summary>\n<pre class=\"course-solution-code\">Algorithme ExoFile_RotationDroite;\nVar\n    F : File;\n    n, k, i, x : Entier;\nDebut\n    Lire(n);\n    Pour i := 1 a n Faire\n        Lire(x);\n        Enfiler(F, x);\n    Fin Pour;\n\n    Lire(k);\n    Si n &gt; 0 Alors\n        k := k mod n;\n        Pour i := 1 a n-k Faire\n            Defiler(F, x);\n            Enfiler(F, x);\n        Fin Pour;\n    Fin Si;\n\n    Tantque NON FileVide(F) Faire\n        Defiler(F, x);\n        Ecrire(x);\n    Fin Tantque;\nFin.</pre>\n<button class=\"course-solution-run\" data-code=\"Algorithme ExoFile_RotationDroite;\\nVar\\n    F : File;\\n    n, k, i, x : Entier;\\nDebut\\n    Lire(n);\\n    Pour i := 1 a n Faire\\n        Lire(x);\\n        Enfiler(F, x);\\n    Fin Pour;\\n\\n    Lire(k);\\n    Si n > 0 Alors\\n        k := k mod n;\\n        Pour i := 1 a n-k Faire\\n            Defiler(F, x);\\n            Enfiler(F, x);\\n        Fin Pour;\\n    Fin Si;\\n\\n    Tantque NON FileVide(F) Faire\\n        Defiler(F, x);\\n        Ecrire(x);\\n    Fin Tantque;\\nFin.\">Exécuter cette solution</button>\n</details>\n</div>\n\n<div class=\"course-exercise\">\n  <div class=\"course-exercise-title\"><i class=\"fas fa-code-branch\"></i> Exercice B : fusion de deux files triées</div>\n  <p><strong>Objectif :</strong> Fusionner deux files triées en ordre croissant dans une troisième file, également triée. On ne doit utiliser que les opérations de file, pas de tableau intermédiaire.</p>\n  <p><strong>Point d'attention :</strong> Il faut conserver les valeurs déjà défilées lors des comparaisons. Une méthode classique consiste à défilier le premier élément de chaque file, puis à comparer et enfiler le plus petit, puis à défilier l'élément suivant de la file correspondante, et ainsi de suite.</p>\n  <details class=\"course-solution-details\"><summary>Voir la solution complète</summary>\n<pre class=\"course-solution-code\">Algorithme ExoFile_FusionTriee;\nVar\n    F1, F2, F3 : File;\n    x, y : Entier;\n    ok1, ok2 : Booleen;\nDebut\n    ok1 := NON FileVide(F1);\n    ok2 := NON FileVide(F2);\n\n    Si ok1 Alors Defiler(F1, x); Fin Si;\n    Si ok2 Alors Defiler(F2, y); Fin Si;\n\n    Tantque ok1 Et ok2 Faire\n        Si x &lt;= y Alors\n            Enfiler(F3, x);\n            ok1 := NON FileVide(F1);\n            Si ok1 Alors Defiler(F1, x); Fin Si;\n        Sinon\n            Enfiler(F3, y);\n            ok2 := NON FileVide(F2);\n            Si ok2 Alors Defiler(F2, y); Fin Si;\n        Fin Si;\n    Fin Tantque;\n\n    Si ok1 Alors\n        Enfiler(F3, x);\n        Tantque NON FileVide(F1) Faire Defiler(F1, x); Enfiler(F3, x); Fin Tantque;\n    Fin Si;\n\n    Si ok2 Alors\n        Enfiler(F3, y);\n        Tantque NON FileVide(F2) Faire Defiler(F2, y); Enfiler(F3, y); Fin Tantque;\n    Fin Si;\nFin.</pre>\n<button class=\"course-solution-run\" data-code=\"Algorithme ExoFile_FusionTriee;\\nVar\\n    F1, F2, F3 : File;\\n    x, y : Entier;\\n    ok1, ok2 : Booleen;\\nDebut\\n    ok1 := NON FileVide(F1);\\n    ok2 := NON FileVide(F2);\\n\\n    Si ok1 Alors Defiler(F1, x); Fin Si;\\n    Si ok2 Alors Defiler(F2, y); Fin Si;\\n\\n    Tantque ok1 Et ok2 Faire\\n        Si x <= y Alors\\n            Enfiler(F3, x);\\n            ok1 := NON FileVide(F1);\\n            Si ok1 Alors Defiler(F1, x); Fin Si;\\n        Sinon\\n            Enfiler(F3, y);\\n            ok2 := NON FileVide(F2);\\n            Si ok2 Alors Defiler(F2, y); Fin Si;\\n        Fin Si;\\n    Fin Tantque;\\n\\n    Si ok1 Alors\\n        Enfiler(F3, x);\\n        Tantque NON FileVide(F1) Faire Defiler(F1, x); Enfiler(F3, x); Fin Tantque;\\n    Fin Si;\\n\\n    Si ok2 Alors\\n        Enfiler(F3, y);\\n        Tantque NON FileVide(F2) Faire Defiler(F2, y); Enfiler(F3, y); Fin Tantque;\\n    Fin Si;\\nFin.\">Exécuter cette solution</button>\n</details>\n</div>\n\n<div class=\"course-exercise\">\n  <div class=\"course-exercise-title\"><i class=\"fas fa-text-height\"></i> Exercice C : test de palindrome</div>\n  <p><strong>Objectif :</strong> Vérifier si une chaîne de caractères est un palindrome (elle se lit identiquement dans les deux sens) en utilisant une file et une pile.</p>\n  <p><strong>Point d'attention :</strong> On place chaque caractère à la fois dans une file (ordre normal) et dans une pile (ordre inverse). Ensuite, on compare caractère par caractère en défilant et dépilant simultanément. Dès qu'une différence apparaît, ce n'est pas un palindrome.</p>\n  <details class=\"course-solution-details\"><summary>Voir la solution complète</summary>\n<pre class=\"course-solution-code\">Algorithme ExoFile_Palindrome;\nVar\n    F : File;\n    P : ^Pile;\n    s : Chaine;\n    i : Entier;\n    c1, c2 : Caractere;\n    ok : Booleen;\nDebut\n    Lire(s);\n    ok := Vrai;\n\n    Pour i := 1 a Longueur(s) Faire\n        Enfiler(F, s[i]);\n        Empiler(P, s[i]);\n    Fin Pour;\n\n    Tantque (NON FileVide(F)) Et ok Faire\n        Defiler(F, c1);\n        Depiler(P, c2);\n        Si c1 &lt;&gt; c2 Alors\n            ok := Faux;\n        Fin Si;\n    Fin Tantque;\n\n    Si ok Alors Ecrire('Palindrome'); Sinon Ecrire('Non palindrome'); Fin Si;\nFin.</pre>\n<button class=\"course-solution-run\" data-code=\"Algorithme ExoFile_Palindrome;\\nVar\\n    F : File;\\n    P : ^Pile;\\n    s : Chaine;\\n    i : Entier;\\n    c1, c2 : Caractere;\\n    ok : Booleen;\\nDebut\\n    Lire(s);\\n    ok := Vrai;\\n\\n    Pour i := 1 a Longueur(s) Faire\\n        Enfiler(F, s[i]);\\n        Empiler(P, s[i]);\\n    Fin Pour;\\n\\n    Tantque (NON FileVide(F)) Et ok Faire\\n        Defiler(F, c1);\\n        Depiler(P, c2);\\n        Si c1 <> c2 Alors\\n            ok := Faux;\\n        Fin Si;\\n    Fin Tantque;\\n\\n    Si ok Alors Ecrire('Palindrome'); Sinon Ecrire('Non palindrome'); Fin Si;\\nFin.\">Exécuter cette solution</button>\n</details>\n</div>\n\n<div class=\"course-exercise\">\n  <div class=\"course-exercise-title\"><i class=\"fas fa-users\"></i> Exercice D : simulation de guichet</div>\n  <p><strong>Objectif :</strong> Simuler un guichet unique où les clients sont traités dans l'ordre FIFO. On lit d'abord le nombre de clients, puis pour chaque client on lit son identifiant (ou numéro) et on l'enfile. Ensuite, on sert les clients un par un en affichant leur identifiant dans l'ordre.</p>\n  <p><strong>Point d'attention :</strong> Il est essentiel de respecter strictement l'ordre d'arrivée ; on ne doit jamais sauter de client. Cette simulation illustre simplement le comportement FIFO.</p>\n  <details class=\"course-solution-details\"><summary>Voir la solution complète</summary>\n<pre class=\"course-solution-code\">Algorithme ExoFile_SimulationGuichet;\nVar\n    F : File;\n    n, i, service, client : Entier;\nDebut\n    Lire(n); // nombre de clients\n    Pour i := 1 a n Faire\n        Lire(client);\n        Enfiler(F, client);\n    Fin Pour;\n\n    service := 1;\n    Tantque NON FileVide(F) Faire\n        Defiler(F, client);\n        Ecrire('Service ', service, ': client ', client);\n        service := service + 1;\n    Fin Tantque;\nFin.</pre>\n<button class=\"course-solution-run\" data-code=\"Algorithme ExoFile_SimulationGuichet;\\nVar\\n    F : File;\\n    n, i, service, client : Entier;\\nDebut\\n    Lire(n); // nombre de clients\\n    Pour i := 1 a n Faire\\n        Lire(client);\\n        Enfiler(F, client);\\n    Fin Pour;\\n\\n    service := 1;\\n    Tantque NON FileVide(F) Faire\\n        Defiler(F, client);\\n        Ecrire('Service ', service, ': client ', client);\\n        service := service + 1;\\n    Fin Tantque;\\nFin.\">Exécuter cette solution</button>\n</details>\n</div>"
    }
  ]
}
