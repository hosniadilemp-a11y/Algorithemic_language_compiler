{
  "id": "listes",
  "title": "Chapitre 8: Les Listes Chaînées",
  "sections": [
    {
      "title": "Problème: limites des tableaux",
      "content": "Pour stocker des séries de valeurs, les tableaux sont efficaces mais rigides.\n\n### Limites clés\n- **Taille fixe** : un tableau déclaré avec 10 cases ne peut pas accueillir un 11e élément sans être redimensionné (ce qui implique une copie coûteuse).\n- **Insertion au milieu coûteuse** : pour insérer une valeur à la position i, il faut décaler tous les éléments à partir de i vers la droite. Cela nécessite en moyenne n/2 décalages.\n- **Suppression coûteuse** : de même, supprimer un élément demande un décalage vers la gauche pour combler le vide.\n- **Gaspillage mémoire** : si on prévoit trop grand, on occupe de la mémoire inutilisée ; trop petit, on manque de place.\n\n### Intuition\nLe tableau est un bloc contigu en mémoire : très bon pour l'accès direct `T[i]` (temps constant), mais moins bon pour les modifications structurelles fréquentes.\n\n[[NOTE]] Les listes chaînées sont une réponse naturelle quand la structure doit évoluer dynamiquement pendant l'exécution, sans connaître à l'avance le nombre d'éléments."
    },
    {
      "title": "Introduction: pourquoi les listes chaînées",
      "content": "Une liste chaînée est une structure **dynamique** où chaque élément (maillon) contient une information et un pointeur vers l'élément suivant. Contrairement au tableau, les maillons ne sont pas forcément contigus en mémoire ; le lien logique est assuré par le pointeur.\n\n### Cas d'usage\n- flux de données de taille inconnue (lecture depuis un fichier, saisie utilisateur) ;\n- insertions et suppressions fréquentes, surtout en tête ou en milieu (coût O(1) une fois la position connue) ;\n- implémentation de structures dynamiques comme les piles, les files, les graphes.\n\n### Pièges à éviter\n- perdre la tête de liste (le seul point d'entrée) en modifiant le pointeur `Tete` sans le conserver ;\n- modifier les pointeurs dans le mauvais ordre (par exemple, couper le chaînage avant d'avoir récupéré le suivant) ;\n- oublier de libérer la mémoire des maillons supprimés (fuite mémoire)."
    },
    {
      "title": "Définition d'une liste chaînée (adresse / info / suivant)",
      "content": "Chaque nœud (maillon) contient trois champs essentiels :\n- **Adresse** : identifie le maillon en mémoire (ex: `@100`). C'est la valeur du pointeur.\n- **Information** : la valeur utile stockée (ex: `15`).\n- **Suivant** : l'adresse du prochain maillon, ou `NIL` si la liste se termine.\n\n### Intuition\nUne liste chaînée est une \"chaîne d'adresses\". Pour aller au maillon suivant, on ne calcule pas un indice : on suit le pointeur `suivant`. Le dernier maillon a son champ `suivant` à `NIL`, ce qui marque la fin.\n\n<div class=\"course-diagram\">\n<svg viewBox=\"0 0 980 300\" role=\"img\" aria-label=\"Structure d'un nœud et chaînage\">\n  <defs>\n    <marker id=\"d8-def-a\" markerWidth=\"10\" markerHeight=\"8\" refX=\"9\" refY=\"4\" orient=\"auto\">\n      <path d=\"M0,0 L10,4 L0,8 z\" fill=\"currentColor\"/>\n    </marker>\n  </defs>\n\n  <text x=\"120\" y=\"30\" class=\"diagram-title\">Maillon 1</text>\n  <rect x=\"96\" y=\"44\" width=\"74\" height=\"24\" rx=\"6\" class=\"diagram-cell\"/>\n  <text x=\"116\" y=\"61\" class=\"diagram-addr\">@100</text>\n\n  <rect x=\"80\" y=\"82\" width=\"260\" height=\"92\" rx=\"12\" class=\"diagram-node\"/>\n  <line x1=\"220\" y1=\"82\" x2=\"220\" y2=\"174\" class=\"diagram-split\"/>\n  <text x=\"135\" y=\"136\" class=\"diagram-main\">15</text>\n  <text x=\"247\" y=\"136\" class=\"diagram-link\">@480</text>\n\n  <text x=\"550\" y=\"30\" class=\"diagram-title\">Maillon 2</text>\n  <rect x=\"526\" y=\"44\" width=\"74\" height=\"24\" rx=\"6\" class=\"diagram-cell\"/>\n  <text x=\"546\" y=\"61\" class=\"diagram-addr\">@480</text>\n\n  <rect x=\"510\" y=\"82\" width=\"260\" height=\"92\" rx=\"12\" class=\"diagram-node\"/>\n  <line x1=\"650\" y1=\"82\" x2=\"650\" y2=\"174\" class=\"diagram-split\"/>\n  <text x=\"565\" y=\"136\" class=\"diagram-main\">10</text>\n  <text x=\"684\" y=\"136\" class=\"diagram-link\">NIL</text>\n\n  <line x1=\"342\" y1=\"128\" x2=\"508\" y2=\"128\" class=\"diagram-arrow\" marker-end=\"url(#d8-def-a)\"/>\n\n  <text x=\"116\" y=\"220\" class=\"diagram-caption\">Partie information</text>\n  <line x1=\"178\" y1=\"210\" x2=\"158\" y2=\"176\" class=\"diagram-caption-line\"/>\n\n  <text x=\"246\" y=\"220\" class=\"diagram-caption\">Champ suivant</text>\n  <line x1=\"300\" y1=\"210\" x2=\"280\" y2=\"176\" class=\"diagram-caption-line\"/>\n\n  <text x=\"508\" y=\"220\" class=\"diagram-caption\">Dernier maillon : suivant = NIL</text>\n</svg>\n</div>\n\n### Pièges fréquents\n- confondre l'adresse du maillon et la valeur stockée ;\n- oublier `NIL` sur le dernier maillon (la liste n'aurait pas de fin) ;\n- perdre une adresse avant de relier le nouveau pointeur, ce qui rend certains maillons inaccessibles."
    },
    {
      "title": "Représentation mémoire: Tableau vs Liste",
      "content": "Comparer tableau et liste chaînée aide à comprendre quand choisir l'une ou l'autre structure. Le schéma ci-dessous illustre la différence fondamentale : le tableau occupe une zone contiguë, la liste est dispersée et liée par des pointeurs.\n\n<div class=\"course-diagram\">\n<svg viewBox=\"0 0 1120 360\" role=\"img\" aria-label=\"Comparaison mémoire tableau et liste chaînée\">\n  <defs>\n    <marker id=\"d8-def-b\" markerWidth=\"10\" markerHeight=\"8\" refX=\"9\" refY=\"4\" orient=\"auto\">\n      <path d=\"M0,0 L10,4 L0,8 z\" fill=\"currentColor\"/>\n    </marker>\n  </defs>\n\n  <line x1=\"555\" y1=\"26\" x2=\"555\" y2=\"334\" class=\"diagram-caption-line\"/>\n\n  <text x=\"120\" y=\"48\" class=\"diagram-title\">Tableau (mémoire contiguë)</text>\n  <rect x=\"56\" y=\"84\" width=\"88\" height=\"64\" class=\"diagram-cell\"/>\n  <rect x=\"144\" y=\"84\" width=\"88\" height=\"64\" class=\"diagram-cell\"/>\n  <rect x=\"232\" y=\"84\" width=\"88\" height=\"64\" class=\"diagram-cell\"/>\n  <rect x=\"320\" y=\"84\" width=\"88\" height=\"64\" class=\"diagram-cell\"/>\n  <text x=\"90\" y=\"124\" class=\"diagram-main\">12</text>\n  <text x=\"178\" y=\"124\" class=\"diagram-main\">5</text>\n  <text x=\"266\" y=\"124\" class=\"diagram-main\">8</text>\n  <text x=\"354\" y=\"124\" class=\"diagram-main\">3</text>\n  <text x=\"76\" y=\"172\" class=\"diagram-addr\">@100</text>\n  <text x=\"164\" y=\"172\" class=\"diagram-addr\">@101</text>\n  <text x=\"252\" y=\"172\" class=\"diagram-addr\">@102</text>\n  <text x=\"340\" y=\"172\" class=\"diagram-addr\">@103</text>\n  <text x=\"58\" y=\"210\" class=\"diagram-caption\">Lecture directe : T[i] en O(1)</text>\n\n  <text x=\"705\" y=\"48\" class=\"diagram-title\">Liste chaînée (mémoire dispersée)</text>\n\n  <rect x=\"650\" y=\"88\" width=\"190\" height=\"62\" rx=\"10\" class=\"diagram-node\"/>\n  <line x1=\"748\" y1=\"88\" x2=\"748\" y2=\"150\" class=\"diagram-split\"/>\n  <text x=\"692\" y=\"126\" class=\"diagram-main\">12</text>\n  <text x=\"768\" y=\"126\" class=\"diagram-link\">@520</text>\n  <text x=\"676\" y=\"170\" class=\"diagram-addr\">@100</text>\n\n  <rect x=\"870\" y=\"206\" width=\"190\" height=\"62\" rx=\"10\" class=\"diagram-node\"/>\n  <line x1=\"968\" y1=\"206\" x2=\"968\" y2=\"268\" class=\"diagram-split\"/>\n  <text x=\"914\" y=\"244\" class=\"diagram-main\">5</text>\n  <text x=\"988\" y=\"244\" class=\"diagram-link\">@360</text>\n  <text x=\"896\" y=\"288\" class=\"diagram-addr\">@520</text>\n\n  <rect x=\"650\" y=\"236\" width=\"190\" height=\"62\" rx=\"10\" class=\"diagram-node\"/>\n  <line x1=\"748\" y1=\"236\" x2=\"748\" y2=\"298\" class=\"diagram-split\"/>\n  <text x=\"692\" y=\"274\" class=\"diagram-main\">8</text>\n  <text x=\"774\" y=\"274\" class=\"diagram-link\">NIL</text>\n  <text x=\"676\" y=\"318\" class=\"diagram-addr\">@360</text>\n\n  <line x1=\"844\" y1=\"118\" x2=\"868\" y2=\"236\" class=\"diagram-arrow\" marker-end=\"url(#d8-def-b)\"/>\n  <line x1=\"1064\" y1=\"236\" x2=\"842\" y2=\"266\" class=\"diagram-arrow\" marker-end=\"url(#d8-def-b)\"/>\n\n  <text x=\"648\" y=\"332\" class=\"diagram-caption\">Accès position k : parcours nécessaire (O(n))</text>\n</svg>\n</div>\n\n### Lecture du schéma\n- **Tableau** : les cases sont côte à côte, les adresses se suivent (`@100`, `@101`, ...). Cela permet un calcul direct de l'adresse d'un élément à partir de son indice.\n- **Liste** : les maillons peuvent être placés n'importe où en mémoire ; le lien logique est assuré par le champ `suivant`. L'adresse du deuxième maillon (`@520`) est stockée dans le premier, etc.\n\n### Conséquences algorithmiques\n- accès indexé dans un tableau : `O(1)`.\n- accès à la position `k` dans une liste : `O(k)` (donc `O(n)` au pire).\n- insertion/suppression locale en liste : `O(1)` si le pointeur vers la position cible est déjà connu (par exemple, après un parcours)."
    },
    {
      "title": "Types de listes et périmètre du chapitre",
      "content": "### Liste simplement chaînée\nChaque nœud pointe uniquement vers le suivant. C'est la structure la plus simple, mais on ne peut pas revenir en arrière facilement.\n\n### Liste doublement chaînée\nChaque nœud possède deux pointeurs : vers le précédent et vers le suivant. Cela permet un parcours dans les deux sens, mais consomme plus de mémoire et demande plus de précautions lors des insertions/suppressions.\n\n### Liste circulaire\nLe dernier nœud pointe vers le premier, formant un cycle. Utile pour les applications tournantes (ordonnancement circulaire).\n\n[[NOTE]] Ce chapitre se concentre sur la **liste simplement chaînée**, qui est la base pour comprendre les mécanismes de chaînage avant d'aborder des structures plus complexes."
    },
    {
      "title": "Déclaration syntaxique (type maillon + tête)",
      "content": "Un maillon est un enregistrement avec une valeur (ou plus généralement un ensemble de données) et un pointeur vers un maillon du même type. La déclaration du type maillon définit le contrat mémoire de la liste. La tête (`Tete`) est ensuite la porte d'entrée unique de la structure : elle contient l'adresse du premier maillon, ou `NIL` si la liste est vide.\n\nEn algorithmique, on utilise souvent une variable globale `Tete` pour simplifier, mais dans une approche modulaire, on la passe en paramètre.",
      "code": "Type Element = Enregistrement\nDebut\n    x : Entier;\n    suivant : ^Element;\nFin;\n\nVar\n    Tete : ^Element;"
    },
    {
      "title": "Structure d'une liste simplement chaînée (tête, premier, dernier)",
      "content": "Si `Tete = NIL`, la liste est vide. Sinon, `Tete` donne l'accès au premier maillon. Pour atteindre le dernier maillon, il faut parcourir toute la liste jusqu'à ce que `suivant` soit `NIL`. Dans certaines implémentations (comme la création FIFO), on conserve aussi un pointeur `Queue` pour accéder directement au dernier élément.\n\n<div class=\"course-diagram\">\n<svg viewBox=\"0 0 960 210\" role=\"img\" aria-label=\"Tête et maillons\">\n  <defs>\n    <marker id=\"d8c\" markerWidth=\"10\" markerHeight=\"8\" refX=\"9\" refY=\"4\" orient=\"auto\">\n      <path d=\"M0,0 L10,4 L0,8 z\" fill=\"currentColor\"/>\n    </marker>\n  </defs>\n  <rect x=\"34\" y=\"74\" width=\"120\" height=\"44\" rx=\"8\" class=\"diagram-head\"/>\n  <text x=\"68\" y=\"102\" class=\"diagram-main\">Tête</text>\n  <rect x=\"220\" y=\"60\" width=\"190\" height=\"60\" rx=\"10\" class=\"diagram-node\"/>\n  <line x1=\"320\" y1=\"60\" x2=\"320\" y2=\"120\" class=\"diagram-split\"/>\n  <text x=\"270\" y=\"95\" class=\"diagram-main\">Val1</text>\n  <text x=\"340\" y=\"95\" class=\"diagram-link\">@B</text>\n  <rect x=\"470\" y=\"60\" width=\"190\" height=\"60\" rx=\"10\" class=\"diagram-node\"/>\n  <line x1=\"570\" y1=\"60\" x2=\"570\" y2=\"120\" class=\"diagram-split\"/>\n  <text x=\"520\" y=\"95\" class=\"diagram-main\">Val2</text>\n  <text x=\"590\" y=\"95\" class=\"diagram-link\">@C</text>\n  <rect x=\"720\" y=\"60\" width=\"190\" height=\"60\" rx=\"10\" class=\"diagram-node\"/>\n  <line x1=\"820\" y1=\"60\" x2=\"820\" y2=\"120\" class=\"diagram-split\"/>\n  <text x=\"770\" y=\"95\" class=\"diagram-main\">Val3</text>\n  <text x=\"843\" y=\"95\" class=\"diagram-link\">NIL</text>\n  <line x1=\"156\" y1=\"94\" x2=\"216\" y2=\"90\" class=\"diagram-arrow\" marker-end=\"url(#d8c)\"/>\n  <line x1=\"412\" y1=\"90\" x2=\"468\" y2=\"90\" class=\"diagram-arrow\" marker-end=\"url(#d8c)\"/>\n  <line x1=\"662\" y1=\"90\" x2=\"718\" y2=\"90\" class=\"diagram-arrow\" marker-end=\"url(#d8c)\"/>\n  <text x=\"264\" y=\"160\" class=\"diagram-caption\">Premier élément</text>\n  <text x=\"772\" y=\"160\" class=\"diagram-caption\">Dernier élément</text>\n</svg>\n</div>"
    },
    {
      "title": "Exemple 1: liste d'entiers",
      "content": "La partie information est un entier. C'est le cas le plus fréquent pour les exercices de base. On déclare un type `Element` avec un champ `x` (entier) et un pointeur `suivant`. La variable `Tete` (ou `P`) permet de manipuler la liste.\n\nCet exemple montre le cas le plus simple : un maillon contient une valeur entière et un lien vers le suivant. C'est le modèle de base à maîtriser avant de passer à des structures plus complexes (comme des listes d'enregistrements).",
      "code": "Type Element = Enregistrement\nDebut\n    x : Entier;\n    suivant : ^Element;\nFin;\n\nVar\n    Tete, P : ^Element;"
    },
    {
      "title": "Exemple 2: liste de dates (information composée)",
      "content": "L'information d'un maillon peut être un enregistrement complet, par exemple une date (jour, mois, année). Cela montre qu'une liste chaînée peut stocker des données complexes sans changer la logique de chaînage. Le pointeur `suivant` reste un pointeur vers un maillon de même type.\n\nCet exemple met en évidence qu'un maillon peut contenir une structure complexe (ici `Date`) et pas seulement un type primitif. Il faut alors accéder aux champs via `P->d.jour`, etc.",
      "code": "Type Date = Enregistrement\nDebut\n    jour, mois, annee : Entier;\nFin;\n\nType Element = Enregistrement\nDebut\n    d : Date;\n    suivant : ^Element;\nFin;"
    },
    {
      "title": "Accès et manipulation (`P^.x` et `P->x`)",
      "content": "Les notations `P^.x` et `P->x` représentent le même accès selon la convention utilisée (la flèche `->` est souvent employée en algorithmique pour plus de lisibilité). Dans les deux cas, on déréférence le pointeur pour accéder au champ de la structure pointée.\n\n[[ALERT]] Toujours vérifier `P <> NIL` avant d'accéder à `P->x`. Déréférencer un pointeur `NIL` provoque une erreur (pointeur nul).\n\nDans les deux notations, l'idée est identique : accéder à la donnée via l'adresse. La vigilance principale est de ne jamais déréférencer un pointeur `NIL`.",
      "code": "P := Tete;\nSi P <> NIL Alors\n    Ecrire(P->x);\n    P := P->suivant;\nFin Si;"
    },
    {
      "title": "Méthodes de création: FIFO vs LIFO",
      "content": "On peut construire une liste chaînée selon deux stratégies principales :\n\n### FIFO (First In, First Out)\nLes éléments sont ajoutés en fin de liste. L'ordre de saisie est conservé : le premier entré reste en tête. Pour cela, on a besoin de deux pointeurs : `Tete` (début) et `Queue` (fin) afin d'ajouter en queue sans avoir à parcourir toute la liste à chaque insertion.\n\n### LIFO (Last In, First Out)\nLes éléments sont ajoutés en tête de liste. Chaque nouveau maillon devient la nouvelle tête, et son `suivant` pointe vers l'ancienne tête. L'ordre est inversé : le dernier entré devient le premier.\n\n### Choix\n- conserver l'ordre d'arrivée → FIFO.\n- simplicité d'implémentation (un seul pointeur) → LIFO."
    },
    {
      "title": "Création FIFO détaillée (2 pointeurs: tête/queue)",
      "content": "On utilise un pointeur `Queue` pour éviter de reparcourir la liste à chaque insertion. Voici les étapes :\n1. Lire le nombre d'éléments `n`.\n2. Si `n <= 0`, la liste est vide (`Tete := NIL`).\n3. Sinon, allouer le premier maillon, lire sa valeur, et initialiser `Tete` et `Queue` sur ce maillon.\n4. Pour les `n-1` éléments suivants :\n   - Allouer un nouveau maillon `P`.\n   - Lire sa valeur.\n   - Attacher `P` à la suite de `Queue` (`Queue->suivant := P`).\n   - Mettre `Queue` à jour (`Queue := P`).\n5. Enfin, marquer la fin de la liste en mettant `Queue->suivant := NIL`.\n\nAvec FIFO, on conserve l'ordre de lecture en ajoutant en fin. Le pointeur `queue` évite un parcours complet de la liste à chaque insertion.",
      "code": "Algorithme CreationFIFO;\nType Element = Enregistrement\nDebut\n    x : Entier;\n    suivant : ^Element;\nFin;\nVar\n    Tete, Queue, P : ^Element;\n    n, i : Entier;\nDebut\n    Lire(n);\n    Si n <= 0 Alors\n        Tete := NIL;\n    Sinon\n        Tete := allouer(taille(Element));\n        Lire(Tete->x);\n        Queue := Tete;\n\n        Pour i := 1 a n-1 Faire\n            P := allouer(taille(Element));\n            Lire(P->x);\n            Queue->suivant := P;\n            Queue := P;\n        Fin Pour;\n\n        Queue->suivant := NIL;\n    Fin Si;\nFin."
    },
    {
      "title": "Création LIFO détaillée (1 pointeur: tête)",
      "content": "La création LIFO est plus simple :\n1. Initialiser `Tete` à `NIL`.\n2. Lire le nombre d'éléments `n`.\n3. Pour chaque élément :\n   - Allouer un nouveau maillon `P`.\n   - Lire sa valeur.\n   - Faire pointer `P->suivant` vers l'ancienne tête (`P->suivant := Tete`).\n   - Mettre à jour la tête (`Tete := P`).\n\nAinsi, chaque nouvel élément devient la tête. Le coût de chaque insertion est constant (`O(1)`). Cette variante est très utile pour simuler une pile ou pour un traitement où l'ordre n'a pas d'importance.",
      "code": "Algorithme CreationLIFO;\nType Element = Enregistrement\nDebut\n    x : Entier;\n    suivant : ^Element;\nFin;\nVar\n    Tete, P : ^Element;\n    n, i : Entier;\nDebut\n    Tete := NIL;\n    Lire(n);\n    Pour i := 1 a n Faire\n        P := allouer(taille(Element));\n        Lire(P->x);\n        P->suivant := Tete;\n        Tete := P;\n    Fin Pour;\nFin."
    },
    {
      "title": "Parcours d'une liste",
      "content": "Le parcours d'une liste simplement chaînée est séquentiel. On part de la tête, et tant que le pointeur courant n'est pas `NIL`, on traite l'élément puis on avance au suivant via `P := P->suivant`.\n\n### Complexité\nParcours complet : `O(n)`.\n\nLe parcours est fondamental pour afficher, rechercher, ou modifier les éléments. Il faut toujours conserver la tête (ou une copie) pour ne pas perdre l'accès à la liste.",
      "code": "Algorithme ParcoursListe;\nVar\n    P : ^Element;\nDebut\n    P := Tete;\n    Tantque P <> NIL Faire\n        Ecrire(P->x);\n        P := P->suivant;\n    Fin Tantque;\nFin."
    },
    {
      "title": "Libération de la mémoire",
      "content": "Lorsqu'une liste n'est plus utile, il faut libérer chaque maillon un par un pour éviter les fuites mémoire. On ne peut pas libérer la tête directement sans perdre l'accès au reste. La technique classique consiste à :\n1. Sauvegarder le pointeur vers le suivant (`P := Tete->suivant`).\n2. Libérer le maillon courant (`liberer(Tete)`).\n3. Avancer la tête (`Tete := P`).\n4. Répéter jusqu'à ce que la liste soit vide.\n\nCe parcours destructif est obligatoire dans un contexte d'allocation dynamique.",
      "code": "Algorithme LibererListe;\nVar\n    P : ^Element;\nDebut\n    Tantque Tete <> NIL Faire\n        P := Tete->suivant;\n        liberer(Tete);\n        Tete := P;\n    Fin Tantque;\nFin."
    },
    {
      "title": "Exercice 1 + Exercice 2 (modularité)",
      "content": "<div class=\"course-exercise\">\n  <div class=\"course-exercise-title\"><i class=\"fas fa-puzzle-piece\"></i> Exercice 1: Créer, afficher les pairs, libérer</div>\n  <p>Créez une liste d'entiers en lecture jusqu'à la valeur 0 (0 non inclus). Affichez ensuite les valeurs paires, puis libérez la mémoire. Cet exercice met en œuvre la création FIFO, le parcours conditionnel et la libération.</p>\n  <details class=\"course-solution-details\"><summary>Voir la solution complète</summary>\n  <pre class=\"course-solution-code\">Algorithme Exo1_ListesPairs;\nType Element = Enregistrement\nDebut\n    x : Entier;\n    suivant : ^Element;\nFin;\nVar\n    Tete, Queue, P : ^Element;\n    v : Entier;\nDebut\n    Tete := NIL;\n    Queue := NIL;\n\n    Lire(v);\n    Tantque v &lt;&gt; 0 Faire\n        P := allouer(taille(Element));\n        P-&gt;x := v;\n        P-&gt;suivant := NIL;\n\n        Si Tete = NIL Alors\n            Tete := P;\n            Queue := P;\n        Sinon\n            Queue-&gt;suivant := P;\n            Queue := P;\n        Fin Si;\n\n        Lire(v);\n    Fin Tantque;\n\n    P := Tete;\n    Tantque P &lt;&gt; NIL Faire\n        Si (P-&gt;x % 2 = 0) Alors\n            Ecrire(P-&gt;x);\n        Fin Si;\n        P := P-&gt;suivant;\n    Fin Tantque;\n\n    Tantque Tete &lt;&gt; NIL Faire\n        P := Tete-&gt;suivant;\n        liberer(Tete);\n        Tete := P;\n    Fin Tantque;\nFin.</pre>\n  <button class=\"course-solution-run\" data-code=\"Algorithme Exo1_ListesPairs;\\nType Element = Enregistrement\\nDebut\\n    x : Entier;\\n    suivant : ^Element;\\nFin;\\nVar\\n    Tete, Queue, P : ^Element;\\n    v : Entier;\\nDebut\\n    Tete := NIL;\\n    Queue := NIL;\\n\\n    Lire(v);\\n    Tantque v <> 0 Faire\\n        P := allouer(taille(Element));\\n        P->x := v;\\n        P->suivant := NIL;\\n\\n        Si Tete = NIL Alors\\n            Tete := P;\\n            Queue := P;\\n        Sinon\\n            Queue->suivant := P;\\n            Queue := P;\\n        Fin Si;\\n\\n        Lire(v);\\n    Fin Tantque;\\n\\n    P := Tete;\\n    Tantque P <> NIL Faire\\n        Si (P->x % 2 = 0) Alors\\n            Ecrire(P->x);\\n        Fin Si;\\n        P := P->suivant;\\n    Fin Tantque;\\n\\n    Tantque Tete <> NIL Faire\\n        P := Tete->suivant;\\n        liberer(Tete);\\n        Tete := P;\\n    Fin Tantque;\\nFin.\">Exécuter cette solution</button>\n  </details>\n</div>\n\n<div class=\"course-exercise\">\n  <div class=\"course-exercise-title\"><i class=\"fas fa-cubes\"></i> Exercice 2: Version modulaire</div>\n  <p>Reprenez l'exercice précédent en découpant le code en actions paramétrées : `Creer_Liste` (lit les valeurs et construit la liste), `Afficher_Pairs` (parcourt et affiche les pairs), `Liberer_Liste` (libère la mémoire). Cela illustre les bonnes pratiques de modularité.</p>\n  <details class=\"course-solution-details\"><summary>Voir la solution complète</summary>\n  <pre class=\"course-solution-code\">Algorithme Exo2_Modulaire;\nType Element = Enregistrement\nDebut\n    x : Entier;\n    suivant : ^Element;\nFin;\nVar\n    Tete : ^Element;\n\nProcedure Creer_Liste(Var Tete : ^Element);\nVar\n    Queue, P : ^Element;\n    v : Entier;\nDebut\n    Tete := NIL;\n    Queue := NIL;\n    Lire(v);\n    Tantque v &lt;&gt; 0 Faire\n        P := allouer(taille(Element));\n        P-&gt;x := v;\n        P-&gt;suivant := NIL;\n        Si Tete = NIL Alors\n            Tete := P;\n            Queue := P;\n        Sinon\n            Queue-&gt;suivant := P;\n            Queue := P;\n        Fin Si;\n        Lire(v);\n    Fin Tantque;\nFin;\n\nProcedure Afficher_Pairs(Tete : ^Element);\nVar P : ^Element;\nDebut\n    P := Tete;\n    Tantque P &lt;&gt; NIL Faire\n        Si (P-&gt;x % 2 = 0) Alors Ecrire(P-&gt;x); Fin Si;\n        P := P-&gt;suivant;\n    Fin Tantque;\nFin;\n\nProcedure Liberer_Liste(Var Tete : ^Element);\nVar P : ^Element;\nDebut\n    Tantque Tete &lt;&gt; NIL Faire\n        P := Tete-&gt;suivant;\n        liberer(Tete);\n        Tete := P;\n    Fin Tantque;\nFin;\n\nDebut\n    Creer_Liste(Tete);\n    Afficher_Pairs(Tete);\n    Liberer_Liste(Tete);\nFin.</pre>\n  <button class=\"course-solution-run\" data-code=\"Algorithme Exo2_Modulaire;\\nType Element = Enregistrement\\nDebut\\n    x : Entier;\\n    suivant : ^Element;\\nFin;\\nVar\\n    Tete : ^Element;\\n\\nProcedure Creer_Liste(Var Tete : ^Element);\\nVar\\n    Queue, P : ^Element;\\n    v : Entier;\\nDebut\\n    Tete := NIL;\\n    Queue := NIL;\\n    Lire(v);\\n    Tantque v <> 0 Faire\\n        P := allouer(taille(Element));\\n        P->x := v;\\n        P->suivant := NIL;\\n        Si Tete = NIL Alors\\n            Tete := P;\\n            Queue := P;\\n        Sinon\\n            Queue->suivant := P;\\n            Queue := P;\\n        Fin Si;\\n        Lire(v);\\n    Fin Tantque;\\nFin;\\n\\nProcedure Afficher_Pairs(Tete : ^Element);\\nVar P : ^Element;\\nDebut\\n    P := Tete;\\n    Tantque P <> NIL Faire\\n        Si (P->x % 2 = 0) Alors Ecrire(P->x); Fin Si;\\n        P := P->suivant;\\n    Fin Tantque;\\nFin;\\n\\nProcedure Liberer_Liste(Var Tete : ^Element);\\nVar P : ^Element;\\nDebut\\n    Tantque Tete <> NIL Faire\\n        P := Tete->suivant;\\n        liberer(Tete);\\n        Tete := P;\\n    Fin Tantque;\\nFin;\\n\\nDebut\\n    Creer_Liste(Tete);\\n    Afficher_Pairs(Tete);\\n    Liberer_Liste(Tete);\\nFin.\">Exécuter cette solution</button>\n  </details>\n</div>"
    },
    {
      "title": "Insertion au début (étapes + schéma)",
      "content": "L'insertion d'un nouveau maillon en tête est l'opération la plus simple :\n1. Allouer un nouveau maillon `Nouv`.\n2. Remplir sa valeur (`Nouv->x := val`).\n3. Faire pointer `Nouv->suivant` vers l'ancienne tête (`Nouv->suivant := Tete`).\n4. Mettre à jour la tête (`Tete := Nouv`).\n\nCette opération est en temps constant `O(1)`.\n\n<div class=\"course-diagram\">\n<svg viewBox=\"0 0 920 220\" role=\"img\" aria-label=\"Insertion au début\">\n  <defs><marker id=\"d8d\" markerWidth=\"10\" markerHeight=\"8\" refX=\"9\" refY=\"4\" orient=\"auto\"><path d=\"M0,0 L10,4 L0,8 z\" fill=\"currentColor\"/></marker></defs>\n  <text x=\"36\" y=\"34\" class=\"diagram-title\">Avant</text>\n  <rect x=\"34\" y=\"58\" width=\"110\" height=\"44\" rx=\"8\" class=\"diagram-head\"/><text x=\"66\" y=\"86\" class=\"diagram-main\">Tête</text>\n  <rect x=\"188\" y=\"50\" width=\"170\" height=\"58\" rx=\"8\" class=\"diagram-node\"/><line x1=\"278\" y1=\"50\" x2=\"278\" y2=\"108\" class=\"diagram-split\"/>\n  <text x=\"230\" y=\"84\" class=\"diagram-main\">A</text><text x=\"300\" y=\"84\" class=\"diagram-link\">...</text>\n  <line x1=\"146\" y1=\"80\" x2=\"184\" y2=\"79\" class=\"diagram-arrow\" marker-end=\"url(#d8d)\"/>\n  <text x=\"486\" y=\"34\" class=\"diagram-title\">Après</text>\n  <rect x=\"486\" y=\"58\" width=\"110\" height=\"44\" rx=\"8\" class=\"diagram-head\"/><text x=\"518\" y=\"86\" class=\"diagram-main\">Tête</text>\n  <rect x=\"640\" y=\"50\" width=\"170\" height=\"58\" rx=\"8\" class=\"diagram-node-accent\"/><line x1=\"730\" y1=\"50\" x2=\"730\" y2=\"108\" class=\"diagram-split\"/>\n  <text x=\"676\" y=\"84\" class=\"diagram-main\">Nouv</text><text x=\"750\" y=\"84\" class=\"diagram-link\">@A</text>\n  <rect x=\"640\" y=\"146\" width=\"170\" height=\"58\" rx=\"8\" class=\"diagram-node\"/><line x1=\"730\" y1=\"146\" x2=\"730\" y2=\"204\" class=\"diagram-split\"/>\n  <text x=\"718\" y=\"180\" class=\"diagram-main\">A</text><text x=\"750\" y=\"180\" class=\"diagram-link\">...</text>\n  <line x1=\"598\" y1=\"80\" x2=\"636\" y2=\"79\" class=\"diagram-arrow\" marker-end=\"url(#d8d)\"/>\n  <line x1=\"730\" y1=\"110\" x2=\"730\" y2=\"142\" class=\"diagram-arrow\" marker-end=\"url(#d8d)\"/>\n</svg>\n</div>",
      "code": "Nouv := allouer(taille(Element));\nNouv->x := val;\nNouv->suivant := Tete;\nTete := Nouv;"
    },
    {
      "title": "Insertion au milieu (étapes + schéma + ordre)",
      "content": "Pour insérer un nouveau maillon entre deux maillons existants, par exemple entre `Pred` (le précédent) et `P` (le suivant), l'ordre des affectations est crucial pour ne pas perdre le reste de la liste.\n\nÉtapes correctes :\n1. Allouer `Nouv` et remplir sa valeur.\n2. Faire pointer `Nouv->suivant` vers `P` (le maillon qui suivra `Nouv`).\n3. Faire pointer `Pred->suivant` vers `Nouv`.\n\nSi on inversait les étapes 2 et 3, on perdrait l'accès à `P` (car `Pred->suivant` serait écrasé avant d'avoir copié `P`).\n\n<div class=\"course-diagram\">\n<svg viewBox=\"0 0 940 220\" role=\"img\" aria-label=\"Insertion au milieu\">\n  <defs><marker id=\"d8e\" markerWidth=\"10\" markerHeight=\"8\" refX=\"9\" refY=\"4\" orient=\"auto\"><path d=\"M0,0 L10,4 L0,8 z\" fill=\"currentColor\"/></marker></defs>\n  <rect x=\"60\" y=\"80\" width=\"180\" height=\"60\" rx=\"8\" class=\"diagram-node\"/><line x1=\"150\" y1=\"80\" x2=\"150\" y2=\"140\" class=\"diagram-split\"/>\n  <text x=\"100\" y=\"116\" class=\"diagram-main\">Pred</text><text x=\"170\" y=\"116\" class=\"diagram-link\">@P</text>\n  <rect x=\"360\" y=\"80\" width=\"180\" height=\"60\" rx=\"8\" class=\"diagram-node\"/><line x1=\"450\" y1=\"80\" x2=\"450\" y2=\"140\" class=\"diagram-split\"/>\n  <text x=\"433\" y=\"116\" class=\"diagram-main\">P</text><text x=\"470\" y=\"116\" class=\"diagram-link\">...</text>\n  <line x1=\"242\" y1=\"110\" x2=\"356\" y2=\"110\" class=\"diagram-arrow-dashed\" marker-end=\"url(#d8e)\"/>\n  <rect x=\"360\" y=\"20\" width=\"180\" height=\"48\" rx=\"8\" class=\"diagram-node-accent\"/><line x1=\"450\" y1=\"20\" x2=\"450\" y2=\"68\" class=\"diagram-split\"/>\n  <text x=\"414\" y=\"49\" class=\"diagram-main\">Nouv</text><text x=\"468\" y=\"49\" class=\"diagram-link\">@P</text>\n  <line x1=\"242\" y1=\"96\" x2=\"358\" y2=\"44\" class=\"diagram-arrow\" marker-end=\"url(#d8e)\"/>\n  <text x=\"78\" y=\"176\" class=\"diagram-caption\">1) Nouv->suivant := P   2) Pred->suivant := Nouv</text>\n</svg>\n</div>",
      "code": "Nouv := allouer(taille(Element));\nNouv->x := val;\nNouv->suivant := P;\nPred->suivant := Nouv;"
    },
    {
      "title": "Exercice 3 (insertions ciblées)",
      "content": "<div class=\"course-exercise\">\n  <div class=\"course-exercise-title\"><i class=\"fas fa-plus-circle\"></i> Exercice 3: Insertions ciblées</div>\n  <p>Soit une liste d'entiers. Réalisez deux opérations : d'abord insérer une valeur avant la première occurrence d'une valeur donnée (si elle existe), puis insérer une valeur après chaque élément pair de la liste. Gérez correctement les cas particuliers (liste vide, insertion en tête, etc.).</p>\n  <details class=\"course-solution-details\"><summary>Voir la solution complète</summary>\n  <pre class=\"course-solution-code\">Algorithme Exo3_Insertions;\nType Element = Enregistrement\nDebut\n    x : Entier;\n    suivant : ^Element;\nFin;\nVar\n    Tete, P, Pred, Nouv : ^Element;\n    val, valIns : Entier;\nDebut\n    Lire(val);\n    Lire(valIns);\n\n    P := Tete;\n    Pred := NIL;\n    Tantque (P &lt;&gt; NIL) Et (P-&gt;x &lt;&gt; val) Faire\n        Pred := P;\n        P := P-&gt;suivant;\n    Fin Tantque;\n\n    Si P &lt;&gt; NIL Alors\n        Nouv := allouer(taille(Element));\n        Nouv-&gt;x := valIns;\n        Si Pred = NIL Alors\n            Nouv-&gt;suivant := Tete;\n            Tete := Nouv;\n        Sinon\n            Nouv-&gt;suivant := P;\n            Pred-&gt;suivant := Nouv;\n        Fin Si;\n    Fin Si;\n\n    P := Tete;\n    Tantque P &lt;&gt; NIL Faire\n        Si (P-&gt;x % 2 = 0) Alors\n            Nouv := allouer(taille(Element));\n            Nouv-&gt;x := valIns;\n            Nouv-&gt;suivant := P-&gt;suivant;\n            P-&gt;suivant := Nouv;\n            P := Nouv-&gt;suivant;\n        Sinon\n            P := P-&gt;suivant;\n        Fin Si;\n    Fin Tantque;\nFin.</pre>\n  <button class=\"course-solution-run\" data-code=\"Algorithme Exo3_Insertions;\\nType Element = Enregistrement\\nDebut\\n    x : Entier;\\n    suivant : ^Element;\\nFin;\\nVar\\n    Tete, P, Pred, Nouv : ^Element;\\n    val, valIns : Entier;\\nDebut\\n    Lire(val);\\n    Lire(valIns);\\n\\n    P := Tete;\\n    Pred := NIL;\\n    Tantque (P <> NIL) Et (P->x <> val) Faire\\n        Pred := P;\\n        P := P->suivant;\\n    Fin Tantque;\\n\\n    Si P <> NIL Alors\\n        Nouv := allouer(taille(Element));\\n        Nouv->x := valIns;\\n        Si Pred = NIL Alors\\n            Nouv->suivant := Tete;\\n            Tete := Nouv;\\n        Sinon\\n            Nouv->suivant := P;\\n            Pred->suivant := Nouv;\\n        Fin Si;\\n    Fin Si;\\n\\n    P := Tete;\\n    Tantque P <> NIL Faire\\n        Si (P->x % 2 = 0) Alors\\n            Nouv := allouer(taille(Element));\\n            Nouv->x := valIns;\\n            Nouv->suivant := P->suivant;\\n            P->suivant := Nouv;\\n            P := Nouv->suivant;\\n        Sinon\\n            P := P->suivant;\\n        Fin Si;\\n    Fin Tantque;\\nFin.\">Exécuter cette solution</button>\n  </details>\n</div>"
    },
    {
      "title": "Suppression: introduction (début vs milieu)",
      "content": "La suppression d'un maillon nécessite de distinguer deux cas principaux :\n- **Suppression en tête** : le premier maillon est retiré. Il faut alors mettre à jour la tête pour qu'elle pointe vers le deuxième maillon.\n- **Suppression au milieu** : le maillon à supprimer n'est pas le premier. Il faut court-circuiter le chaînage en reliant le maillon précédent directement au maillon suivant.\n\n[[ALERT]] Après déchaînage, il faut libérer le maillon supprimé avec `liberer()` pour éviter les fuites mémoire."
    },
    {
      "title": "Suppression au début (étapes + résumé)",
      "content": "Étapes pour supprimer le premier maillon :\n1. Sauvegarder l'adresse de la tête dans un pointeur temporaire `P := Tete`.\n2. Avancer la tête vers le deuxième maillon : `Tete := Tete->suivant`.\n3. Libérer l'ancien premier maillon : `liberer(P)`.\n\nCette opération est en `O(1)`. Attention : si la liste n'a qu'un seul élément, après l'avancement, `Tete` devient `NIL`, ce qui est correct.\n\n<div class=\"course-diagram\">\n<svg viewBox=\"0 0 900 220\" role=\"img\" aria-label=\"Suppression au début\">\n  <defs><marker id=\"d8f\" markerWidth=\"10\" markerHeight=\"8\" refX=\"9\" refY=\"4\" orient=\"auto\"><path d=\"M0,0 L10,4 L0,8 z\" fill=\"currentColor\"/></marker></defs>\n  <rect x=\"60\" y=\"80\" width=\"160\" height=\"60\" rx=\"8\" class=\"diagram-node-delete\"/><line x1=\"145\" y1=\"80\" x2=\"145\" y2=\"140\" class=\"diagram-split\"/>\n  <text x=\"94\" y=\"114\" class=\"diagram-main\">Ancien</text><text x=\"164\" y=\"114\" class=\"diagram-link\">@B</text>\n  <rect x=\"300\" y=\"80\" width=\"160\" height=\"60\" rx=\"8\" class=\"diagram-node\"/><line x1=\"385\" y1=\"80\" x2=\"385\" y2=\"140\" class=\"diagram-split\"/>\n  <text x=\"352\" y=\"114\" class=\"diagram-main\">B</text><text x=\"404\" y=\"114\" class=\"diagram-link\">...</text>\n  <line x1=\"222\" y1=\"110\" x2=\"296\" y2=\"110\" class=\"diagram-arrow\" marker-end=\"url(#d8f)\"/>\n  <rect x=\"560\" y=\"64\" width=\"110\" height=\"44\" rx=\"8\" class=\"diagram-head\"/><text x=\"592\" y=\"92\" class=\"diagram-main\">Tête</text>\n  <line x1=\"670\" y1=\"86\" x2=\"744\" y2=\"108\" class=\"diagram-arrow\" marker-end=\"url(#d8f)\"/>\n  <rect x=\"748\" y=\"80\" width=\"130\" height=\"60\" rx=\"8\" class=\"diagram-node\"/><text x=\"806\" y=\"114\" class=\"diagram-main\">B</text>\n  <text x=\"80\" y=\"176\" class=\"diagram-caption\">Déplacer Tête puis libérer l'ancien premier</text>\n</svg>\n</div>",
      "code": "P := Tete;\nTete := Tete->suivant;\nliberer(P);"
    },
    {
      "title": "Suppression au milieu (étapes + résumé)",
      "content": "Pour supprimer un maillon qui n'est pas en tête, on doit connaître son prédécesseur `Pred`. Étapes :\n1. Court-circuiter le chaînage : `Pred->suivant := P->suivant`.\n2. Libérer le maillon `P`.\n\nIl est essentiel de ne pas perdre l'adresse de `P` avant de l'avoir libérée. Cette opération est aussi en `O(1)` si `Pred` est déjà connu.\n\n<div class=\"course-diagram\">\n<svg viewBox=\"0 0 940 220\" role=\"img\" aria-label=\"Suppression au milieu\">\n  <defs><marker id=\"d8g\" markerWidth=\"10\" markerHeight=\"8\" refX=\"9\" refY=\"4\" orient=\"auto\"><path d=\"M0,0 L10,4 L0,8 z\" fill=\"currentColor\"/></marker></defs>\n  <rect x=\"70\" y=\"82\" width=\"170\" height=\"60\" rx=\"8\" class=\"diagram-node\"/><line x1=\"160\" y1=\"82\" x2=\"160\" y2=\"142\" class=\"diagram-split\"/>\n  <text x=\"112\" y=\"116\" class=\"diagram-main\">Pred</text><text x=\"178\" y=\"116\" class=\"diagram-link\">@P</text>\n  <rect x=\"340\" y=\"82\" width=\"170\" height=\"60\" rx=\"8\" class=\"diagram-node-delete\"/><line x1=\"430\" y1=\"82\" x2=\"430\" y2=\"142\" class=\"diagram-split\"/>\n  <text x=\"420\" y=\"116\" class=\"diagram-main\">P</text><text x=\"448\" y=\"116\" class=\"diagram-link\">@N</text>\n  <rect x=\"610\" y=\"82\" width=\"170\" height=\"60\" rx=\"8\" class=\"diagram-node\"/><line x1=\"700\" y1=\"82\" x2=\"700\" y2=\"142\" class=\"diagram-split\"/>\n  <text x=\"686\" y=\"116\" class=\"diagram-main\">N</text><text x=\"719\" y=\"116\" class=\"diagram-link\">...</text>\n  <line x1=\"242\" y1=\"112\" x2=\"336\" y2=\"112\" class=\"diagram-arrow-dashed\" marker-end=\"url(#d8g)\"/>\n  <line x1=\"512\" y1=\"112\" x2=\"606\" y2=\"112\" class=\"diagram-arrow-dashed\" marker-end=\"url(#d8g)\"/>\n  <line x1=\"242\" y1=\"96\" x2=\"608\" y2=\"96\" class=\"diagram-arrow\" marker-end=\"url(#d8g)\"/>\n  <text x=\"248\" y=\"74\" class=\"diagram-caption\">Pred->suivant := P->suivant, puis liberer(P)</text>\n</svg>\n</div>",
      "code": "Pred->suivant := P->suivant;\nliberer(P);"
    },
    {
      "title": "Exercice 4 (suppression occurrence / toutes occurrences)",
      "content": "<div class=\"course-exercise\">\n  <div class=\"course-exercise-title\"><i class=\"fas fa-minus-circle\"></i> Exercice 4: Suppression d'occurrences</div>\n  <p>Écrire un algorithme qui supprime d'abord la première occurrence d'une valeur donnée, puis (dans la même liste) toutes les occurrences de cette valeur. Attention aux cas particuliers : suppression en tête, liste vide, éléments consécutifs.</p>\n  <p><strong>Correction d'un bug potentiel :</strong> après la suppression des premières occurrences en tête, si la liste devient vide, il faut s'assurer que le pointeur `P` est bien initialisé à `NIL` pour la suite.</p>\n  <details class=\"course-solution-details\"><summary>Voir la solution complète (corrigée)</summary>\n  <pre class=\"course-solution-code\">Algorithme Exo4_Suppressions;\nVar\n    Tete, P, Pred, Tmp : ^Element;\n    val : Entier;\nDebut\n    Lire(val);\n\n    // Suppression de la première occurrence\n    P := Tete;\n    Pred := NIL;\n    Tantque (P &lt;&gt; NIL) Et (P-&gt;x &lt;&gt; val) Faire\n        Pred := P;\n        P := P-&gt;suivant;\n    Fin Tantque;\n    Si P &lt;&gt; NIL Alors\n        Si Pred = NIL Alors\n            Tete := Tete-&gt;suivant;\n        Sinon\n            Pred-&gt;suivant := P-&gt;suivant;\n        Fin Si;\n        liberer(P);\n    Fin Si;\n\n    // Suppression de toutes les occurrences (après la première éventuelle)\n    // Traitement des occurrences en tête (répétées)\n    Tantque (Tete &lt;&gt; NIL) Et (Tete-&gt;x = val) Faire\n        Tmp := Tete-&gt;suivant;\n        liberer(Tete);\n        Tete := Tmp;\n    Fin Tantque;\n\n    // Suppression des occurrences suivantes (au milieu ou fin)\n    Pred := Tete;\n    Si Pred = NIL Alors\n        P := NIL;   // liste vide, plus rien à faire\n    Sinon\n        P := Pred-&gt;suivant;\n    Fin Si;\n    Tantque P &lt;&gt; NIL Faire\n        Si P-&gt;x = val Alors\n            Pred-&gt;suivant := P-&gt;suivant;\n            liberer(P);\n            P := Pred-&gt;suivant;\n        Sinon\n            Pred := P;\n            P := P-&gt;suivant;\n        Fin Si;\n    Fin Tantque;\nFin.</pre>\n  <button class=\"course-solution-run\" data-code=\"Algorithme Exo4_Suppressions;\\nVar\\n    Tete, P, Pred, Tmp : ^Element;\\n    val : Entier;\\nDebut\\n    Lire(val);\\n\\n    P := Tete;\\n    Pred := NIL;\\n    Tantque (P <> NIL) Et (P->x <> val) Faire\\n        Pred := P;\\n        P := P->suivant;\\n    Fin Tantque;\\n    Si P <> NIL Alors\\n        Si Pred = NIL Alors\\n            Tete := Tete->suivant;\\n        Sinon\\n            Pred->suivant := P->suivant;\\n        Fin Si;\\n        liberer(P);\\n    Fin Si;\\n\\n    Tantque (Tete <> NIL) Et (Tete->x = val) Faire\\n        Tmp := Tete->suivant;\\n        liberer(Tete);\\n        Tete := Tmp;\\n    Fin Tantque;\\n\\n    Pred := Tete;\\n    Si Pred = NIL Alors\\n        P := NIL;\\n    Sinon\\n        P := Pred->suivant;\\n    Fin Si;\\n    Tantque P <> NIL Faire\\n        Si P->x = val Alors\\n            Pred->suivant := P->suivant;\\n            liberer(P);\\n            P := Pred->suivant;\\n        Sinon\\n            Pred := P;\\n            P := P->suivant;\\n        Fin Si;\\n    Fin Tantque;\\nFin.\">Exécuter cette solution</button>\n  </details>\n</div>"
    },
    {
      "title": "Tri d'une liste: principes et contraintes",
      "content": "Le tri par sélection s'applique bien en liste simplement chaînée si on échange les **valeurs** des maillons plutôt que de réorganiser les pointeurs (ce qui est plus complexe et risqué).\n\n### Points clés\n- On parcourt la liste pour trouver le minimum (ou le maximum) dans la partie non triée, puis on échange sa valeur avec celle de la position courante.\n- On répète pour chaque position.\n- Le tri par sélection a une complexité de `O(n^2)` en temps, mais il est simple à implémenter sur une liste chaînée.\n- D'autres tris (fusion, insertion) sont possibles mais nécessitent souvent une adaptation ou une structure auxiliaire."
    },
    {
      "title": "Tri par sélection (version en 2 parties)",
      "content": "L'algorithme procède ainsi :\n1. On initialise un pointeur `P` sur la tête.\n2. Tant que `P` n'est pas le dernier élément :\n   - On cherche le maillon contenant la valeur minimale à partir de `P` (inclus).\n   - On échange les valeurs entre `P` et ce maillon minimum.\n   - On avance `P` d'un cran.\n\nMême si le tri par sélection n'est pas le plus rapide, il reste une excellente base pédagogique pour comprendre la logique de comparaison sur structures chaînées.",
      "code": "Algorithme TriSelectionListe;\nVar\n    P, Q, Min : ^Element;\n    Temp : Entier;\nDebut\n    P := Tete;\n    Tantque (P <> NIL) Et (P->suivant <> NIL) Faire\n        Min := P;\n        Q := P->suivant;\n        Tantque Q <> NIL Faire\n            Si Q->x < Min->x Alors\n                Min := Q;\n            Fin Si;\n            Q := Q->suivant;\n        Fin Tantque;\n        Si Min <> P Alors\n            Temp := P->x;\n            P->x := Min->x;\n            Min->x := Temp;\n        Fin Si;\n        P := P->suivant;\n    Fin Tantque;\nFin."
    },
    {
      "title": "Exercice 5 (trier la liste)",
      "content": "<div class=\"course-exercise\">\n  <div class=\"course-exercise-title\"><i class=\"fas fa-sort\"></i> Exercice 5: Trier la liste en ordre croissant</div>\n  <p>Écrire une action paramétrée `Trier_Liste` qui trie une liste simplement chaînée d'entiers en ordre croissant en utilisant la méthode du tri par sélection (échange des valeurs).</p>\n  <details class=\"course-solution-details\"><summary>Voir la solution complète</summary>\n  <pre class=\"course-solution-code\">Algorithme Exo5_TriListe;\nVar\n    P, Q, Min : ^Element;\n    Temp : Entier;\nDebut\n    P := Tete;\n    Tantque (P &lt;&gt; NIL) Et (P-&gt;suivant &lt;&gt; NIL) Faire\n        Min := P;\n        Q := P-&gt;suivant;\n        Tantque Q &lt;&gt; NIL Faire\n            Si Q-&gt;x &lt; Min-&gt;x Alors\n                Min := Q;\n            Fin Si;\n            Q := Q-&gt;suivant;\n        Fin Tantque;\n        Si Min &lt;&gt; P Alors\n            Temp := P-&gt;x;\n            P-&gt;x := Min-&gt;x;\n            Min-&gt;x := Temp;\n        Fin Si;\n        P := P-&gt;suivant;\n    Fin Tantque;\nFin.</pre>\n  <button class=\"course-solution-run\" data-code=\"Algorithme Exo5_TriListe;\\nVar\\n    P, Q, Min : ^Element;\\n    Temp : Entier;\\nDebut\\n    P := Tete;\\n    Tantque (P <> NIL) Et (P->suivant <> NIL) Faire\\n        Min := P;\\n        Q := P->suivant;\\n        Tantque Q <> NIL Faire\\n            Si Q->x < Min->x Alors\\n                Min := Q;\\n            Fin Si;\\n            Q := Q->suivant;\\n        Fin Tantque;\\n        Si Min <> P Alors\\n            Temp := P->x;\\n            P->x := Min->x;\\n            Min->x := Temp;\\n        Fin Si;\\n        P := P->suivant;\\n    Fin Tantque;\\nFin.\">Exécuter cette solution</button>\n  </details>\n</div>"
    },
    {
      "title": "Comparaison Tableau vs Liste (table HTML)",
      "content": "<div class=\"course-table-wrap\">\n<table class=\"course-table\">\n  <thead>\n    <tr>\n      <th>Opération</th>\n      <th>Tableau</th>\n      <th>Liste Chaînée</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr><td>Accès direct (indice / position)</td><td>O(1)</td><td>O(n)</td></tr>\n    <tr><td>Insertion au début</td><td>O(n)</td><td>O(1)</td></tr>\n    <tr><td>Insertion au milieu</td><td>O(n)</td><td>O(1)*</td></tr>\n    <tr><td>Suppression au début</td><td>O(n)</td><td>O(1)</td></tr>\n    <tr><td>Suppression au milieu</td><td>O(n)</td><td>O(1)*</td></tr>\n    <tr><td>Recherche de valeur</td><td>O(n)</td><td>O(n)</td></tr>\n    <tr><td>Taille dynamique</td><td>Non</td><td>Oui</td></tr>\n  </tbody>\n</table>\n</div>\n* `O(1)` si le pointeur sur la position est déjà disponible. Sinon, il faut d'abord parcourir la liste jusqu'à cette position (O(n))."
    },
    {
      "title": "Exercices supplémentaires (5) - Niveau approfondi",
      "content": "Ces 5 exercices avancés complètent le chapitre avec des situations classiques en listes chaînées. Pour progresser vite, appliquez la même méthode à chaque question : définir les pointeurs utiles, traiter les cas limites (liste vide, tête modifiée), puis valider la libération mémoire.\n\n<div class=\"course-exercise\">\n  <div class=\"course-exercise-title\"><i class=\"fas fa-list-ol\"></i> Exercice 6: Longueur, somme et moyenne</div>\n  <p><strong>Objectif :</strong> Parcourir une liste d'entiers et calculer sa longueur, sa somme et sa moyenne.<br><strong>Point d'attention :</strong> Traiter explicitement le cas d'une liste vide pour éviter une division par zéro.</p>\n  <details class=\"course-solution-details\"><summary>Voir la solution complète</summary>\n  <pre class=\"course-solution-code\">Algorithme Exo6_StatsListe;\nVar\n    P : ^Element;\n    n, somme : Entier;\n    moy : Reel;\nDebut\n    P := Tete;\n    n := 0;\n    somme := 0;\n\n    Tantque P &lt;&gt; NIL Faire\n        n := n + 1;\n        somme := somme + P-&gt;x;\n        P := P-&gt;suivant;\n    Fin Tantque;\n\n    Si n = 0 Alors\n        Ecrire('Liste vide');\n    Sinon\n        moy := somme / n;\n        Ecrire('Longueur=', n, ' Somme=', somme, ' Moyenne=', moy);\n    Fin Si;\nFin.</pre>\n  <button class=\"course-solution-run\" data-code=\"Algorithme Exo6_StatsListe;\\nVar\\n    P : ^Element;\\n    n, somme : Entier;\\n    moy : Reel;\\nDebut\\n    P := Tete;\\n    n := 0;\\n    somme := 0;\\n\\n    Tantque P <> NIL Faire\\n        n := n + 1;\\n        somme := somme + P->x;\\n        P := P->suivant;\\n    Fin Tantque;\\n\\n    Si n = 0 Alors\\n        Ecrire('Liste vide');\\n    Sinon\\n        moy := somme / n;\\n        Ecrire('Longueur=', n, ' Somme=', somme, ' Moyenne=', moy);\\n    Fin Si;\\nFin.\">Exécuter cette solution</button>\n  </details>\n</div>\n\n<div class=\"course-exercise\">\n  <div class=\"course-exercise-title\"><i class=\"fas fa-exchange-alt\"></i> Exercice 7: Inverser une liste (en place)</div>\n  <p><strong>Objectif :</strong> Inverser le sens des liens d'une liste sans créer de nouveaux maillons. L'ordre des éléments doit être inversé.<br><strong>Point d'attention :</strong> Utiliser trois pointeurs (`Prec`, `Cour`, `Suiv`) pour ne jamais perdre le reste de la chaîne pendant l'inversion.</p>\n  <details class=\"course-solution-details\"><summary>Voir la solution complète</summary>\n  <pre class=\"course-solution-code\">Algorithme Exo7_InverserListe;\nVar\n    Prec, Cour, Suiv : ^Element;\nDebut\n    Prec := NIL;\n    Cour := Tete;\n\n    Tantque Cour &lt;&gt; NIL Faire\n        Suiv := Cour-&gt;suivant;\n        Cour-&gt;suivant := Prec;\n        Prec := Cour;\n        Cour := Suiv;\n    Fin Tantque;\n\n    Tete := Prec;\nFin.</pre>\n  <button class=\"course-solution-run\" data-code=\"Algorithme Exo7_InverserListe;\\nVar\\n    Prec, Cour, Suiv : ^Element;\\nDebut\\n    Prec := NIL;\\n    Cour := Tete;\\n\\n    Tantque Cour <> NIL Faire\\n        Suiv := Cour->suivant;\\n        Cour->suivant := Prec;\\n        Prec := Cour;\\n        Cour := Suiv;\\n    Fin Tantque;\\n\\n    Tete := Prec;\\nFin.\">Exécuter cette solution</button>\n  </details>\n</div>\n\n<div class=\"course-exercise\">\n  <div class=\"course-exercise-title\"><i class=\"fas fa-plus\"></i> Exercice 8: Insertion dans une liste triée</div>\n  <p><strong>Objectif :</strong> Insérer une valeur `val` à la bonne position dans une liste déjà triée en ordre croissant.<br><strong>Point d'attention :</strong> Gérer les trois cas : insertion en tête (si `val` est plus petit que la première valeur), au milieu, ou en fin de liste.</p>\n  <details class=\"course-solution-details\"><summary>Voir la solution complète</summary>\n  <pre class=\"course-solution-code\">Algorithme Exo8_InsererTrie;\nVar\n    P, Pred, Nouv : ^Element;\n    val : Entier;\nDebut\n    Lire(val);\n    Nouv := allouer(taille(Element));\n    Nouv-&gt;x := val;\n\n    P := Tete;\n    Pred := NIL;\n    Tantque (P &lt;&gt; NIL) Et (P-&gt;x &lt; val) Faire\n        Pred := P;\n        P := P-&gt;suivant;\n    Fin Tantque;\n\n    Si Pred = NIL Alors\n        Nouv-&gt;suivant := Tete;\n        Tete := Nouv;\n    Sinon\n        Nouv-&gt;suivant := P;\n        Pred-&gt;suivant := Nouv;\n    Fin Si;\nFin.</pre>\n  <button class=\"course-solution-run\" data-code=\"Algorithme Exo8_InsererTrie;\\nVar\\n    P, Pred, Nouv : ^Element;\\n    val : Entier;\\nDebut\\n    Lire(val);\\n    Nouv := allouer(taille(Element));\\n    Nouv->x := val;\\n\\n    P := Tete;\\n    Pred := NIL;\\n    Tantque (P <> NIL) Et (P->x < val) Faire\\n        Pred := P;\\n        P := P->suivant;\\n    Fin Tantque;\\n\\n    Si Pred = NIL Alors\\n        Nouv->suivant := Tete;\\n        Tete := Nouv;\\n    Sinon\\n        Nouv->suivant := P;\\n        Pred->suivant := Nouv;\\n    Fin Si;\\nFin.\">Exécuter cette solution</button>\n  </details>\n</div>\n\n<div class=\"course-exercise\">\n  <div class=\"course-exercise-title\"><i class=\"fas fa-code-branch\"></i> Exercice 9: Fusion de deux listes triées</div>\n  <p><strong>Objectif :</strong> Fusionner deux listes triées `L1` et `L2` (chacune triée en ordre croissant) en une seule liste `L3` également triée. On ne doit pas créer de nouveaux maillons, mais réutiliser ceux des listes d'origine en modifiant les pointeurs.<br><strong>Point d'attention :</strong> Gérer correctement le cas où l'une des listes est plus longue ou vide.</p>\n  <details class=\"course-solution-details\"><summary>Voir la solution complète</summary>\n  <pre class=\"course-solution-code\">Algorithme Exo9_FusionTriee;\nVar\n    L1, L2, L3, Queue, P : ^Element;\nDebut\n    L3 := NIL;\n    Queue := NIL;\n\n    Tantque (L1 &lt;&gt; NIL) Ou (L2 &lt;&gt; NIL) Faire\n        Si (L2 = NIL) Ou ((L1 &lt;&gt; NIL) Et (L1-&gt;x &lt;= L2-&gt;x)) Alors\n            P := L1;\n            L1 := L1-&gt;suivant;\n        Sinon\n            P := L2;\n            L2 := L2-&gt;suivant;\n        Fin Si;\n\n        P-&gt;suivant := NIL;\n        Si L3 = NIL Alors\n            L3 := P;\n            Queue := P;\n        Sinon\n            Queue-&gt;suivant := P;\n            Queue := P;\n        Fin Si;\n    Fin Tantque;\nFin.</pre>\n  <button class=\"course-solution-run\" data-code=\"Algorithme Exo9_FusionTriee;\\nVar\\n    L1, L2, L3, Queue, P : ^Element;\\nDebut\\n    L3 := NIL;\\n    Queue := NIL;\\n\\n    Tantque (L1 <> NIL) Ou (L2 <> NIL) Faire\\n        Si (L2 = NIL) Ou ((L1 <> NIL) Et (L1->x <= L2->x)) Alors\\n            P := L1;\\n            L1 := L1->suivant;\\n        Sinon\\n            P := L2;\\n            L2 := L2->suivant;\\n        Fin Si;\\n\\n        P->suivant := NIL;\\n        Si L3 = NIL Alors\\n            L3 := P;\\n            Queue := P;\\n        Sinon\\n            Queue->suivant := P;\\n            Queue := P;\\n        Fin Si;\\n    Fin Tantque;\\nFin.\">Exécuter cette solution</button>\n  </details>\n</div>\n\n<div class=\"course-exercise\">\n  <div class=\"course-exercise-title\"><i class=\"fas fa-clone\"></i> Exercice 10: Supprimer les doublons consécutifs</div>\n  <p><strong>Objectif :</strong> Dans une liste triée, supprimer les doublons successifs pour ne garder qu'une seule occurrence de chaque valeur.<br><strong>Point d'attention :</strong> Après avoir supprimé un doublon, il faut rester sur le même maillon courant pour vérifier s'il y a encore d'autres doublons identiques à la suite.</p>\n  <details class=\"course-solution-details\"><summary>Voir la solution complète</summary>\n  <pre class=\"course-solution-code\">Algorithme Exo10_SupprimerDoublons;\nVar\n    P, Tmp : ^Element;\nDebut\n    P := Tete;\n    Tantque (P &lt;&gt; NIL) Et (P-&gt;suivant &lt;&gt; NIL) Faire\n        Si P-&gt;x = P-&gt;suivant-&gt;x Alors\n            Tmp := P-&gt;suivant;\n            P-&gt;suivant := Tmp-&gt;suivant;\n            liberer(Tmp);\n        Sinon\n            P := P-&gt;suivant;\n        Fin Si;\n    Fin Tantque;\nFin.</pre>\n  <button class=\"course-solution-run\" data-code=\"Algorithme Exo10_SupprimerDoublons;\\nVar\\n    P, Tmp : ^Element;\\nDebut\\n    P := Tete;\\n    Tantque (P <> NIL) Et (P->suivant <> NIL) Faire\\n        Si P->x = P->suivant->x Alors\\n            Tmp := P->suivant;\\n            P->suivant := Tmp->suivant;\\n            liberer(Tmp);\\n        Sinon\\n            P := P->suivant;\\n        Fin Si;\\n    Fin Tantque;\\nFin.\">Exécuter cette solution</button>\n  </details>\n</div>\n"
    },
    {
      "title": "Fin du chapitre / Questions",
      "content": "### Synthèse\nVous maîtrisez désormais les concepts fondamentaux des listes simplement chaînées : déclaration, création (FIFO et LIFO), parcours, insertion (début, milieu), suppression (début, milieu), tri par sélection et libération mémoire. Vous avez également vu comment modulariser le code et traiter les cas particuliers.\n\n### Bonnes pratiques à retenir\n- Vérifier systématiquement `NIL` avant tout accès à un pointeur.\n- Préserver les adresses avant de modifier des pointeurs (toujours garder une référence vers le maillon suivant avant de supprimer ou réaffecter).\n- Libérer chaque maillon supprimé avec `liberer()`.\n- Tester les cas limites : liste vide, un seul élément, insertion/suppression en tête, élément absent.\n\n<strong>Questions ?</strong> N'hésitez pas à revoir les exercices pour consolider ces notions."
    }
  ]
}