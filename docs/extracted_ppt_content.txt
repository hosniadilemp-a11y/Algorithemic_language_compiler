=== FILE: Chapitre 1 Le langage algorithmiqueH.pptx ===

--- Slide 1 ---
Chapitre 1 
Le langage algorithmique
2Ã¨me AnnÃ©e MI

 
<number>

--- Slide 2 ---


1. DÃ©finitions :

Câ€™est un nombre fini dâ€™instructions Ã  appliquer dans un ordre dÃ©terminÃ© Ã  un nombre fini de donnÃ©es permettant dâ€™atteindre un rÃ©sultat correct ou exacte.  Â«Â dictionnaire informatiqueÂ Â»




<number>

--- Slide 3 ---
2- PropriÃ©tÃ©s dâ€™un algorithme :
Chaque algorithme doit vÃ©rifier les 3 propriÃ©tÃ©s suivantes :

A- Justesse : un algorithme juste donne toujours le bon rÃ©sultats quelque soit les donnÃ©es en entrÃ©e, le concepteur doit prÃ©voir tous les cas possible.

B- ClartÃ© : un algorithme non clair est embrouillÃ© est trÃ¨s difficile Ã  lire et Ã  modifier mÃªme par son concepteur et quasiment impossible par dâ€™autre personnes.

C- EfficacitÃ© : câ€™est la mesure la plus importante, comme il existe parfois plusieurs solutions on peut parler de la meilleure. Donc un algorithme est le plus efficace sâ€™il permet de rÃ©soudre le problÃ¨me donnÃ© tout en utilisant le moins dâ€™espace mÃ©moire possible et en donnant les rÃ©sultats le plus rapidement possible aussi.




<number>

--- Slide 4 ---
3. Structure gÃ©nÃ©rale dâ€™un algorithme :

 algorithme  <identificateur> ;                         
      <dÃ©claration des constantes> ;
      <dÃ©claration des variables> ;                    
 debut
      <partie instruction> ;                 
 fin.
<number>

--- Slide 5 ---
<number>
3.1.  Un identificateur :
Un identificateur est une suite de caractÃ¨res alphanumÃ©riques (a..z, A..Z, 0..9), les autres caractÃ¨res ne sont pas autorisÃ©s sauf (â€˜_â€™ tirÃ© 8). Il doit respecter les condition suivantes : 
 - Il commence obligatoirement par une lettre alphabÃ©tique. 
 - Pas dâ€™espace entre ses caractÃ¨res
- Il ne doit pas Ãªtre un mot clÃ© comme : algorithme, debut,  
  fin, â€¦etc. (les mots clÃ©s seront Ã©tudiÃ©s au fur et Ã  mesure).
 - Il vaut mieux choisir des identificateurs significatifs
Exemple :
a, b , alpha, s10, som_div, som  : sont des identificateurs correctes.
3v, a3-x, livrÃ©, Âµ ,Ï€  , som div : sont des identificateurs incorrectes


--- Slide 6 ---
<number>

3.2 . DÃ©claration des constantes :

Une constante est un objet auquel on attribue une valeur Ã  la dÃ©claration. Sa valeur ne peut pas Ãªtre modifiÃ©e tout au long dâ€™un algorithme.  Sa syntaxe  de dÃ©claration est :



Le mot clÃ© cons sâ€™Ã©crit une seule fois dans lâ€™algorithme quelque soit le nombre de constantes.

Exemples :
  const   n=100;
                pi=3.14;
                lettre =â€˜fâ€™;
                module = â€˜â€™informatiqueâ€™â€™;


const   <identificateur>  =  <valeur> ;

--- Slide 7 ---
<number>
3.2 . DÃ©claration des variables :

Une variable est un objet dont sa valeur peut Ãªtre modifiÃ©e dans lâ€™algorithme selon besoin. Sa dÃ©claration est prÃ©cÃ©dÃ©e par le mot clÃ© var. Sa syntaxe de dÃ©claration estÂ :



Le mot clÃ© var sâ€™Ã©crit une seule fois dans un algorithme quelque soit le nombre de variables.

 <liste_variables> : peut contenir une variable ou plusieurs  variables sÃ©parÃ©es par des virgules.
 <type> : les types de bases et leur syntaxe sontÂ :
var  <liste_variables>  :  <type> ;

--- Slide 8 ---
<number>
Exemples:
var  x : entier;                                    
var  x, y : caractere;     
var  x : entier;
             y, z : reel;

--- Slide 9 ---
<number>
Une variable du type caractÃ¨re possÃ¨de 256 valeurs . Donc, elle appartient Ã  lâ€™ensemble fini suivant. 
{'a', 'b',â€¦, 'z'} {{'A', 'B',â€¦, 'Z'}  {'0', '1',â€¦, '9'}  {'. ', '? ', '! ', '\', â€¦}
Chaque  caractÃ¨re a un code ASCII (un chiffre qui le reprÃ©sente).
Les opÃ©rations de comparaisons (=, < >, <, <=, >, >=) sont possibles sur ce type. 
La comparaison se fait en se basant sur la position du caractÃ¨re dans la table ASCII ('0â€˜<'1'<â€¦<'9'<'A'<â€¦<â€˜Zâ€˜â€¦.. <'a'<â€¦<'z' â€¦.).

--- Slide 10 ---
<number>
OpÃ©rations sur les entiers :
Les opÃ©rations arithmÃ©tiques  :
     +   : addition
     -    : soustraction
     *   : multiplication
     /    : division rÃ©elle
     div : division entiÃ¨re
     mod : reste de la division entiÃ¨re.
 
Exemple : 
      5 + 2  donne  7
      5 - 2  donne  3
      5*2  donne  10
      5/2  donne  2.5         
      5 div 2  donne  2
      5 mod 2  donne  1

--- Slide 11 ---
<number>

Les opÃ©rations de comparaison  :

     =    : Ã©galitÃ©
     <>  : diffÃ©rence
     <    : infÃ©rieur strictement
     <=  : infÃ©rieur ou Ã©gale
     >    : supÃ©rieur strictement
     >=  : supÃ©rieur ou Ã©gale.

--- Slide 12 ---
<number>
OpÃ©ration sur les rÃ©els :
Les opÃ©rations sur les rÃ©els sont les mÃªmes que celles dÃ©finies sur les entiers, exceptÃ© le div et le mod qui sâ€™appliquent que sur les entiers.
OpÃ©ration sur les caractÃ¨res :
Les opÃ©rations possibles sur les caractÃ¨res sont les opÃ©rations de comparaisons (=, <>, <, <=, >, >=) et la comparaison se fait en se basant sur la position du caractÃ¨re dans la table ASCII 
   â€˜0â€™<â€˜1â€™<â€¦<â€˜9â€™<â€˜Aâ€™<â€¦<â€˜Zâ€™ <â€¦â€¦â€¦..<â€˜aâ€™<â€¦<â€˜zâ€™ â€¦.
OpÃ©ration sur les boolÃ©ens :
Les opÃ©rations possibles sur les boolÃ©ens sont les opÃ©rations logiques suivantes   :  
NON : la nÃ©gation logique
OU :  le ou logique
ET : le et logique


--- Slide 13 ---

   
   ()
Â 
Â 
Â 
*     /        div        mod   
Â 
Â 
+       - 
ElevÃ©e
Faible

Ordre de prioritÃ© des opÃ©rateurs arithmÃ©tiques :
Le calcul dâ€™une expression se fait de de la prioritÃ© la plus Ã©levÃ©e Ã  la prioritÃ© la plus faible . 
Les opÃ©rateurs qui se trouvent sur le mÃªme niveau ont la mÃªme prioritÃ©, leur calculs se fait de gauche Ã  droite.
13

--- Slide 14 ---

   
   ()

Â 
Â   non

   et

   ou 
ElevÃ©e
Faible

Ordre de prioritÃ© des opÃ©rateurs logiques : 
Le calcul dâ€™une expression se fait de de la prioritÃ© la plus Ã©levÃ©e Ã  la prioritÃ© la plus faible . 
Les opÃ©rateurs qui se trouvent sur le mÃªme niveau ont la mÃªme prioritÃ©, leur calculs se fait de gauche Ã  droite.
14

--- Slide 15 ---

Exemple : 
Donner le rÃ©sultat des expressions suivantes :

a=4+5*6
b=(4+5)*6
x=Vrai ou Vrai et Faut
y=(Vrai ou Vrai) et Faut

Solution :
a=4+30 = 34
b=9*6 = 54
x=Vrai ou Faut= Vrai
y=Vrai et Faut = Faut
15

--- Slide 16 ---
<number>
3.3.1. Lâ€™instruction dâ€™affectation :
lâ€™affectation permet de mettre le rÃ©sultat dâ€™une expression dans une variable. Pour le faire, on peut utiliser le symbole : ïƒŸ   ou le symbole  :=

On peut alors utiliser la syntaxe 1 :
                         
Ou bien la syntaxe 2 : 

Dans notre  cours on va utiliser la syntaxe 2 ( qui utilise le symbole  :=  )

<expression> peut Ãªtre :
 Une valeur
 Une constante
 Une variable
 Une expression arithmÃ©tique ou logique

3.3. Partie instruction :
Elle constitue lâ€™ensemble des instructions Ã  appliquer pour rÃ©soudre le problÃ¨me.
variable ïƒŸ <expression> ;
variable := <expression> ;

--- Slide 17 ---
<number>

Exemple :

const  N=10;
car a,b,d : entier;
                x : reel;

    a := 10;                            /* valeur */
    b := N;                             /* constante */
    d := a;                              /* variable */
    x := a/2 + 2*N â€“ 20;       /* expression */

--- Slide 18 ---
<number>
3.3.2.  Lâ€™instruction de Lecture  :

Cette instruction permet de lire des valeurs Ã  partir du clavier et les stocker dans des variables.

Syntaxe :
                         

<liste_variable> :  est soit une variable ou plusieurs sÃ©parÃ©es par des virgules.

Exemple : lire(a);    lire(x, y); lire(a, x, y);

lire ( <liste_variable> ) ;

--- Slide 19 ---
<number>
3.3.3. Lâ€™instruction dâ€™Ã©criture :
Lâ€™instruction ecrire permet dâ€™afficher Ã  lâ€™Ã©cran un ou plusieurs objets.

Syntaxe :
                         


<liste_objets> :  est soit un objet ou plusieurs sÃ©parÃ©s par des virgules. Un objet peut Ãªtre une valeur, une constante, une variable, une expression arithmÃ©tique, une constante chaine de caractÃ¨res, ou leur combinaison.

ecrire( <liste_objets> ) ;

--- Slide 20 ---
<number>
Pour bien comprendre lâ€™instruction dâ€™Ã©criture, nous prÃ©sentons dans le tableau suivant quelques exemples dâ€™Ã©critures et leurs affichages sur Ã©cranÂ :

Soir x et y deux variables, avec x=5 et  y=8


--- Slide 21 ---
<number>


Exercice 1 :

Ecrire un algorithme qui permet de lire deux entiers x et y, puis calcule et affiche leur somme. 


--- Slide 22 ---
<number>

3.3.4. Instructions conditionnelles :

Une instruction conditionnelle est une instruction qui permet de rÃ©aliser un test (condition) et dâ€™exÃ©cuter ou non un groupe dâ€™instruction selon la valeur du test rÃ©alisÃ©. La condition est une expression boolÃ©enne (dont lâ€™Ã©valuation donne soit vrai ou faux).

On distingue 4 formes :
1- conditionnelle simple.
2- conditionnelle alternative.
3- conditionnelle imbriquÃ©e.
4- conditionnelle Ã  choix multiple.

--- Slide 23 ---
<number>

--- Slide 24 ---
<number>
Remarque : 
Une condition peut Ãªtre simple ou composÃ©e de plusieurs conditions reliÃ©es entre elles par des opÃ©rateurs logiques ( ou, et ).

Un bloc dâ€™instructions peut contenir une ou plusieurs instructions.

Si un bloc dâ€™instructions contient une seule instruction seulement, alors dÃ©but et fin peuvent Ãªtre enlevÃ©s.

--- Slide 25 ---
<number>
Exercice 2 : 
Ecrire un algorithme qui lit la moyenne dâ€™un Ã©lÃ¨ve (on suppose que la moyenne est supÃ©rieure Ã  0). Puis, affiche son orientation (MI ou ST). 
Un Ã©lÃ¨ve est orientÃ© vers la spÃ©cialitÃ© MI si sa moyenne est supÃ©rieur Ã  12. Sinon, il est orientÃ© vers la spÃ©cialitÃ© ST. 

--- Slide 26 ---
<number>
Exercice 3 : 
Ecrire lâ€™algorithme qui permet de lire le degrÃ© dâ€™un angle. Puis, dâ€™afficher son typeÂ : aigu, droit, obtus, plat ou rentrant.

IndicationÂ :
- Un angle est aigu si son degrÃ© < 90.
- Un angle est droit si son degrÃ© = 90.
- Un angle est obtus si son degrÃ© >90 et <180.
- Un angle est plat si son degrÃ© =180.
- Un angle est rentrant si son degrÃ© est >180 et <360. 

--- Slide 27 ---
<number>
 Conditionnelle Ã  choix multiple.
Lâ€™instruction conditionnelle Ã  choix multiple est utilisÃ©e lorsquâ€™une expression prend des valeurs dans un ensemble fini et pour chaque valeur, un ensemble dâ€™instructions est exÃ©cutÃ©.

--- Slide 28 ---
<number>

Fonctionnement : 

Si la de valeur <expression> = valeur 1 alors câ€™est le Bloc1 dâ€™instructions qui est exÃ©cutÃ©, 
Sinon, Si la de valeur <expression> = valeur 2 alors câ€™est le Bloc2 dâ€™instructions qui est exÃ©cutÃ©
 â€¦â€¦.
Sinon, Si la de valeur <expression> = Valeur n alors câ€™est la Blocn dâ€™instructions qui est exÃ©cutÃ©.

Remarques: 
Si un bloc dâ€™instructions contient une seule instruction seulement, alors dÃ©but et fin peuvent Ãªtre enlevÃ©s.
La partie sinon est facultative si elle existe et la valeur de <expression> est diffÃ©rente de valeur 1 , valeur 2 , â€¦, valeur n alors câ€™est le Blocn+1 dâ€™instructions qui est exÃ©cutÃ©.




--- Slide 29 ---
<number>

Exercice  4 : 
Ecrire lâ€™algorithme qui permet de lire un nombre entier x. Puis, dâ€™afficher ce chiffre en lettres sâ€™il est compris entre 1 et 5, sinon dâ€™afficher le message Â« ce nombre nâ€™est pas entre un et cinq Â».


--- Slide 30 ---
<number>

Exercice  en plus : 
Variable  Note : numÃ©rique 
Lire (Note) 
Selon Que       
       Note > 10 : Ecrire Â« passable Â»
       Note > 12 : Ecrire Â« assez bien Â»
      Note > 14 : Ecrire Â« bien Â»
       Note > 16 : Ecrire Â« trÃ¨s bien Â»
Sinon : Ecrire Â« ajournÃ© Â» 
Fin Selon Que

-Câ€™est quoi le problÃ¨me dans cette Ã©critureÂ ? RÃ©Ã©crire lâ€™action Mention en utilisant seulement des si-alors sinon.



--- Slide 31 ---
<number>

Exercice  en plus : 
Variable Note : numÃ©rique Lire Note Si Note > 16 alors Ecrire Â« TrÃ¨s bien Â» Sinon       Si Note > 14 alors Ecrire Â« Bien Â»       Sinon                  Si Note > 12 alors Ecrire Â« Assez Bien Â»             Sinon                        Si Note > 10 alors Ecrire Â« Passable Â»                   Sinon Ecrire Â« AjournÃ© Â»                   Fsi                  Fsi            Fsi      Fsi 


--- Slide 32 ---
<number>

Exercice  en plus : 
â—¼ Ecrire un algorithme qui lit deux nombres, une opÃ©ration arithmÃ©tique (+, -, *, /) et affiche le rÃ©sultat de lâ€™opÃ©ration.
â—¼ Ecrivez un algorithme qui lit deux valeurs entiÃ¨res (A et B) au clavier
et qui affiche le signe du produit de A et B sans faire la multiplication.
â—¼ Ecrivez un algorithme qui lit trois valeurs entiÃ¨res (A, B et C) au
clavier. Triez les valeurs A, B et C par Ã©changes successifs de maniÃ¨re
Ã  obtenir : val(A) val(B) val(C)
â—¼ Ecrivez un algorithme qui lit deux valeurs entiÃ¨res (A et B) au clavier
et qui affiche le signe de la somme de A et B sans faire l'addition.
Utilisez la fonction abs. abs(-2) = 2


--- Slide 33 ---
<number>

Exercice 4.1  : 
Ecrire lâ€™algorithme qui permet de lire et afficher la somme de 5 nombres entier. 


--- Slide 34 ---
<number>

algorithme Exercice 4.1;                         
      var a1,a2, a3 ,a4, a5, somme: entier;
Debut
	 somme:=0;
	lire(a1);
	somme:= somme + a1;
	lire(a2);
	somme:= somme + a2;
	lire(a3);
	somme:= somme + a3;
	lire(a4);
	somme:= somme + a4;
	lire(a5);
	somme:= somme + a5;
                   ecrire(somme);
 fin.

Exercice 4.1  : 


algorithme Exercice 4.1;                         
      var A, somme, i: entier;
Debut
	 somme:=0;
	pour i :=  1 a  5 faire
	debut
	    lire(A);
	    somme:= somme + A;
	 finÂ ;
                  ecrire(somme);
 fin.

--- Slide 35 ---
<number>

3.3.5. Instructions itÃ©ratives :

Les instructions itÃ©ratives ou boucles sont des instructions composÃ©es qui permettent de rÃ©pÃ©ter plusieurs fois un bloc dâ€™instructions.

Il existe trois formes de boucles :

                     1- La boucle    pour
                     2- La boucle    tant que 
                     3- La boucle    repeter   jusquâ€™a

--- Slide 36 ---
<number>
OÃ¹:
<compteur> : est une variable qui contrÃ´le le nombre de rÃ©pÃ©titions. Elle possÃ¨de une valeur initiale et une valeur finale.
< Exp_1> et < Exp_2> : reprÃ©sentent respectivement la valeur initiale et la valeur finale du compteur. Chacune peut Ãªtre une valeur simple ou le rÃ©sultat dâ€™une expression arithmÃ©tique.
<compteur> , < Exp_1> et < Exp_2> : peuvent Ãªtre de type entier ou caractÃ¨re. 
3.4.1.  La boucle Â«Â pourÂ Â»  :
Syntaxe :

--- Slide 37 ---
<number>
Remarque : 
 Le nombre de rÃ©pÃ©titions=valeur finale-valeur initiale +1.

 A la sortie de la boucle, le compteur =valeur finale+1.

Le compteur sâ€™incrÃ©mente automatiquement de 1 sans rajouter lâ€™instructionÂ : iÂ := i+1.

Si un bloc dâ€™instructions contient une seule instruction seulement, alors dÃ©but et fin peuvent Ãªtre enlevÃ©s.


--- Slide 38 ---
<number>

Exercice 4.1  : 

	

algorithme Exercice 4.1;                         
 var A, somme, i: entier;
Debut
	 somme:=0;
	pour i :=  1 a  5 faire
	debut
	    lire(A);
	    somme:= somme + A;
	 finÂ ;
                  ecrire(somme);
 fin.



--- Slide 39 ---
<number>

Exercice 5 : 
Ecrire un algorithme qui permet de lire deux entiers a et b (un entier peut Ãªtre positif ou nÃ©gatif). Puis, dâ€™afficher leur produit sans utiliser lâ€™opÃ©rateur de multiplication, Ã©tudier les deux cas, (positif ou nÃ©gatif). 

--- Slide 40 ---
<number>

Exercice 5.1  : 
Ã‰crivez un algorithme qui vous permet de lire une sÃ©rie de nombres entiers. Jusqu'Ã  ce que leur somme soit supÃ©rieure Ã  30.


--- Slide 41 ---
<number>
La condition de rÃ©pÃ©tition doit Ãªtre initialisÃ©e avant la boucle.
Dans le bloc dâ€™instructions, il faut avoir une instruction qui permet la modification de la condition (pour ne pas avoir une boucle infinie).
Remarque : 
Si un bloc dâ€™instructions contient une seule instruction seulement, alors dÃ©but et fin peuvent Ãªtre enlevÃ©s.
3.4.2.  La boucle Â«Â tant queÂ Â»  :
Syntaxe :

--- Slide 42 ---
<number>

Exercice 5.1  : 

	

algorithme Exercice 5.1;                         
 var A, somme, i: entier;
Debut
	 somme:=0;i:=0;
     tant que somme <= 30 faire
	debut
	    lire(A);
	    somme:= somme + A;
	    i:=i+1;
	 finÂ ;
                  ecrire(i);
 fin.



--- Slide 43 ---
<number>


Exercice 6 : 
Ecrire un algorithme qui permet de lire deux entiers positifs a et b (bâ‰ 0). Puis, de calculer le quotient et le reste de a par b sans utiliser lâ€™opÃ©rateur de la division ( utiliser que des soustractions).


--- Slide 44 ---
<number>
La condition de rÃ©pÃ©tition doit Ãªtre initialisÃ©e avant ou Ã  lâ€™intÃ©rieur de la boucle.
Dans le bloc dâ€™instructions, il faut avoir une instruction qui permet la modification de la condition (pour ne pas avoir une boucle infinie).
Remarque: 
Si un bloc dâ€™instructions contient une seule instruction seulement, alors dÃ©but et fin peuvent Ãªtre enlevÃ©s.
3.4.3.  La boucle Â«Â repeter jusquâ€™Ã Â Â»  :
Syntaxe :

--- Slide 45 ---
<number>


Exercice 7 : 
Ecrire un algorithme qui permet de lire deux entiers positifs a et b (b <= a), contrÃ´ler la lecture dans lâ€™algorithme. Puis, de calculer et dâ€™afficher le quotient et le reste de a par b sans utiliser lâ€™opÃ©rateur de la division (utiliser que des soustractions).


--- Slide 46 ---
<number>

Choix de la boucle Ã  utiliser :

Choisir entre les trois boucles


--- Slide 47 ---
<number>

Choix de la boucle Ã  utiliser :
Pour choisir entre les trois boucles on passe par les questions suivantes :

est ce quâ€™on connait le nombre dâ€™itÃ©rations ? si oui câ€™est la boucle pour quâ€™il faudra utiliser (Ã©tant la plus simple).
sinon : est ce que le nombre dâ€™itÃ©rations est  >=1 ? Si oui câ€™est la boucle repeter jusqâ€™a quâ€™il faudra utiliser, parce que on a au mois une itÃ©ration quelle que soit la condition. 
sinon on utilise la boucle tant que.

--- Slide 48 ---
<number>
Les commentaires :
Les commentaires ne sont pas des instructions mais juste des explications quâ€™on introduit dans un algorithme pour expliquer lâ€™utilitÃ© de certains objets ou le travail fait par un sous ensemble dâ€™instructions â€¦ . Il existe deux faÃ§ons de faire un commentaires :

 1. Un commentaire commence par /* et se termine par */
     Dans le cas dâ€™un commentaire Ã©crit sur plusieurs lignes.

 2. Un commentaire qui commence par  //
       Dans le cas dâ€™un commentaire Ã©crit sur une seule ligne.

Exemple :
x := yÂ ; // veut dire que la variable x reÃ§oit la valeur de la variable y
x := y+z*wÂ ; /*cette instruction arithmÃ©tique contient 02 opÃ©rateurs. Pour lâ€™Ã©valuer, il faut prendre en considÃ©ration la prioritÃ©, la multiplication est plus prioritaire que lâ€™addition */ 


=== FILE: Chapitre 10 Les files.pptx ===

--- Slide 1 ---

Chapitre 10:
Les files
Ecole Nationale PrÃ©paratoire aux Etudes dâ€™IngÃ©niorat Badji Mokhtar

Docteur: A. MAHANI

--- Slide 2 ---
2
Dans quelques applications informatiques, on nÃ©cessite le traitement des donnÃ©es dans lâ€™ordre de leur arrivÃ©e oÃ¹ la premiÃ¨re donnÃ©e ajoutÃ©e sera la premiÃ¨re traitÃ©e.
Exemple: Gestion des ressources informatique (gestion des imprimantes, â€¦.).

Donc, il est nÃ©cessaire dâ€™utiliser une nouvelle structure de donnÃ©es, appelÃ©e File.
1. Introduction:

--- Slide 3 ---
3
Une file est une structure de donnÃ©es fondÃ©e sur le principe Â«premiÃ¨re donnÃ©e ajoutÃ©e est la premiÃ¨re extraite Â» (FIFO: First In First Out). Elle contient des donnÃ©es qui sont du mÃªme type (simples ou structurÃ©es).
Lâ€™ajout dâ€™Ã©lÃ©ment se fait par la queue et le retrait se fait par la tÃªte (on retire le premier Ã©lÃ©ment de la file). Lâ€™accÃ¨s Ã  un Ã©lÃ©ment quelconque se fait aprÃ¨s le retrait de tous les Ã©lÃ©ments qui le prÃ©cÃ¨dent.
Donc, une file doit Ãªtre repÃ©rÃ© par la tÃªte et la queue.

2. DÃ©finition dâ€™une file:
Retrait
Ajout



--- Slide 4 ---
4
 Gestion dâ€™impression.
SystÃ¨me multitÃ¢ches.
Les files dâ€™attente. 
 

3. Les domaines dâ€™application des piles:

--- Slide 5 ---










5
4. Les primitives de manipulation:
Pour pouvoir manipuler les files, on utilise les primitives  suivantes:
 Initialisation dâ€™une file.
 Ajout dâ€™un Ã©lÃ©ment.
 Retrait dâ€™un Ã©lÃ©ment.
 Consultation du premier Ã©lÃ©ment.
 Test de lâ€™Ã©tat de la file.
Dans ce qui suit, on va dÃ©tailler chaque primitive.




 

--- Slide 6 ---










6
4.1. Initialisation dâ€™une file:
Permet dâ€™ouvrir une file vide. Sa syntaxe est:




 

--- Slide 7 ---










7
4.2. Ajout dâ€™un Ã©lÃ©ment: 
Permet dâ€™ajouter un Ã©lÃ©ment Ã  la fin dâ€™une file. Sa syntaxe est:




 

--- Slide 8 ---










8
4.3. Retrait dâ€™un Ã©lÃ©ment: 
Permet de retirer un Ã©lÃ©ment de la file et de rÃ©cupÃ©rer sa valeur dans une variable (lâ€™Ã©lÃ©ment retirÃ© est supprimÃ© de la file). Sa syntaxe est:



 

--- Slide 9 ---










9
4.4. Consultation de la tete:
Permet de consulter ou de rÃ©cupÃ©rer le premier Ã©lÃ©ment de la file dans une variable sans le supprimer. Mais, il faut Ãªtre sÃ»r que la file nâ€™est pas vide. Sa syntaxe est:




 

--- Slide 10 ---










10
4.5. Test de lâ€™Ã©tat de la pile:
Permet de vÃ©rifier si une file est vide ou non. Sa syntaxe est:


Cette fonction retourne la valeur Â«vraiÂ» si la file est vide. Sinon, elle retourne la valeur Â«fauxÂ».


--- Slide 11 ---
11
Il existe deux types de reprÃ©sentation des files en mÃ©moire:

 ReprÃ©sentation Ã  lâ€™aide des tableaux.

 ReprÃ©sentation Ã  lâ€™aide des listes simplement chainÃ©es.
Donc, les primitives de manipulation dÃ©pendent de la reprÃ©sentation utilisÃ©e.  
Dans ce chapitre, on va voir seulement la reprÃ©sentation dâ€™une file par une liste simplement chainÃ©e.
5. ReprÃ©sentation des files en mÃ©moire:

--- Slide 12 ---










12
6. ReprÃ©sentation dâ€™une file avec une liste simplement chainÃ©e:
Une file est repÃ©rÃ© par lâ€™adresse de son premier Ã©lÃ©ment Â«teteÂ» et lâ€™adresse de son dernier Ã©lÃ©ment queue.

Exemple:  soit la file suivante.


 

--- Slide 13 ---
13
On considÃ¨re que le type de la partie information de la file est: <type_element> 








On rajoute aussi lâ€™enregistrement qui contient la tÃªte et la queue.


6.1. DÃ©claration dâ€™une file:

--- Slide 14 ---
14











6.1. DÃ©claration dâ€™une file:

--- Slide 15 ---
15











Exemple de dÃ©claration dâ€™une file dâ€™entier:

--- Slide 16 ---
16
 6.2.1. InitialiserFile:
6.2. Les primitives de manipulation:

--- Slide 17 ---










17
6.1.2. Enfiler:
Lâ€™enfilement dâ€™un Ã©lÃ©ment revient Ã  faire un ajout Ã  la fin de la liste.

Exemple:  soit la file suivante.


 

--- Slide 18 ---
18

--- Slide 19 ---










19
6.1.3. DÃ©filer:
Le dÃ©filement dâ€™un Ã©lÃ©ment revient Ã  faire une suppression au dÃ©but de la liste en rÃ©cupÃ©rant lâ€™Ã©lÃ©ment supprimÃ©.

Exemple:  soit la file suivante:


 

--- Slide 20 ---
20

--- Slide 21 ---
21
6.1.4. TeteFile:

--- Slide 22 ---
22
6.1.5. FileVide:

--- Slide 23 ---
Ecrire lâ€™action paramÃ©trÃ©e Creation qui permet de crÃ©er une file de N entiers.
Ecrire lâ€™action paramÃ©trÃ©e Affichage qui affiche lâ€™Ã©lÃ©ment qui se trouve dans la position k sâ€™il existe. 
Ecrire un algorithme qui permet de crÃ©er une file de N entiers. Puis, dâ€™afficher lâ€™Ã©lÃ©ment qui se trouve dans la position pos (pos est donnÃ©e par lâ€™utilisateur). 
Remarque: Utiliser les primitives de manipulation des files.
23
Exercice :


=== FILE: Chapitre 2 Les tableaux et les matricesh.pptx ===

--- Slide 1 ---

Chapitre 2:
Les tableaux et les matrices
Ecole Nationale PrÃ©paratoire aux Etudes dâ€™IngÃ©niorat Badji Mokhtar

Docteur: A. MAHANI

--- Slide 2 ---
0. Introduction:
Un tableau est une structure de donnÃ©es complexe qui peut contenir plusieurs Ã©lÃ©ments du mÃªme type dÃ©signÃ©s par un identificateur unique. Il existe deux types de tableauxÂ : 
 Les tableaux Ã  une seule dimension, appelÃ©s vecteurs ou tableaux.
 Les tableaux Ã  deux dimensions connus sous le nom matrices.

2

--- Slide 3 ---
3
Les tableaux Ã  une seule dimension (les vecteurs)

1.1. DÃ©claration dâ€™un tableau:

OÃ¹:
<taille maximale>: peut Ãªtre:
 Une valeur. Exemple: T[100]: tableau dâ€™entier;
 La valeur dâ€™une constante. Exemple:
 const N=100;
 T[N]: tableau de reel;


--- Slide 4 ---
4
1.2. ReprÃ©sentation dâ€™un tableau dans la mÃ©moire:
Les Ã©lÃ©ments dâ€™un tableau sont stockÃ©s dans la mÃ©moire dans un espace contigu (lâ€™un Ã  la suite de lâ€™autre).
Graphiquement, un tableau est reprÃ©sentÃ© par une suite de cases consÃ©cutives oÃ¹ chaque case est repÃ©rÃ©e par un indice. Pour un tableau de taille N, lâ€™indice de la premiÃ¨re case est 0 et lâ€™indice de la derniÃ¨re case est N-1. 

ExempleÂ :





--- Slide 5 ---
5
1.3. AccÃ¨s aux Ã©lÃ©ments dâ€™un tableau:
Pour accÃ©der Ã  un Ã©lÃ©ment dâ€™un tableau, on Ã©critÂ :


<indice> doit appartenir Ã  [1, N] et il peut prendre la forme de nâ€™importe quelle expression arithmÃ©tique de type entier.
Exemple: dans lâ€™exemple prÃ©cÃ©dent:
T[2]=3.
Si i=1 alors T[i]=T[1]=5; 
T[1+15 div 5]=T[1+3]=0;

--- Slide 6 ---
6
Remarque:
Il faut faire la diffÃ©rence entre la taille maximale dâ€™un tableau et sa taille rÃ©elle (significative).
- La taille maximale est donnÃ©e dans la dÃ©claration.
- La taille rÃ©elle est donnÃ©e par lâ€™utilisateur.





--- Slide 7 ---
7
1.4. Lecture et Ã©criture dâ€™un tableau:

La lecture ou lâ€™Ã©criture dâ€™un tableau T de taille N consiste Ã  lire ou Ã  Ã©crire chaque case en utilisant la boucleÂ suivante:
 


--- Slide 8 ---
8
Exercice 1:
Ecrire un algorithme qui permet de lire un tableau de rÃ©els de taille 10. Puis, de calculer et dâ€™afficher la moyenne de ses valeurs.



--- Slide 9 ---
9
Exercice 2:
Ecrire un algorithme qui permet de lire le tableau dâ€™entiers T de taille N (N est donnÃ© par lâ€™utilisateur avec 1â‰¤N â‰¤50). Puis, de calculer et dâ€™afficher le nombre dâ€™apparition dâ€™une valeur x dans T (x est une valeur quelconque donnÃ©e par lâ€™utilisateur).



--- Slide 10 ---
10
Exercice 3:
Soit T un tableau de caractÃ¨res de taille N (N est donnÃ© par lâ€™utilisateur avec 1â‰¤N â‰¤50). 
Ecrire un algorithme qui permet de lire les (N-1) valeurs du T (en laissant la derniÃ¨re case vide). Puis, de lire le caractÃ¨re x et lâ€™insÃ©rer dans la position p (p est donnÃ©e par lâ€™utilisateur avec 1â‰¤p â‰¤N). Enfin, dâ€™afficher le tableau T.
Exemple:  x='a'; p=3







--- Slide 11 ---
11
Exercice 4:
Ecrire un algorithme qui permet de lire le tableau dâ€™entiers T de taille N (N est donnÃ© par lâ€™utilisateur avec 1â‰¤N â‰¤30). Puis, de supprimer la premiÃ¨re apparition de la valeur val (val est donnÃ©e par lâ€™utilisateur). Dans le cas oÃ¹ val nâ€™existe pas dans T, alors afficher le message: Â« val nâ€™existe pas Â» sinon afficher T.
Exemple:  val=3







--- Slide 12 ---
12
Exercice 4:
Ecrire un algorithme qui permet de lire le tableau dâ€™entiers T de taille N (N est donnÃ© par lâ€™utilisateur avec 1â‰¤N â‰¤30). Puis, chercher si une valeur existe.
Exemple:  val=3
Si le tableau n'est pas triÃ©
nous devons visiter tous les Ã©lÃ©ments du table.
O(n)
Si le tableau est triÃ©
on peut utiliser la recherche binaire (dichotomique).
O(Log2(n))
17 min
1.8 ms

--- Slide 13 ---
13
Trier un tableau, veut dire ordonner ses Ã©lÃ©ments selon lâ€™ordre croissant ou dÃ©croissant. GÃ©nÃ©ralement, il existe 03 algorithmes de triÂ :  
Par sÃ©lection.
Par permutation.
Par insertion.


Pour expliquer le principe de chaque algorithme, on suppose que le tri se fait selon lâ€™ordre croissant.


1.5. Les algorithmes de tri:

--- Slide 14 ---
14
a. Le tri par sÃ©lection:
Il consiste Ã  parcourir le tableau (N-1) fois tel queÂ :
- Pour T[0]Â : on cherche la position du minimum dans le tableau Ã  partir de la case dâ€™indice 0. Si lâ€™indice du minimum Â«indminÂ» est diffÃ©rent de 0, alors on permute T[0] avec T[indmin].
- Pour T[1]Â : on cherche la position du minimum dans le tableau Ã  partir de la case dâ€™indice 1. Si lâ€™indice du minimum Â«Â indminÂ Â» est diffÃ©rent de 1, alors on permute  T[1] avec T[indmin].
â€¦
- Jusquâ€™Ã  T[N-2].





--- Slide 15 ---
15
Exercice 5:
Ecrire un algorithme qui permet de lire le tableau dâ€™entiers T de taille N (N est donnÃ© par lâ€™utilisateur avec 1â‰¤N â‰¤50). Puis, de le trier en appliquant lâ€™algorithme de tri par sÃ©lection. Enfin, dâ€™afficher T.



--- Slide 16 ---
16
b. Le tri par permutation:
Il consiste Ã  faire plusieurs passages sur le tableau T. Lors de chaque passage, on compare chaque deux Ã©lÃ©ments consÃ©cutifs dâ€™indice i et i+1 et si T[i] est supÃ©rieur Ã  T[i+1] alors on les permute.
Le nombre de passages maximal ne doit pas dÃ©passer (N-2). Mais, si on effectue un passage et on ne trouve pas des permutations alors le tableau est triÃ© et il nâ€™est pas nÃ©cessaire dâ€™effectuer un autre passage. 

--- Slide 17 ---
17
On rajoute un complÃ©ment de cet algorithme afin de lâ€™optimiserÂ : 
A la fin du premier passage, la plus grande valeur est dÃ©calÃ©e vers la fin dans la case dâ€™indice N (elle est dans la bonne place). Donc, dans le deuxiÃ¨me passage, on traite les Ã©lÃ©ments dont lâ€™indice appartient Ã  [1, N-2]. 
Aussi, Ã  la fin du deuxiÃ¨me  passage, la deuxiÃ¨me plus grande valeur est dÃ©calÃ©e vers la fin dans la case dâ€™indice N-1. Donc, dans le troisiÃ¨me passage, on traite les Ã©lÃ©ments dont lâ€™indice appartient Ã  [1, N-3]â€¦

--- Slide 18 ---
18
Exercice 6:
Ecrire un algorithme qui permet de lire le tableau dâ€™entiers T de taille N (N est donnÃ© par lâ€™utilisateur avec 1â‰¤N â‰¤50). Puis, de le trier en appliquant lâ€™algorithme de tri par permutation. Enfin, dâ€™afficher T.



--- Slide 19 ---
19
c. Le tri par insertion:
Son principe consiste Ã  trier les Ã©lÃ©ments dâ€™un tableau un par un. 
A chaque fois quâ€™on trie lâ€™Ã©lÃ©ment T[i], on est sÃ»re que les Ã©lÃ©ments T[j] qui le prÃ©cÃ¨dent sont dÃ©jÃ  triÃ©s (j=i-1, â€¦2, 1,0). Pour cela, on cherche la position dâ€™insertion de T[i] dans les cases qui le prÃ©cÃ¨dent en le dÃ©calant vers la gauche Ã  chaque fois. L'arrÃªt se fera dans les deux cas suivants:
1. L'Ã©lÃ©ment T[j] qui est plus petit que T[i] est trouvÃ©. Alors l'insertion de T[i] se fait dans la position j+1.
2. Il n'existe aucun Ã©lÃ©ment petit que T[i] (tous les Ã©lÃ©ments qui le prÃ©cÃ¨dent sont infÃ©rieurs Ã  T[i]. Par consÃ©quent, on insÃ¨re T[i] dans la position 1.

--- Slide 20 ---
20
Exercice 7:
Ecrire un algorithme qui permet de lire le tableau dâ€™entiers T de taille N (N est donnÃ© par lâ€™utilisateur avec 1â‰¤N â‰¤50). Puis, de le trier en appliquant lâ€™algorithme de tri par insertion. Enfin, dâ€™afficher T.



--- Slide 21 ---
21
2. Les tableaux Ã  deux dimensions:





2.1. DÃ©claration:



Exemples:
mat[100][100] :tableau dâ€™entier;
const N=100;
               M=50;
     mat[N][M]:tableau de caractere;
 

--- Slide 22 ---
22
2.2. ReprÃ©sentation dâ€™une matrice dans la mÃ©moire:
Dans la mÃ©moire centrale, les Ã©lÃ©ments dâ€™une matrice sont stockÃ©s ligne par ligne. Sachant que les Ã©lÃ©ments dâ€™une ligne sont stockÃ©s lâ€™un aprÃ¨s lâ€™autre. 
ExempleÂ : soit la matrice mat suivante:






--- Slide 23 ---
23
2.3. AccÃ¨s aux Ã©lÃ©ments dâ€™une matrice:
Un Ã©lÃ©ment dâ€™une matrice est repÃ©rÃ© par deux indices: lâ€™indice de sa ligne et lâ€™indice de sa colonne. Lâ€™accÃ¨s se fait avec cette syntaxe:


Pour une matrice de taille N*M: lâ€™indice de la ligne appartient Ã  [1,N] et lâ€™indice de la colonne appartient Ã  [1,M].
Exemple: dans lâ€™exemple prÃ©cÃ©dent
 


--- Slide 24 ---
24
Exemple: soit la matrice mat suivante:


mat[0,0]=1;
mat[2,1]=-4;
mat[3*2-5,15 div 5-1]=mat[1,2]=2;


 


--- Slide 25 ---
25
2.4. Lecture dâ€™une matrice:
La lecture dâ€™une matrice Â« mat Â» de taille N*M peut se faire ligne par ligne ou colonne par colonne.
a. Ligne par ligne:


b. Colonne par colonne:



--- Slide 26 ---
26
2.5. Affichage dâ€™une matrice:

Lâ€™affichage dâ€™une matrice Â« mat Â» de taille N*M nÃ©cessite lâ€™affichage de tous ses Ã©lÃ©ments selon le format voulu par lâ€™utilisateur.



--- Slide 27 ---
27
Exercice 8:
Ecrire un algorithme qui permet de lire la matrice dâ€™entiers mat de taille 10*10. Puis, de calculer et dâ€™afficher la moyenne de ses Ã©lÃ©ments.



--- Slide 28 ---
28
Exercice 9:
Ecrire un algorithme qui permet de lire la matrice dâ€™entiers mat de taille N*M (N et M sont donnÃ©s par lâ€™utilisateur avec 1â‰¤Nâ‰¤50 et 1â‰¤Mâ‰¤50). Puis, de calculer et dâ€™afficher le maximum de chaque ligne.



--- Slide 29 ---
29
Exercice 10:
Ecrire un algorithme qui permet de lire la matrice dâ€™entiers mat de taille N*M (N et M sont donnÃ©s par lâ€™utilisateur avec 1â‰¤Nâ‰¤50 et 1â‰¤Mâ‰¤50). Puis, de calculer et dâ€™afficher la somme de chaque colonne.



--- Slide 30 ---
30

--- Slide 31 ---
31
CC1:
Ã‰crire un algorithme qui affiche tous les nombres narcissiques infÃ©rieurs Ã  un nombre entier n donnÃ© par l'utilisateur. 
1, 2 , 3 , â€¦â€¦ , k , â€¦â€¦ , n-3 , n-2 , n-1
nous devons vÃ©rifier tous les nombres infÃ©rieurs Ã  n s'ils correspondent Ã  la condition ou non.
c'est la premiÃ¨re boucle que nous avons dans l'algorithme
Pour k=1 a n-1 faire
Debut
<block instructions>
fin

--- Slide 32 ---
32

--- Slide 33 ---
33
153 / 10 = 15
/ 10 = 1
1 / 10 = 0
Puissances = nombre de chiffre
p=0 , 
p=p+1
153 / 10 = 15
p=p+1
/ 10 = 1
p=p+1
1 / 10 = 0
A=153, p=0
p=p+1 
A / 10 = A
p=p+1
A / 10 = A
p=p+1
A / 10 = A
Exmple, k =153






A=153, p=0
Repeter
debut
p=p+1
A= A / 10 
fin
Jusquâ€™a (A==0)


--- Slide 34 ---
34
CC1:
Pour k=0 a n-1 faire
  Debut
    A=k, p=0
    Repeter
       debut
       p=p+1
       A=A / 10 
       fin
     Jusquâ€™a (A==0)
     <block instructions>
  fin

--- Slide 35 ---
35

--- Slide 36 ---
153 mod 10 =3
153 / 10 = 15
15 mod 10 =5
15 / 10 = 1
1 mod 10 =1
1 / 10 = 0
Puissances = nombre de chiffre
S=0 , 
153 mod 10 =3
S+3**p=S
153 / 10 = 15
15 mod 10 =5
S+5**p=S
15 / 10 = 1
1 mod 10 =1
S+1**p=S
1 / 10 = 0

Exmple, k =153
S=0 , A=153
A mod 10 =R
S+R**p=S
A / 10 = A
A mod 10 =R
S+R**p=S
A / 10 = A
A mod 10 =R
S+R**p=S
A / 10 = 0





--- Slide 37 ---
Puissances = nombre de chiffre
Exmple, k =153
S=0 , A=153
A mod 10 =R
S+R**p=S
A / 10 = A
A mod 10 =R
S+R**p=S
A / 10 = A
A mod 10 =R
S+R**p=S
A / 10 = 0




A=k, S=0
Repeter
debut
R= A mod 10 
S=S+R**p
A= A / 10 
fin
Jusquâ€™a (A==0)

--- Slide 38 ---
38
CC1:
Algorithme CC1
Var  k, n, p, A, R,S: entier;
debut
Pour k=1 a n-1 faire
  Debut
    A=k, p=0;
    Repeter
       debut
       p=p+1;
       A=A / 10 ;
       fin
    Jusquâ€™a (A==0)
A=k, S=0
    Repeter
       debut
         R= A mod 10 ;
         S=S+R**p;
         A= A / 10 ;
       fin
    Jusquâ€™a (A==0)
is ( k==S) alors
Ecrice (k, â€œest Un nombre narcissiqueâ€™â€™ );
Fin Pour
Fin Algorithm


=== FILE: Chapitre 3 Les chaines de caracteÌ€res.pptx ===

--- Slide 1 ---
Chapitre 3
Les chaines de caractÃ¨res 2Ã¨me AnnÃ©e MI

 
1

--- Slide 2 ---

Chapitre 3:
Les chaines de caractÃ¨res
Ecole Nationale PrÃ©paratoire aux Etudes dâ€™IngÃ©niorat Badji Mokhtar


--- Slide 3 ---
3
#include <stdio.h>

int main()
{
    printf("Hello World");
    char c=0;
    for (int i=0;i<128;i++)
    printf("\n%c",c+i );
    
    return 0;
}
Que fait ce programme?????

--- Slide 4 ---
1. DÃ©finition :
Une chaine de caractÃ¨res est une suite finie de caractÃ¨res. Elle peut Ãªtre considÃ©rÃ©e aussi comme un tableau de caractÃ¨res. 


4
Dans un programme informatique, les chaÃ®nes de caractÃ¨res servent Ã  stocker les informations non numÃ©riques comme par exemple une liste de nom de personne ou des adresses.


--- Slide 5 ---
5
2. DÃ©claration dâ€™une chaine de caractÃ¨res:
Elle peut Ãªtre dÃ©clarÃ©e Ã  lâ€™aide de ces deux possibilitÃ©s:



Exemples:
Ch: chaine;
Ch[50]:chaine de caractÃ¨re;
Remarque:
En langage C, la premiÃ¨re dÃ©claration nâ€™est pas possible.

--- Slide 6 ---
6
3. Lecture et Ã©criture dâ€™une chaine de caractÃ¨res:

Une chaine de caractÃ¨res est une variable comme les autres variables du type simple. Donc, elle se lit et sâ€™affiche comme  les autres types.

Syntaxe:







--- Slide 7 ---
7
Remarque:
Lorsquâ€™on saisit une chaine de caractÃ¨res, on ne saisit pas le caractÃ¨re finchaine car il va Ãªtre rajoutÃ© automatiquement. 

Exemple:

ch[50]:chaine de caractere;
Si par exemple, lâ€™utilisateur saisit: Bonjour.
Alors, la reprÃ©sentation de la chaine ch dans la mÃ©moire est:











--- Slide 8 ---
8
4. Initialisation dâ€™une chaine de caractÃ¨res:
Une chaine de caractÃ¨res peut Ãªtre initialisÃ©e en mettant sa valeur entre guillemets ('').
Exemple:
Ch: chaine;
Ch= ''Bonjourâ€™â€™;




--- Slide 9 ---
9
4. Initialisation dâ€™une chaine de caractÃ¨res:
Une chaine de caractÃ¨res peut Ãªtre initialisÃ©e en mettant sa valeur entre guillemets (â€™â€™).

â€˜xâ€™ est un caractÃ¨re constant, qui a une valeur numÃ©rique: Par exemple: 'x' Ã  la valeur 120 dans le code ASCII.
â€œxâ€est un tableau de caractÃ¨res qui contient deux caractÃ¨res: la lettre 'x' et le caractÃ¨re 'finchaine': '\0â€™
â€˜xâ€™ est codÃ© dans un octet
â€œxâ€est codÃ© dans deux octets




--- Slide 10 ---
10
4.1 La table ASCII:






--- Slide 11 ---
11
4.1 La table ASCII:
Var C: char;

C= â€˜Aâ€™ ou C = 65, 
C= â€˜aâ€™ ou C = 97. 

is (C>='0â€™ et C<='9â€™) un chiffre 

is (C>='Aâ€™ et C<='Zâ€™) une majuscules 

is (C>='aâ€™ et C<='zâ€™) une minuscules

Il est facile, de convertir des lettres majuscules dans des minuscules:
is (C>='Aâ€™ et C<='Z') C = C-'A'+'aâ€™; ou vice-versa:
is (C>='aâ€™ et C<='z') C = C-'a'+'A';

--- Slide 12 ---
12
5. Quelques fonctions de manipulation des chaines de caractÃ¨res:

5.1. La fonction longueur:
Elle permet de retourner la taille dâ€™une chaine de caractÃ¨res (le nombre de caractÃ¨res quâ€™elle contient). Sa syntaxe est:


Exemple:
Si la chaine ch=''Bonjour''. Alors
L=longueur(ch);
Donc, L=7.

--- Slide 13 ---
13
5.2. La fonction concat:

Elle permet de retourner une nouvelle chaine de caractÃ¨res, qui est le rÃ©sultat dâ€™ajout une chaine Ã  la fin dâ€™une autre chaine. Sa syntaxe est:


Remarque: 

Lâ€™ordre des chaines de caractÃ¨res dans cette fonction est trÃ¨s important (la <chaine2> va Ãªtre rajoutÃ©e Ã  la fin de <chaine1>.


--- Slide 14 ---
14
Exemple :

ch1,ch2,ch3:chaine;

ch1=''Bonjour'';
ch2=''tout le mondeâ€™â€™; 
1)ch3=concat (ch1,ch2); alors ch3=''Bonjourtout le monde'';
ch4=''  tout le mondeâ€™â€™; 
2)ch3=concat (ch1,ch4); alors ch3=''Bonjour tout le mondeâ€™â€™;
3)ch3=concat (ch1,Â Â Â â€™â€™  â€˜â€™); alors ch3=''Bonjour â€™â€™;
ch3=concat (ch3,Â Â Â ch2); alors ch3=''Bonjour tout le monde'';







--- Slide 15 ---
15
6. Comparaison des chaines de caractÃ¨res:

Les chaines de caractÃ¨res sont comparÃ©es selon lâ€™ordre des caractÃ¨res dÃ©fini dans la table ASCII.
La comparaison se fait Ã  lâ€™aide des opÃ©rateurs de comparaison (<, >, =, <>, â€¦).




--- Slide 16 ---
16
Exemple:

ch1=''Bonjour'';

ch2=''tout le monde'';

On remarque que ch1 est infÃ©rieure Ã  ch2 car la lettre B est infÃ©rieure Ã  la lettre t.

--- Slide 17 ---
17
7. AccÃ¨s aux Ã©lÃ©ments dâ€™une chaine de caractÃ¨res:
Pour accÃ©der Ã  un Ã©lÃ©ment dâ€™une chaine, on Ã©critÂ :


<indice>: pour une chaine de caractÃ¨res de longueur L, indice doit appartenir Ã  [1, L] et il peut prendre la forme de nâ€™importe quelle expression arithmÃ©tique de type entier.
Exemple:
ch=''Bonjour''. 
ch[1]='B'; ch[4]='j'; ch[7]='r';

--- Slide 18 ---
18
Exercice 1:
Ecrire un algorithme qui permet de lire une chaine de caractÃ¨res. Puis, de calculer et dâ€™afficher le nombre de lettres minuscules contenues dans cette chaine.



--- Slide 19 ---
19
Exercice 2:
Ecrire un algorithme qui permet de lire deux chaines de caractÃ¨res. Puis, de les afficher dans lâ€™ordre alphabÃ©tique croissant. 



--- Slide 20 ---
20
Exercice 3:
Ecrire un algorithme qui permet de lire une chaine de caractÃ¨res. Puis, dâ€™afficher un message indiquant si cette chaine est palindrome ou non.
Indication: une chaine est palindrome si elle se lit de la droite vers la gauche ou de la gauche vers la droite.
Exemples:
Â« radar Â», Â« elle Â» sont deux mots palindromes.
 



--- Slide 21 ---
21
8. Les tableaux de chaines de caractÃ¨res (tableau de mots):
Un tableau de mots est reprÃ©sentÃ©e par une matrice de chaines de caractÃ¨res, oÃ¹ chaque ligne reprÃ©sente une seule chaine. 
A noter que chaque chaine a sa propre taille (c'est-Ã -dire le nombre de colonnes nâ€™est pas le mÃªme pour toutes les lignes). Il est dÃ©clarÃ©e comme une matrice. Lâ€™accÃ¨s Ã  un mot qui se trouve dans la ligne i se fait comme suit: 









--- Slide 22 ---
22
Exemple:
Soit le tableau de mots suivant:




A[1]=''math'';
A[3]=''algorithme'';
A[1,1]='m';  A[4,2]='o';


--- Slide 23 ---
23
Exercice 4:
Ecrire un algorithme qui permet de lire un tableau de N mots (N est donnÃ©e par lâ€™utilisateur avec 1â‰¤N â‰¤50). Puis, dâ€™afficher le mot qui a le maximum de lettres alphabÃ©tiques minuscules.
Exemple:



Le mot: AlgoRitHME a le maximum de lettres alphabÃ©tiques minuscules.




=== FILE: Chapitre 3 Les chaines de caractÃ¨res.pptx ===

--- Slide 1 ---
Chapitre 3
Les chaines de caractÃ¨res 2Ã¨me AnnÃ©e MI

 
â€¹#â€º

--- Slide 2 ---

Chapitre 3:
Les chaines de caractÃ¨res
Ecole Nationale PrÃ©paratoire aux Etudes dâ€™IngÃ©niorat Badji Mokhtar


--- Slide 3 ---
â€¹#â€º
#include <stdio.h>

int main()
{
    printf("Hello World");
    char c=0;
    for (int i=0;i<128;i++)
    printf("\n%c",c+i );
    
    return 0;
}
Que fait ce programme?????

--- Slide 4 ---
1. DÃ©finition :
Une chaine de caractÃ¨res est une suite finie de caractÃ¨res. Elle peut Ãªtre considÃ©rÃ©e aussi comme un tableau de caractÃ¨res. 


â€¹#â€º
Dans un programme informatique, les chaÃ®nes de caractÃ¨res servent Ã  stocker les informations non numÃ©riques comme par exemple une liste de nom de personne ou des adresses.


--- Slide 5 ---
â€¹#â€º
2. DÃ©claration dâ€™une chaine de caractÃ¨res:
Elle peut Ãªtre dÃ©clarÃ©e Ã  lâ€™aide de ces deux possibilitÃ©s:



Exemples:
Ch: chaine;
Ch[50]:chaine de caractÃ¨re;
Remarque:
En langage C, la premiÃ¨re dÃ©claration nâ€™est pas possible.

--- Slide 6 ---
â€¹#â€º
3. Lecture et Ã©criture dâ€™une chaine de caractÃ¨res:

Une chaine de caractÃ¨res est une variable comme les autres variables du type simple. Donc, elle se lit et sâ€™affiche comme  les autres types.

Syntaxe:







--- Slide 7 ---
â€¹#â€º
Remarque:
Lorsquâ€™on saisit une chaine de caractÃ¨res, on ne saisit pas le caractÃ¨re finchaine car il va Ãªtre rajoutÃ© automatiquement. 

Exemple:

ch[50]:chaine de caractere;
Si par exemple, lâ€™utilisateur saisit: Bonjour.
Alors, la reprÃ©sentation de la chaine ch dans la mÃ©moire est:











--- Slide 8 ---
â€¹#â€º
4. Initialisation dâ€™une chaine de caractÃ¨res:
Une chaine de caractÃ¨res peut Ãªtre initialisÃ©e en mettant sa valeur entre guillemets ('').
Exemple:
Ch: chaine;
Ch= ''Bonjourâ€™â€™;




--- Slide 9 ---
â€¹#â€º
4. Initialisation dâ€™une chaine de caractÃ¨res:
Une chaine de caractÃ¨res peut Ãªtre initialisÃ©e en mettant sa valeur entre guillemets (â€™â€™).

â€˜xâ€™ est un caractÃ¨re constant, qui a une valeur numÃ©rique: Par exemple: 'x' Ã  la valeur 120 dans le code ASCII.
â€œxâ€est un tableau de caractÃ¨res qui contient deux caractÃ¨res: la lettre 'x' et le caractÃ¨re 'finchaine': '\0â€™
â€˜xâ€™ est codÃ© dans un octet
â€œxâ€est codÃ© dans deux octets




--- Slide 10 ---
â€¹#â€º
4.1 La table ASCII:






--- Slide 11 ---
â€¹#â€º
4.1 La table ASCII:
Var C: char;

C= â€˜Aâ€™ ou C = 65, 
C= â€˜aâ€™ ou C = 97. 

is (C>='0â€™ et C<='9â€™) un chiffre 

is (C>='Aâ€™ et C<='Zâ€™) une majuscules 

is (C>='aâ€™ et C<='zâ€™) une minuscules

Il est facile, de convertir des lettres majuscules dans des minuscules:
is (C>='Aâ€™ et C<='Z') C = C-'A'+'aâ€™; ou vice-versa:
is (C>='aâ€™ et C<='z') C = C-'a'+'A';

--- Slide 12 ---
â€¹#â€º
5. Quelques fonctions de manipulation des chaines de caractÃ¨res:

5.1. La fonction longueur:
Elle permet de retourner la taille dâ€™une chaine de caractÃ¨res (le nombre de caractÃ¨res quâ€™elle contient). Sa syntaxe est:


Exemple:
Si la chaine ch=''Bonjour''. Alors
L=longueur(ch);
Donc, L=7.

--- Slide 13 ---
â€¹#â€º
5.2. La fonction concat:

Elle permet de retourner une nouvelle chaine de caractÃ¨res, qui est le rÃ©sultat dâ€™ajout une chaine Ã  la fin dâ€™une autre chaine. Sa syntaxe est:


Remarque: 

Lâ€™ordre des chaines de caractÃ¨res dans cette fonction est trÃ¨s important (la <chaine2> va Ãªtre rajoutÃ©e Ã  la fin de <chaine1>.


--- Slide 14 ---
â€¹#â€º
Exemple :

ch1,ch2,ch3:chaine;

ch1=''Bonjour'';
ch2=''tout le mondeâ€™â€™; 
1)ch3=concat (ch1,ch2); alors ch3=''Bonjourtout le monde'';
ch4=''  tout le mondeâ€™â€™; 
2)ch3=concat (ch1,ch4); alors ch3=''Bonjour tout le mondeâ€™â€™;
3)ch3=concat (ch1,Â Â Â â€™â€™  â€˜â€™); alors ch3=''Bonjour â€™â€™;
ch3=concat (ch3,Â Â Â ch2); alors ch3=''Bonjour tout le monde'';







--- Slide 15 ---
â€¹#â€º
6. Comparaison des chaines de caractÃ¨res:

Les chaines de caractÃ¨res sont comparÃ©es selon lâ€™ordre des caractÃ¨res dÃ©fini dans la table ASCII.
La comparaison se fait Ã  lâ€™aide des opÃ©rateurs de comparaison (<, >, =, <>, â€¦).




--- Slide 16 ---
â€¹#â€º
Exemple:

ch1=''Bonjour'';

ch2=''tout le monde'';

On remarque que ch1 est infÃ©rieure Ã  ch2 car la lettre B est infÃ©rieure Ã  la lettre t.

--- Slide 17 ---
â€¹#â€º
7. AccÃ¨s aux Ã©lÃ©ments dâ€™une chaine de caractÃ¨res:
Pour accÃ©der Ã  un Ã©lÃ©ment dâ€™une chaine, on Ã©critÂ :


<indice>: pour une chaine de caractÃ¨res de longueur L, indice doit appartenir Ã  [1, L] et il peut prendre la forme de nâ€™importe quelle expression arithmÃ©tique de type entier.
Exemple:
ch=''Bonjour''. 
ch[1]='B'; ch[4]='j'; ch[7]='r';

--- Slide 18 ---
â€¹#â€º
Exercice 1:
Ecrire un algorithme qui permet de lire une chaine de caractÃ¨res. Puis, de calculer et dâ€™afficher le nombre de lettres minuscules contenues dans cette chaine.



--- Slide 19 ---
â€¹#â€º
Exercice 2:
Ecrire un algorithme qui permet de lire deux chaines de caractÃ¨res. Puis, de les afficher dans lâ€™ordre alphabÃ©tique croissant. 



--- Slide 20 ---
â€¹#â€º
Exercice 3:
Ecrire un algorithme qui permet de lire une chaine de caractÃ¨res. Puis, dâ€™afficher un message indiquant si cette chaine est palindrome ou non.
Indication: une chaine est palindrome si elle se lit de la droite vers la gauche ou de la gauche vers la droite.
Exemples:
Â« radar Â», Â« elle Â» sont deux mots palindromes.
 



--- Slide 21 ---
â€¹#â€º
8. Les tableaux de chaines de caractÃ¨res (tableau de mots):
Un tableau de mots est reprÃ©sentÃ©e par une matrice de chaines de caractÃ¨res, oÃ¹ chaque ligne reprÃ©sente une seule chaine. 
A noter que chaque chaine a sa propre taille (c'est-Ã -dire le nombre de colonnes nâ€™est pas le mÃªme pour toutes les lignes). Il est dÃ©clarÃ©e comme une matrice. Lâ€™accÃ¨s Ã  un mot qui se trouve dans la ligne i se fait comme suit: 









--- Slide 22 ---
â€¹#â€º
Exemple:
Soit le tableau de mots suivant:




A[1]=''math'';
A[3]=''algorithme'';
A[1,1]='m';  A[4,2]='o';


--- Slide 23 ---
â€¹#â€º
Exercice 4:
Ecrire un algorithme qui permet de lire un tableau de N mots (N est donnÃ©e par lâ€™utilisateur avec 1â‰¤N â‰¤50). Puis, dâ€™afficher le mot qui a le maximum de lettres alphabÃ©tiques minuscules.
Exemple:



Le mot: AlgoRitHME a le maximum de lettres alphabÃ©tiques minuscules.



--- Slide 24 ---
â€¹#â€º
ğŸ§© Exercice 1 : Suppression du bruit â€œsel et poivreâ€ Ã  lâ€™aide du filtre mÃ©dian

ğŸ”Š 1. Quâ€™est-ce que le bruit â€œsel et poivreâ€ ?
Le bruit sel et poivre est un type de perturbation courante dans les images numÃ©riques. Il apparaÃ®t sous forme de pixels blancs (sel) et pixels noirs (poivre) rÃ©partis de maniÃ¨re alÃ©atoire, ce qui dÃ©grade la qualitÃ© visuelle de lâ€™image.
Exemple visuel :
Origine du bruit :
Erreurs de transmission dâ€™image ğŸ“¡
Capteurs dÃ©fectueux ğŸ“¸
Compression ou stockage de mauvaise qualitÃ© ğŸ’¾
Dans une matrice grise reprÃ©sentant une image, cela 
correspond Ã  des 0 (noirs) et 255 (blancs) mal placÃ©s.

--- Slide 25 ---
â€¹#â€º
ğŸ§® 2. Le filtre mÃ©dian
Le filtre mÃ©dian est une technique de traitement dâ€™image non linÃ©aire utilisÃ©e pour supprimer le bruit tout en prÃ©servant les contours.
Principe : Pour chaque pixel, on remplace sa valeur par la mÃ©diane des valeurs de ses voisins dans une fenÃªtre donnÃ©e (souvent 3Ã—3).
Ã‰tapes :
SÃ©lectionner une fenÃªtre (par exemple 3Ã—3) autour du pixel central.
Mettre toutes les valeurs des pixels de cette fenÃªtre dans une liste.
Trier la liste.
Remplacer le pixel central par la valeur mÃ©diane de cette liste.
Exemple :
Liste des valeurs = [0, 0, 1, 0, 1, 1, 0, 0, 0] â†’ TriÃ©e = [0, 0, 0, 0, 0, 1, 1, 1, 1] â†’ MÃ©diane = 0 â†’ Le pixel central devient 0 âœ…
Ainsi, les pixels â€œanormauxâ€ sont corrigÃ©s sans trop flouter lâ€™image.

--- Slide 26 ---
â€¹#â€º
Ã‰crire un algorithme qui permet de supprimer le bruit â€œsel et poivreâ€ dans une image reprÃ©sentÃ©e par une matrice, en utilisant le filtre mÃ©dian.
Lâ€™algorithme doit :
Lire une matrice M des nÃ—m.
Pour chaque pixel (sauf les bords), crÃ©er une fenÃªtre 3Ã—3 centrÃ©e sur ce pixel.
Calculer la mÃ©diane des valeurs de la fenÃªtre.
Remplacer le pixel central par cette mÃ©diane.
Afficher la matrice filtrÃ©e.

--- Slide 27 ---
â€¹#â€º
Exercice 2 : DÃ©tection de sÃ©quences croissantes
Ã‰crire un algorithme qui permet de dÃ©terminer le nombre de sous-suites strictement croissantes dans une sÃ©rie de nombres donnÃ©e. Lâ€™algorithme doit aussi identifier la plus longue sÃ©quence croissante, en affichant :
son point de dÃ©part,
son point dâ€™arrivÃ©e,
et sa longueur.
Exemple :
EntrÃ©e : [2, 3, 1, 4, 5, 7, 2, 9]
Sous-suites croissantes :(2, 3), (1, 4, 5, 7), (2, 9)RÃ©sultat :
Nombre de sÃ©quences croissantes = 3 Plus longue sÃ©quence = (1, 4, 5, 7) DÃ©but = 1, Fin = 7, Longueur = 4

--- Slide 28 ---
â€¹#â€º
Exercice 3 : ChaÃ®ne â€œspirale alphabÃ©tiqueâ€
Ã‰crire un algorithme qui lit une chaÃ®ne de caractÃ¨res et vÃ©rifie si les lettres suivent une progression alphabÃ©tique circulaire. Autrement dit, aprÃ¨s z, on revient Ã  a.
Lâ€™algorithme doit afficher :
â€œChaÃ®ne spiraleâ€ si la condition est respectÃ©e,
sinon â€œNon spiraleâ€.
Exemples :
â€œabcdeâ€ â†’ spirale âœ…
â€œxyzabâ€ â†’ spirale âœ…
â€œacdeâ€ â†’ non spirale âŒ

--- Slide 29 ---
â€¹#â€º
ğŸ”¡ Exercice 4 : Trouver le mot le plus long dans une phrase
Ã‰crire un algorithme qui lit une phrase et identifie le mot le plus long quâ€™elle contient, ainsi que sa longueur.
Exemple : EntrÃ©e : â€œLes algorithmes rendent la logique puissante.â€ â†’ Mot le plus long : â€œalgorithmesâ€, longueur = 11
Indication : DÃ©couper la phrase en mots et comparer leurs longueurs Ã  chaque itÃ©ration.

--- Slide 30 ---
â€¹#â€º
Exercice 5 : Rotation des anneaux dâ€™une matrice

ğŸ¯ Objectif :
Ã‰crire un algorithme qui effectue une rotation circulaire des anneaux (ou couches) dâ€™une matrice carrÃ©e ou rectangulaire de k positions vers la droite.

ğŸ§  Principe :
Une matrice peut Ãªtre vue comme un ensemble dâ€™anneaux concentriques :
Lâ€™anneau externe : formÃ© par la premiÃ¨re ligne, la derniÃ¨re colonne, la derniÃ¨re ligne et la premiÃ¨re colonne.
Lâ€™anneau interne : les Ã©lÃ©ments juste Ã  lâ€™intÃ©rieur, et ainsi de suiteâ€¦
Lâ€™idÃ©e est de faire tourner chaque anneau indÃ©pendamment de k positions, comme une roue ğŸš´â€â™‚ï¸.


--- Slide 31 ---
â€¹#â€º

âš™ï¸ Ã‰tapes de lâ€™algorithme :
Lire une matrice MMM de taille nÃ—mn \times mnÃ—m et un entier kkk.
Pour chaque couche (ou â€œringâ€) :
Extraire les Ã©lÃ©ments de lâ€™anneau dans une liste.
Effectuer une rotation circulaire de cette liste de kkk positions vers la droite.
RÃ©insÃ©rer les Ã©lÃ©ments dans la matrice Ã  leurs nouvelles positions.
Afficher la matrice aprÃ¨s rotation.


=== FILE: Chapitre 4 allocation dynamique.pptx ===

--- Slide 1 ---

Chapitre 4:
Pointeurs et allocation dynamique 
Ecole Nationale PrÃ©paratoire aux Etudes dâ€™IngÃ©niorat Badji Mokhtar

Docteur: A. MAHANI

--- Slide 2 ---
La mÃ©moire centrale est un ensemble de cellules mÃ©moires organisÃ©es en octets.
Chaque octet est repÃ©rÃ© et identifiÃ© dâ€™une faÃ§on unique par une valeur quâ€™on appelle adresse.
Chaque donnÃ©e stockÃ©e dans la mÃ©moire a une adresse mÃ©moire qui reprÃ©sente le dÃ©but de cette donnÃ©e.
2
1. Introduction

--- Slide 3 ---
Exemple:   x:entier;
La dÃ©claration de x rÃ©sulte une rÃ©servation dâ€™un espace mÃ©moire. Donc, x a une adresse.
Supposons que lâ€™adresse de x est 30.
Alors: on Ã©crit 
Lâ€™adresse de x quâ€™on note &x=30
Si x=5, alors le contenu de lâ€™adresse 30, notÃ©: contenu(&30)=5
3

5




&30


--- Slide 4 ---

En rÃ©sumÃ©:
Une variable a une adresse mÃ©moire et un contenu.
Cette adresse peut Ãªtre manipulÃ©e grÃ¢ce Ã  la notion de pointeur.
4

--- Slide 5 ---

Un pointeur est une variable qui contient lâ€™adresse dâ€™une autre variable. Cette derniÃ¨re est appelÃ©e la variable pointÃ©e ou lâ€™objet pointÃ©.
Le type dâ€™un pointeur a le mÃªme type que la variable pointÃ©e. 
Pour dÃ©clarer un pointeur, on Ã©crit:





5
2. Notion de pointeur

--- Slide 6 ---
Exemple: Soit x une variable entiÃ¨re et p est un pointeur sur un entier. 
X:entier;
p: â†‘entier;
Jusquâ€™Ã  prÃ©sent, il nâ€™existe aucune relation entre x et p.
Pour que p puisse pointer sur x, on doit Ã©crire:

Donc, le contenu de lâ€™adresse de x est le contenu de p, on Ã©crit:
6

--- Slide 7 ---
7
La fonction taille fournit la taille dâ€™un type donnÃ© en octet. Sa syntaxe est:



Exemples :   
  taille(entier)   = 4
  taille(caractere) = 1


3. La fonction taille dâ€™un type:

--- Slide 8 ---
8

4.1. Affectation dâ€™un pointeur Ã  lâ€™adresse NIL:

Lâ€™adresse NIL veut dire Â« aucune adresse Â».

Exemple:

P:â†‘ entier;

P:=NIL; veut dire que P ne pointe pas sur aucune adresse mÃ©moire.



4. Quelques opÃ©rations sur les pointeurs

--- Slide 9 ---
9
4.2. IncrÃ©mentation:

Lâ€™incrÃ©mentation dâ€™un pointeur permet de passer Ã  lâ€™espace mÃ©moire suivant.     

Exemple:
P:â†‘ entier;
P+1 reprÃ©sente lâ€™adresse de lâ€™entier suivant. Donc:


--- Slide 10 ---
10

4.3. Soustraction:

La diffÃ©rence entre deux pointeurs du mÃªme type reprÃ©sente le nombre dâ€™Ã©lÃ©ments situÃ©s entre ces deux adresses.

4.4. Comparaison:

Il est possible de comparer deux pointeurs du mÃªme type. 


--- Slide 11 ---
11

Dans lâ€™allocation statique, la rÃ©servation dâ€™un espace mÃ©moire se fait au moment de la compilation. 
Cependant, elle nâ€™est pas pratique pour les tableaux car elle nÃ©cessite une rÃ©servation avant de connaitre la taille rÃ©elle dâ€™un tableau (sachant que cette taille est connue pendant lâ€™exÃ©cution dâ€™un programme). Donc, ce type dâ€™allocation nâ€™est pas bon pour la bonne gestion de la mÃ©moire.


5. Allocation statique et dynamique

--- Slide 12 ---
12

Pour Ã©viter ce problÃ¨me, on fait appel Ã  lâ€™allocation dynamique oÃ¹ la rÃ©servation dâ€™un espace mÃ©moire se fait pendant lâ€™exÃ©cution dâ€™un programme (câ€™est-Ã -dire Ã  la demande de lâ€™utilisateur).


--- Slide 13 ---
13


6. Quelles sont les Ã©tapes de lâ€™allocation dynamique? 


--- Slide 14 ---
14
6.1. Outils de base
6.1.1. La fonction dâ€™allocation: allouer
Pour allouer un espace mÃ©moire dynamiquement, on appelle la fonction allouer. 
Cette fonction rÃ©serve un espace et retourne son adresse de dÃ©but. 
Pour allouer un espace mÃ©moire dâ€™un type donnÃ© de taille N (N>=1), on Ã©crit:



--- Slide 15 ---
15
6.1.2. La fonction de libÃ©ration: liberer
Lâ€™un des intÃ©rÃªts essentiels de lâ€™allocation dynamique est de pouvoir rÃ©cupÃ©rer des emplacements dont on a plus besoins. Donc, pour libÃ©rer un espace mÃ©moire dÃ©jÃ  allouÃ©, on appelle la fonction liberer. 



--- Slide 16 ---
16
6.2. Allocation dynamique pour les tableaux Ã  une seule dimension de taille N:
1. DÃ©clarer un pointeur vers ce tableau:


2.  Lire la taille N.
3. RÃ©server un espace mÃ©moire pour tout le tableau et stocker son adresse de dÃ©but dans le pointeur dÃ©clarÃ©:






--- Slide 17 ---
17
4. VÃ©rifier si la rÃ©servation a Ã©tÃ© faite avec succÃ¨s en comparant la valeur du pointeur avec lâ€™adresse NIL:

5. Faire les traitements nÃ©cessaires.
6. LibÃ©rer lâ€™espace rÃ©servÃ© pour ce tableau en appelant la fonction liberer:  






--- Slide 18 ---
18
RÃ©sumÃ©: les Ã©tapes dâ€™allocation dynamique pour un tableau de N entiers sont: 



 







--- Slide 19 ---
19

Notation:

Le pointeur T reprÃ©sente lâ€™adresse du tableau et il reprÃ©sente lâ€™adresse de T[1]. Donc:



 







--- Slide 20 ---
20
Exercice 1 :
Ecrire un algorithme qui permet de lire un tableau dynamique de n entiers (n est donnÃ© par lâ€™utilisateur et nâ‰¥1). Puis, de calculer et dâ€™afficher la plus grande valeur du tableau. 

--- Slide 21 ---
21
Exercice 2 :
Ecrire un algorithme qui permet de lire le tableau dynamique T de N entiers (N Ã©tant donnÃ© par lâ€™utilisateur oÃ¹ Nâ‰¥2). Puis, de supprimer toutes les occurrences de la valeur val (val est donnÃ©e par lâ€™utilisateur). Enfin, dâ€™afficher T.

Exemple:  val=3


--- Slide 22 ---
22
Exercice 3:
Ecrire un algorithme qui permet de lire un tableau dynamique de N entiers (N Ã©tant donnÃ© par lâ€™utilisateur oÃ¹ Nâ‰¥2). Puis, de remplacer chaque Ã©lÃ©ment par la somme de tous les Ã©lÃ©ments qui le prÃ©cÃ¨dent.
Exemple:


--- Slide 23 ---
23
6.3. Allocation dynamique pour les matrices 

Pour allouer un espace dynamiquement pour une matrice, on utilise lâ€™une des deux possibilitÃ©s suivantes:

PossibilitÃ© 1: allouer un espace mÃ©moire pour chaque ligne.
PossibilitÃ© 2: allouer un espace pour toute la matrice Ã  la fois.     







--- Slide 24 ---
24

Pour les deux possibilitÃ©s, on a la structure suivante:






On remarque quâ€™il faut rajouter un tableau oÃ¹ on stocke lâ€™adresse de chaque ligne dâ€™une matrice.

--- Slide 25 ---
25
6.3.1. PossibilitÃ© 1: Allocation pour chaque ligne
Etape 1: DÃ©clarer un pointeur vers le tableau dâ€™adresses:

Etape 2: Lire N
Etape 3: RÃ©server un espace pour le tableau dâ€™adresses:











--- Slide 26 ---
26
Etape 4: pour chaque ligne: 
   - Lire la taille M (si elle se diffÃ¨re dâ€™une ligne Ã  une autre).
   - RÃ©server un espace mÃ©moire et stocker son adresse dans le tableau dâ€™adresse dans la case correspondante:













--- Slide 27 ---
27
Etape 5: faire les traitements nÃ©cessaires 
Etape 6: LibÃ©rer les espaces rÃ©servÃ©s:
    1. LibÃ©rer lâ€™espace rÃ©servÃ© pour chaque ligne:



      
     2. LibÃ©rer lâ€™espace rÃ©servÃ© pour le tableau dâ€™adresses. 












--- Slide 28 ---
28
RÃ©sumÃ©: Allouer un espace pour une matrice de N lignes et les colonnes varie dâ€™une ligne Ã  une autre. 



 










--- Slide 29 ---
29
6.3.2.  PossibilitÃ© 2: Allocation pour toute la matrice
Etape 1: DÃ©clarer un pointeur vers le tableau dâ€™adresses:

Etape 2: Lire N et M.
Etape 3: RÃ©server un espace pour le tableau dâ€™adresses. 

Etape 4: RÃ©server un espace pour toute la matrice:











--- Slide 30 ---
30
Etape 5: pour chaque ligne: 
   - Stocker lâ€™adresse de chaque ligne dans le tableau dâ€™adresse dans la case correspondante (exemple dans la  diapositive suivante):


Etape 6: Faire les traitements nÃ©cessaires.
Etape 7: LibÃ©rer les espaces rÃ©servÃ©s
  1. LibÃ©rer lâ€™espace rÃ©servÃ© pour toute la matrice

   2. LibÃ©rer lâ€™espace rÃ©servÃ© pour le tableau dâ€™adresses














--- Slide 31 ---
31
Exemple de calcul des adresses












--- Slide 32 ---
32
RÃ©sumÃ©: Allouer un espace pour une matrice de taille N*M du type entier. 



 








--- Slide 33 ---
33
6.4. Avantages et inconvÃ©nients des deux mÃ©thodes:
Lâ€™allocation dâ€™espace pour toute la matrice Ã  la fois (deuxiÃ¨me mÃ©thode) permet de rÃ©duire le temps dâ€™accÃ¨s Ã  la mÃ©moire en appelant la fonction allouer une seule fois. Mais, cette allocation nÃ©cessite la disponibilitÃ© dâ€™un espace mÃ©moire contigu pour toute la matrice.
La premiÃ¨re mÃ©thode fait appel Ã  la fonction libÃ©rer plusieurs fois mais pour une matrice de grande taille permet de bien gÃ©rer la mÃ©moire en allouant les espaces disponibles dans la mÃ©moire.






--- Slide 34 ---
34
Exercice 4:
Ecrire un algorithme qui permet de lire une matrice dynamique dâ€™entiers de n lignes et m colonnes (n et m sont donnÃ©s par lâ€™utilisateur avec nâ‰¥2 et mâ‰¥2). Ensuite, de calculer et dâ€™afficher le numÃ©ro de la ligne qui donne la plus grande somme.

--- Slide 35 ---
35
Exercice 5:
Soit la matrice dynamique mat du type entier contenant n lignes et m colonnes (n et m sont donnÃ©s par lâ€™utilisateur avec nâ‰¥2 et mâ‰¥2).

Ecrire un algorithme qui permet de lire les m-1 premiers Ã©lÃ©ments de mat oÃ¹ chaque ligne reprÃ©sente une valeur binaire (le contrÃ´le doit Ãªtre assurÃ© par lâ€™algorithme). Ensuite, de calculer la valeur dÃ©cimale correspondante Ã  chaque ligne et de la stocker dans la derniÃ¨re case. Puis, de trier mat selon lâ€™ordre croissant de la valeur dÃ©cimale. Enfin, dâ€™afficher mat.

--- Slide 36 ---
36
Exemple:



--- Slide 37 ---
37
Exercice 6:
Ecrire un algorithme qui permet de lire la matrice dynamique A contenant N mots (N est donnÃ© par lâ€™utilisateur avec Nâ‰¥2). Ensuite, dâ€™afficher tous les mots carrÃ©s de A.
Indication: un mot est carrÃ© sâ€™il est Ã©crit sous la forme UU.
Exemple: papa


=== FILE: Chapitre 5- Les actions paramÃ©tÃ©res 2024 2025.pptx ===

--- Slide 1 ---
1
Algo et SDD 2 â€“ 
Chapitre 1
Les actions paramÃ©trÃ©es (fonctions et les procÃ©dures)
2AP - MI

--- Slide 2 ---
Un algorithme peut Ãªtre dÃ©coupÃ© en plusieurs parties nommÃ©es Â«modulesÂ» ou Â«sous algorithmesÂ» ou Â«actions paramÃ©trÃ©esÂ». Cette programmation dite modulaire et elle se justifie pour plusieurs raisons :

Aborder mieux un problÃ¨me complexe en le dÃ©coupant en plusieurs sous problÃ¨mes chacun donnera naissance Ã  une ou plusieurs modules.
La programmation modulaire permet dâ€™Ã©viter les sÃ©quences dâ€™instructions rÃ©pÃ©titives afin de minimiser la taille dâ€™un algorithme.
Faciliter la maintenance des programmes (correction des erreurs, mise Ã  jour, â€¦).
Permet de partager les modules sur plusieurs utilisateurs pour les regrouper Ã  la fin. 
Remarque : 
Une action paramÃ©trÃ©e peut Ãªtre une fonction ou une procÃ©dure.

2
1. Introduction

--- Slide 3 ---

Une fonction est une action paramÃ©trÃ©e (un sous algorithme ) qui a un type, peut recevoir des donnÃ©es dâ€™entrÃ©es et peut retourner un ou plusieurs rÃ©sultats. 

Exemples:
3
2. Les fonctions
P

--- Slide 4 ---
2.1. Syntaxe de dÃ©claration dâ€™une fonction : 
4
La premiÃ¨re ligne est appelÃ©e: entÃªte de la fonction
 <liste des paramÃ¨tres formels> : sont des paramÃ¨tres dâ€™entrÃ©es et de sorties. Chaque paramÃ¨tre formel se dÃ©clare comme suit : 
Le mode de transmission des paramÃ¨tres est rÃ©sumÃ© dans ce tableau:

--- Slide 5 ---
<DÃ©claration des variables locales> : sont des variables intermÃ©diaires utilisÃ©es par la fonction pour pouvoir effectuer le traitement demandÃ©.
< traitement de la fonction> : La partie des instructions de la fonction
<expression> :  câ€™est le rÃ©sultat de la fonction, son type = type de la fonction. Elle peut Ãªtre : une valeur, une variable ou une expression.  exemples: 
             retourner(12);     retourner (x);     retourner (x+2*y-4);  

Remarque : les parenthÃ¨ses sont facultatives 
5

--- Slide 6 ---
Exemple 1:
6

--- Slide 7 ---
Exemple 2:
7
Prod (entier)
Remarque : cette fonction donne deux rÃ©sultats : la somme et le produit. La somme est stockÃ©e dans le nom de la fonction et le produit est stockÃ© dans le paramÃ¨tre de sortie Prod             

--- Slide 8 ---
Une fonction peut Ãªtre appelÃ©e par un algorithme ou une autre action paramÃ©trÃ©e (fonction ou procÃ©dure), comme  suit :



<variable>: a le mÃªme type que le rÃ©sultat retournÃ© par la fonction.
<identificateur> : câ€™est le nom de la fonction
<liste des paramÃ¨tres effectifs>: sont les paramÃ¨tres contenant les donnÃ©es Ã  fournir Ã  la fonction et les sorties (les rÃ©sultats).
8
2.2.  Appel Ã  une fonction

--- Slide 9 ---
Remarque:
Les paramÃ¨tres effectifs doivent respecter les conditions suivantes:

Ils doivent avoir le mÃªme nombre que les paramÃ¨tres formels .
Ils doivent respecter le mÃªme ordre des paramÃ¨tres formels .
Ils doivent avoir le mÃªme type que les paramÃ¨tres formels .
Ils peuvent avoir des noms diffÃ©rents ou les mÃªmes noms que les paramÃ¨tres formels .
9

--- Slide 10 ---
                   ....
   va r  S, a , b: entier; // passage par valeur
            â€¦
   S:=Somme(a,b); // le rÃ©sultat sera dans S
            â€¦  
10
                    â€¦
   T[50] : tableau dâ€™entier;  
   N, S, P : entier;     
            â€¦
   S:=SomProdTableau(T, N, &P);   //La somme sera dans S
                                                            //Le produit sera dans P 
Exemple 2 : utilisation Ã  la fonction Â«Â SomProdTableauÂ Â» dans lâ€™algorithme principal
Exemple 1 : Appel Ã  la fonction Â«Â SommeÂ Â» dans lâ€™algorithme principal

--- Slide 11 ---
11
Remarques:
Les fonctions sont placÃ©es avant lâ€™algorithme principal.
Dans la mÃ©moire centrale, chaque fonction a sa propre zone mÃ©moire. 
Une fonction peut ne pas avoir des paramÃ¨tres. Câ€™est un cas rare.

2.3. Mode de Transmission des paramÃ¨tres
2.3.1. Transmission par valeur   
La fonction ne connait pas les adresses mÃ©moires des paramÃ¨tres transmis par valeur, elle connait seulement leurs valeurs, donc elle ne peut pas les modifier.

2.3.1. Transmission par adresse
La fonction connait les adresses mÃ©moires des paramÃ¨tres transmis par adresse, et connait aussi leurs valeurs, donc elle peut les modifier.

 

--- Slide 12 ---
Exercice 1: 
DÃ©rouler lâ€™algorithme suivant 
pour x=5, y=11, z=4 et w=10.
12

--- Slide 13 ---
Exercice 2
Ecrire la fonction Â« premierÂ Â» qui dÃ©termine si un nombre entier strictement positif est premier ou non. (ne pas contrÃ´ler si lâ€™entier est strictement positif, on laisse Ã§a Ã  lâ€™algorithme).
Ecrire la fonction factorielle qui permet de calculer la factorielle dâ€™un nombre entier positif. (ne pas contrÃ´ler si lâ€™entier est positif, on laisse Ã§a Ã  lâ€™algorithme).
Ecrire un algorithme qui permet de lire deux entiers strictement positifs x et y avec x â‰¤ y (Ã  contrÃ´ler). Puis, de calculer et dâ€™afficher la factorielle des nombres premiers compris entre x et y (x et y sont inclus).
13

--- Slide 14 ---
Exercice 3 : 

Ecrire la fonction somme qui permet de  calculer  la somme des Ã©lÃ©ments dâ€™un tableau T de N entiers.

Ecrire un algorithme qui permet de lire deux tableaux dâ€™entiers de taille N et M respectivement et dâ€™afficher leurs somme.
14

--- Slide 15 ---

Une procÃ©dure est aussi une action paramÃ©trÃ©e qui peut fournir des rÃ©sultats (un ou plusieurs) ou aucun, mais sans valeur de retour. Les rÃ©sultats sont stockÃ©s dans les paramÃ¨tres de sorties.  

La diffÃ©rence entre une fonction est une procÃ©dure est que :

la fonction possÃ¨de un type et la procÃ©dure ne possÃ¨de pas.
la fonction possÃ¨de Ã  la fin lâ€™instruction Â«Â retournerÂ Â», et la procÃ©dure ne la possÃ¨de pas.




15
3. Les procÃ©dures

--- Slide 16 ---
16
3.1. Syntaxe de dÃ©claration dâ€™une procÃ©dure
<DÃ©claration des variables locales> , <liste des paramÃ¨tres formels> et  < traitement de la procÃ©dure> :  sont dÃ©jÃ  expliquÃ©s dans la fonction

--- Slide 17 ---
Exemple 1 :
17

--- Slide 18 ---
Exemple 2:
18
P (entier)
Remarque : cette procÃ©dure donne deux rÃ©sultats : la somme et le produit. La somme est stockÃ©e dans le paramÃ¨tre de sortie S et le produit est stockÃ© dans le paramÃ¨tre de sortie P             

--- Slide 19 ---
Une procÃ©dure peut Ãªtre appelÃ©e par un algorithme ou une autre action paramÃ©trÃ©e (fonction ou procÃ©dure) ,  comme  suit:




<identificateur> : câ€™est le nom de la procÃ©dure
<liste des paramÃ¨tres effectifs> : sont les paramÃ¨tres rÃ©ellement                      							    utilisÃ©s. 
19
3.2.  Appel Ã  une procÃ©dure

--- Slide 20 ---
                   ....
   va r  S, a , b: entier;
            â€¦
   Somme(a, b, &S); // le rÃ©sultat sera dans S
            â€¦  
20
                    â€¦
   T[50] : tableau dâ€™entier;
   N, S, P : entier;
            â€¦
   SomProdTableau(T, N, &P, &S); //La somme sera dans S
                                                            //Le produit sera dans P 
Exemple 2 : Appel Ã  la procÃ©dure Â«Â SomProdTableauÂ Â»
Exemple 1 : Appel Ã  la procÃ©dure Â«Â SommeÂ Â»

--- Slide 21 ---
Exercice 4 : 
Ecrire une action paramÃ©trÃ©e qui lit un tableau de N entiers.

Ecrire une action paramÃ©trÃ©e qui dÃ©termine lâ€™indice du minimum ainsi que lâ€™indice du maximum dâ€™un tableau de N entiers. 

Ecrire un algorithme qui permet de lire un tableau de N entiers (N>1 et N<=50). Puis, dâ€™afficher la valeur maximale ainsi que la valeur minimale de ce tableau (utiliser les actions paramÃ©trÃ©es prÃ©cÃ©dentes).

Remarque : choisir la bonne action paramÃ©trÃ©e (fonction ou procÃ©dure).
21

--- Slide 22 ---
4. Variables globales VS Variables locales : 
Les variables globales sont des variables dÃ©clarÃ©es dans lâ€™algorithme principal, avant la dÃ©claration des actions paramÃ©trÃ©es. Ces variables peuvent Ãªtre utilisÃ©es par toutes les actions paramÃ©trÃ©es, et par lâ€™algorithme bien sure. 
Les variables locales sont des variables dÃ©clarÃ©es localement dans une action paramÃ©trÃ©e. Ces variables ne peuvent Ãªtre utilisÃ©es que par cette action paramÃ©trÃ©e. 
Si une variable locale est statique alors elle sera automatiquement supprimÃ©e de la mÃ©moire Ã  la fin de lâ€™exÃ©cution de lâ€™action paramÃ©trÃ©e.  
Si elle est dynamique, elle ne sera supprimÃ©e quâ€™aprÃ¨s une instruction de libÃ©ration.
Alors, attention, il ne faut pas retourner lâ€™adresse dâ€™une variable locale statique dâ€™une action paramÃ©trÃ©e, car cette variable statique nâ€™existera plus aprÃ¨s la fin de lâ€™exÃ©cution de lâ€™action paramÃ©trÃ©e. 
22

--- Slide 23 ---
23
5. Attention Ã  lâ€™effet de bord !  
Lorsque une variable x est dÃ©clarÃ©e comme variable globale, et elle nâ€™est pas transmise comme paramÃ¨tre Ã  une action paramÃ©trÃ©e, alors on peut avoir deux cas  :
Si x est dÃ©clarÃ©e aussi localement dans une action paramÃ©trÃ©e, dans ce cas pas de problÃ¨me, on aura deux variables diffÃ©rentes x globale et x locale, donc lâ€™action paramÃ©trÃ©e utilise la variable x locale et lâ€™algorithme utilise la variable x globale.
Si on a oubliÃ© de dÃ©clarer la variable x localement dans une action paramÃ©trÃ©e, alors si cette action paramÃ©trÃ©e modifie une variable dâ€™un nom x alors câ€™est la variable x globale qui sera modifiÃ©e, ce qui est appelÃ© lâ€™effet de bord. Il faut faire attention Ã  ce cas. 
 


--- Slide 24 ---
Exercice 5 :

Ecrire une action paramÃ©trÃ©e qui permet de dÃ©terminer lâ€™indice du minimum dâ€™une ligne dâ€™une matrice dâ€™entiers de taille N*M, Ã  partir dâ€™une position donnÃ©e.  

Ecrire une action paramÃ©trÃ©e qui permet de trier une ligne dâ€™une matrice dâ€™entiers de taille N*M selon lâ€™ordre croissant. 

Ecrire lâ€™algorithme qui permet de lire une matrice dâ€™entiers de taille N*M (1<=N<=50 et 1<=M<=50). Puis, de trier chaque ligne de cette matrice (utiliser les actions paramÃ©trÃ©es prÃ©cÃ©dentes). Enfin, de lâ€™afficher.
24

--- Slide 25 ---
Exercice 6 : 
Ecrire une action paramÃ©trÃ©e qui dÃ©termine si un caractÃ¨re reprÃ©sente une lettre alphabÃ©tique (majuscule ou minuscule) ou non.
Ecrire une action paramÃ©trÃ©e qui dÃ©termine si une chaine de caractÃ¨re contient des lettres alphabÃ©tiques seulement.
Ecrire une action paramÃ©trÃ©e qui  dÃ©termine si une lettre alphabÃ©tique est une voyelle ou non.
Ecrire un algorithme qui permet de lire un tableau de N mots (1<=N<=50) oÃ¹ chaque mot doit contenir que des lettres alphabÃ©tiques. Puis, dâ€™afficher le nombre de voyelles de chaque mot.
25


=== FILE: Chapitre 7 Les fichiers.pptx ===

--- Slide 1 ---

Chapitre 7:
Les fichiers
Ecole Nationale PrÃ©paratoire aux Etudes dâ€™IngÃ©niorat Badji Mokhtar

Docteur: A. MAHANI

--- Slide 2 ---
   Jusquâ€™Ã  prÃ©sent, les informations utilisÃ©es dans nos algorithmes ou dans nos programmes ne pouvaient provenir que de deux sourcesÂ : soit elles Ã©taient incluses (initialisÃ©es) dans lâ€™algorithme lui-mÃªme, soit elles Ã©taient entrÃ©es par lâ€™utilisateur pour les stocker dans la mÃ©moire principale (la RAM). Cependant cette mÃ©moire est volatile et ces donnÃ©es sont effacÃ©es Ã  la fin de lâ€™exÃ©cution dâ€™un programme.
   Imaginons que lâ€™on veuille Ã©crire un programme pour gÃ©rer un carnet dâ€™adresses. Dâ€™une exÃ©cution Ã  une autre,Â lâ€™utilisateur doit pouvoir retrouver son carnet Ã  jour, avec les modifications apportÃ©es la derniÃ¨re fois quâ€™il a exÃ©cutÃ© le programme. Les donnÃ©es du carnet dâ€™adresse ne peuvent donc Ãªtre incluses dans lâ€™algorithme, et encore moins Ãªtre entrÃ©es au clavier Ã  chaque nouvelle exÃ©cutionÂ !
1
1. Introduction

--- Slide 3 ---
   Donc, la solution Ã  ce problÃ¨me nÃ©cessite le stockage de ces informations dans des structures de donnÃ©es permanentes existantes sur un support de stockage appelÃ© mÃ©moire secondaire (disque dur, clÃ© USB, â€¦.).
Dans ce chapitre, on utilise une nouvelle structure de donnÃ©e permanente appelÃ©e fichier. 
   
1
1. Introduction

--- Slide 4 ---
   Un fichier est une structure de stockage permanente des donnÃ©es sur une mÃ©moire secondaire. 
   chaque fichier possÃ¨de un nom sur son support de stockage appelÃ© nom externe ou nom physique.  Ce nom a la forme suivante:


Chemin: pour prÃ©ciser lâ€™endroit dâ€™existence dâ€™un fichier. Il contient lâ€™emplacement  (disque dur D, disque dur C, â€¦) et le rÃ©pertoire qui contient le fichier sâ€™il existe.
Nom: est le nom attribuÃ© Ã  un fichier.
Extension: pour prÃ©ciser le type dâ€™un fichier. 
1
2. DÃ©finition dâ€™un fichier:

--- Slide 5 ---
   
1
Exemples:

1.   d:\\Structures de donnÃ©es2\\les fichiers.docx
    Le fichier portant le nom: les fichiers, existe dans le disque dur D et dans le rÃ©pertoire (dossier) Structures de donnÃ©es2. Son extension est: docx.
2.  C:\\les enregisterements.pptx
 Le fichier portant le nom: les enregistrements, existe dans le disque dur C. Son extension est: pptx.


--- Slide 6 ---
   Il existe deux types de fichiers: les fichiers textes et les fichiers binaires.

Les fichiers texte: sont constituÃ©s dâ€™une suite de caractÃ¨res et ils peuvent Ãªtre manipulÃ©s par un Ã©diteur de texte.

Les fichiers binaires: sont des fichiers qui ne sont pas interprÃ©tables sous forme de texte  (une image, un son, â€¦) et qui ne peuvent pas Ãªtre manipulÃ©s par un Ã©diteur de texte. Ils sont constituÃ©s dâ€™un ensemble dâ€™octets  et ses donnÃ©es sont toutes de mÃªme type.

Dans ce chapitre, on sâ€™intÃ©resse Ã  la manipultion des fichiers binaires seulement.
1
3. Les types dâ€™un fichier:

--- Slide 7 ---
  Un fichier peut Ãªtre manipulÃ© Ã  lâ€™aide dâ€™un algorithme (ou dâ€™un programme) pour pouvoir stocker (Ã©crire) des informations ou de les rÃ©cupÃ©rer (lire son contenu).

   Pour quâ€™un algorithme puisse manipuler un fichier, il doit passer par les Ã©tapes suivantes:
1. Utiliser un pointeur vers le fichier appelÃ© nom interne.
2. Ouvrir le fichier pour pouvoir effectuer les opÃ©rations suivantes: Ã©criture, lecture, mise Ã  jour.
3. Fermer le fichier.
1
4. Manipulation des fichiers binaires:

--- Slide 8 ---
  Il faut utiliser un pointeur (une tÃªte de lecture/Ã©criture). Ce pointeur est appelÃ© le nom logique ou le nom interne dâ€™un fichier. Sa dÃ©claration se fait comme suit:




1
4.1.  DÃ©claration dâ€™un nom interne:

--- Slide 9 ---
  pour ouvrir un fichier, on doit Ã©tablir un lien entre le nom interne dâ€™un fichier et son nom externe en prÃ©cisant le mode dâ€™ouverture. La syntaxe utilisÃ©e est la suivante:


Le mode dâ€™ouverture est rajoutÃ© pour prÃ©ciser le type de lâ€™opÃ©ration Ã  faire sur le fichier. Les modes dâ€™ouvertures sont:
"ecriture" : pour crÃ©er un fichier sâ€™il nâ€™existe pas ou dâ€™Ã©craser son contenu sâ€™il existe dÃ©jÃ .
"lecture" : pour lire les informations Ã©crites dans le fichier. 
"mettre Ã  jour" : pour crÃ©er un fichier sâ€™il nâ€™existe pas ou de rajouter de nouvelles donnÃ©es Ã  la fin dâ€™un fichier.


1
4.2.  Ouverture dâ€™un fichier:

--- Slide 10 ---
Remarque:
Le nom externe dâ€™un fichier peut Ãªtre une chaine constante (mise entre guillemets) ou stockÃ© dans une variable de type chaine de caractÃ¨res (donnÃ© par lâ€™utilisateur ou initialisÃ©).
Exemple 1:
f :  fichier; 
f:=ouvrir("d:\\notes.dat","ecriture");
Exemple 2:
f :  fichier; 
Chemin [20]: chaine de caractre;
lire(Chemin)
f:=ouvrir(Chemin, "mettre a jour");
1

--- Slide 11 ---
   AprÃ¨s lâ€™ouverture dâ€™un fichier, il faut sâ€™assurer que lâ€™ouverture a Ã©tÃ© fait avec succÃ¨s en testant la valeur de nom interne avec la valeur NIL.

   Les problÃ¨mes qui peuvent Ãªtre apparaitre lors de lâ€™ouverture sont les suivantes:
 Lâ€™accÃ¨s refusÃ© Ã  un support de stockage.
 La lecture des donnÃ©es Ã  partir dâ€™un fichier non existant.
 Le chemin donnÃ© nâ€™existe pas.

1
Remarque:

--- Slide 12 ---
    Le rÃ´le de la fonction de fermeture dâ€™un fichier est de rompre la liaison Ã©tablie entre le nom interne et le nom externe. Elle provoque aussi lâ€™Ã©criture sur disque du tampon associÃ© au fichier.

1
4.3. Fermeture dâ€™un fichier:

--- Slide 13 ---
5.  Ecriture dans un fichier:
1
  Pour pouvoir effectuer une opÃ©ration dâ€™Ã©criture, le fichier doit Ãªtre ouvertÂ en mode crÃ©ation (sâ€™il nâ€™existe pas dÃ©jÃ ) ou en mode mise Ã  jour.
 La fonction ecrire permet dâ€™Ã©crire sur un fichier binaire un Ã©lÃ©ment dâ€™une taille donnÃ©e (en nombre dâ€™octets) Ã  partir dâ€™une zone mÃ©moire appelÃ©e tampon.





Ce tampon est une variable qui a le mÃªme type de lâ€™information qui va Ãªtre Ã©crite. Il peut Ãªtre une variable simple ou une variable de type structurÃ©.
Fichier




MÃ©moire tampon


--- Slide 14 ---
5.  Ecriture dans un fichier:
1
La syntaxe de la fonction dâ€™Ã©criture est:

--- Slide 15 ---
5.  Ecriture dans un fichier:
1
En rÃ©sumÃ©, pour crÃ©er ou mettre Ã  jour un fichier, on doit suivre les Ã©tapes suivantes:
DÃ©clarer le nom interne.
Ouvrir le fichier en prÃ©cisant le mode dâ€™ouverture.
Sâ€™assurer que f est diffÃ©rent de NIL.
Ecrire les informations.
Fermer le fichier.

--- Slide 16 ---
Exercice 1:
1
Ecrire un algorithme qui permet dâ€™Ã©crire N nombres entiers dans le fichier portant le nom externe Â« d:\nombres.dat Â»   

--- Slide 17 ---
6.   Lecture:
1
Pour pouvoir effectuer une opÃ©ration de lecture, le fichier doit Ãªtre ouvert en mode lecture et le fichier doit exister.  Les donnÃ©es doivent Ãªtre rÃ©cupÃ©rÃ©es une par une dans une mÃ©moire tampon en parcourant tout le fichier
La syntaxe de lâ€™instruction de lecture est:

--- Slide 18 ---
7.  Parcourir un fichier:
1
Le nombre dâ€™Ã©lÃ©ments dâ€™un fichier nâ€™est pas connu. Mais, un fichier est dÃ©limitÃ© par une marque de fin de fichier qui est reprÃ©sentÃ© par le caractÃ¨re finfichier qui se dÃ©place Ã  chaque ajout dâ€™un Ã©lÃ©ment.
Pour dÃ©tecter la fin dâ€™un fichier, on fait appel Ã  la fonction fin. Sa syntaxe est la suivante: 



Cette fonction retourne:
Vrai: câ€™est la fin dâ€™un fichier est atteinte.
Faux: câ€™est la fin dâ€™un fichier nâ€™est pas atteinte.
1
2
3
4
finfichier

fin


--- Slide 19 ---
7.  Parcourir un fichier:
1
La lecture des Ã©lÃ©ments dâ€™un fichier se fait comme suit:
Au dÃ©but, la tÃªte de L/E est positionnÃ©e sur le premier Ã©lÃ©ment du fichier.
A chaque lecture dâ€™un Ã©lÃ©ment, la tÃªte se dÃ©place automatiquement vers lâ€™Ã©lÃ©ment suivant.
La fin est dÃ©tectÃ©e aprÃ¨s la lecture du caractÃ¨re finfichier.




--- Slide 20 ---
7.  Parcourir un fichier:
1
Si on suit lâ€™algorithme de parcours suivant, on va avoir un problÃ¨me qui sera illustrÃ© dans lâ€™exemple donnÃ© dans le slide suivant:



--- Slide 21 ---
Exemple: le parcours du fichier suivant se fait comme suit pour calculer la somme de ses Ã©lÃ©ments
1

--- Slide 22 ---
7.  Parcourir un fichier:
1
On remarque que la derniÃ¨re valeur est traitÃ©e deux fois. Pour Ã©viter ce problÃ¨me, on doit suivre lâ€™algorithme de parcours suivant:

--- Slide 23 ---
Exemple: le parcours du fichier suivant se fait comme suit pour calculer la somme de ses Ã©lÃ©ments
1

--- Slide 24 ---
1
Exercice 2:

  Ecrire un algorithme qui permet de calculer la somme et la moyenne des Ã©lÃ©ments du fichier dont le nom externe est Â« d:\nombres.dat Â»  (crÃ©Ã© dans lâ€™exercice 1). 

--- Slide 25 ---
8.  Les modes dâ€™accÃ¨s Ã  un fichier:
1
A un instant donnÃ©, un et un seul Ã©lÃ©ment dâ€™un fichier est accessible, celui pointÃ© par la tÃªte de lecture/Ã©criture (L/E). Il existe deux types dâ€™accÃ¨s aux Ã©lÃ©ments dâ€™un fichierÂ : 
 Lâ€™accÃ¨s sÃ©quentiel.
 Lâ€™accÃ¨s direct (sÃ©lectif).


--- Slide 26 ---
8.1.   Lâ€™accÃ¨s sÃ©quentiel:
1
Les Ã©lÃ©ments dâ€™un fichier sont accÃ©dÃ©s lâ€™un Ã  la suite de lâ€™autre  dans lâ€™ordre de leurs stockage, câ€™est Ã  dire pour accÃ©der Ã  lâ€™Ã©lÃ©ment i dâ€™un fichier, il faut passer par les (i-1) Ã©lÃ©ments qui le prÃ©cÃ¨dent.


--- Slide 27 ---
8.2.  Lâ€™accÃ¨s direct:
1
Permet dâ€™accÃ©der directement Ã  un Ã©lÃ©ment i sans passer par les (i-1) Ã©lÃ©ments qui le prÃ©cÃ¨dent. Pour cela, il faut connaitre la position de lâ€™Ã©lÃ©ment voulu pour positionner convenablement la tÃªte de L/E sur cet Ã©lÃ©ment en faisant appel Ã  la fonction pointer. A noter que la position du premier Ã©lÃ©ment est 0. 
Sa syntaxe est la suivanteÂ : 

--- Slide 28 ---
1
Exercice  3:
Un employÃ© est dÃ©fini par les champs suivants: numÃ©ro (1 pour le premier, 2 pour le second, 3 pour le troisiÃ¨me â€¦), nom et prÃ©nom (des chaines de caractÃ¨res de taille maximale 25). 
Les employÃ©s dâ€™une sociÃ©tÃ© sont stockÃ©s dans le fichier Â«employÃ©s.datÂ»
On dÃ©sire stocker le nombre dâ€™heures fait par jour en une semaine dans un tableau (6 jours par semaine) pour chaque employÃ© pour crÃ©er le fichier Â«Heures.datÂ». Sachant que ce fichier contient le numÃ©ro dâ€™un employÃ© et le tableau contenant le nombre dâ€™heures fait en une semaine.

--- Slide 29 ---
1
1. Ecrire lâ€™action paramÃ©trÃ©e Calculer qui calcule le nombre dâ€™heures fait en une semaine.
2. Ecrire lâ€™action paramÃ©trÃ©e Determiner_Maximum qui dÃ©termine le nombre dâ€™heures  maximal Ã  partir du fichier Â«Heures.datÂ». Cette action paramÃ©trÃ©e a en entrÃ©e le nom interne de ce fichier.
3. Ecrire lâ€™action paramÃ©trÃ©e Recuperer_Employe qui rÃ©cupÃ¨re toutes les informations dâ€™un employÃ© identifiÃ© par son numÃ©ro.
4. Ecrire un algorithme qui permet dâ€™afficher tous les employÃ©s qui ont fait un nombre maximal dâ€™heures en une semaine. 
On suppose que les fichiers utilisÃ©s sont dÃ©jÃ  crÃ©Ã©s. 

--- Slide 30 ---
1
1. Cas dâ€™usage des fichiers en informatiqueÂ 
2. SpÃ©cialitÃ©s au niveau de lâ€™EMP
3. Outils et langages Ã  maÃ®triserÂ 
4. Intelligence artificielle
5. Anything specific you want to ask for 
6. Moi	

--- Slide 31 ---
1
1. Cas dâ€™usage des fichiers en informatiqueÂ :
	-IntÃ©gritÃ© des fichiersÂ : comparaison des noms, des tailles, des sommes de contrÃ´les, des signatures, chiffrement dâ€™un fichier, compression dâ€™un fichier
	- SystÃ¨me de gestion de fichierÂ : 
		*l'organisation hiÃ©rarchique des fichiers au sein d'un systÃ¨me d'exploitation (par exemple NTFS, FAT, FAT32)
		*Il existe d'autres faÃ§ons d'organiser les donnÃ©es, par exemple les bases de donnÃ©es (notamment base de donnÃ©es relationnelle) et les fichiers indexÃ©s.

--- Slide 32 ---
1
1. Cas dâ€™usage des fichiers en informatiqueÂ :

Dans le cas du systÃ¨me de fichiers FAT, ancien systÃ¨me de fichiers de MS-DOS et de Windows encore largement utilisÃ© sur les supports amovibles comme les clÃ©s USB, chaque rÃ©pertoire contient une table associant les noms de fichiers Ã  leur taille et un index pointant vers la table d'allocation de fichiers, une zone rÃ©servÃ©e du disque indiquant pour chaque bloc de donnÃ©es l'index du bloc suivant du mÃªme fichier.

Exemples des mÃ©tadonnÃ©es les plus courantes sont :
    -Droits d'accÃ¨s en lecture, Ã©criture et exÃ©cution selon l'utilisateur, le groupe, ou les autres ;
    -Dates de dernier accÃ¨s, de modification des mÃ©tadonnÃ©es (inode), de modification des donnÃ©es (block)8 ;
    -PropriÃ©taire et groupe propriÃ©taire du fichier ;
    -Taille du fichier ;
    -Nombre de noms de fichiers (liens) pointant vers l'inode;
    -Nombre de blocs utilisÃ©s par le fichier9 ;
    -Type de fichier : fichier simple, lien symbolique, rÃ©pertoire, pÃ©riphÃ©rique, etc.

--- Slide 33 ---
1
2. SpÃ©cialitÃ©s au niveau de lâ€™EMPÂ :
	-RÃ©seau
	-SÃ©curitÃ©
	-Science de donnÃ©es
	-Image et visualisation
	-SystÃ¨me dâ€™aide Ã  la dÃ©cision

--- Slide 34 ---
1
3. Outils et langages Ã  maÃ®triser pour tout dÃ©veloppeur
	1. Git [version control and code repository]
	2. SQL [for Database interaction]
	3. Python [Coding and Programming]
	4. Docker [Container]
	5. Kubernetes [Container Orchastration]
	6. Text Editors + IDE [NotePad et plus encore VisualStudio Code]
	7. Linux Commands
	8. Postman [API Testing]
	9. DÃ©veloppement web (PHP, HTML, Javascript, CSS)
	10. DÃ©veloppement dâ€™application Android (Java)
	
	

--- Slide 35 ---
1
4. Intelligence artificielle
	
	
	

--- Slide 36 ---
1
4. Intelligence artificielle
	
	
	

--- Slide 37 ---
1
4. Intelligence artificielle
	
	
	

--- Slide 38 ---
1
4. Intelligence artificielle
	
	
	

--- Slide 39 ---
1
4. Intelligence artificielle
	
	
	


=== FILE: Chapitre 8 Les listes chainÃ©es.pptx ===

--- Slide 1 ---
1
Pour stocker des donnÃ©es en mÃ©moire, nous avons utilisÃ© des variables simples, des tableaux et des structures. Si vous souhaitez stocker une sÃ©rie de donnÃ©es, le plus simple est en gÃ©nÃ©ral d'utiliser des tableaux.

Toutefois, les tableaux se rÃ©vÃ¨lent parfois assez limitÃ©s, Par exemple: 
si vous crÃ©ez un tableau de 10 cases et que vous vous rendez compte plus tard dans votre programme que vous avez besoin de plus d'espace, il sera impossible d'agrandir ce tableau. 
Il n'est pas possible d'insÃ©rer une case au milieu du tableau.
1. ProblÃ¨me:

--- Slide 2 ---

Chapitre 8:
Les listes chainÃ©es
Ecole Nationale PrÃ©paratoire aux Etudes dâ€™IngÃ©niorat Badji Mokhtar

Docteur: A. MAHANI

--- Slide 3 ---
Une liste chainÃ©e est une structure de donnÃ©es contenant des Ã©lÃ©ments du mÃªme type. 
Chaque Ã©lÃ©ment de cette liste possÃ¨de:
3
2. Les listes chainÃ©es: 
1
&10
 &01

--- Slide 4 ---
4
Comparant au tableau , les Ã©lÃ©ments dâ€™une liste sont Ã©parpillÃ©s dans la mÃ©moire contrairement  Ã  un tableau oÃ¹ les Ã©lÃ©ments sont consÃ©cutifs
2. Les listes chainÃ©es: 
Tableau T
Tableau L

--- Slide 5 ---
5
Pour cette raison que la liaison entre les Ã©lÃ©ments dâ€™une liste doit Ãªtre assurÃ©e par le chainage et elle doit Ãªtre identifiÃ©e par lâ€™adresse de son premier Ã©lÃ©ment.
Le nombre dâ€™Ã©lÃ©ments dâ€™une liste chainÃ©e peut varier au cours de temps en ajoutant ou en supprimant des Ã©lÃ©ments. 
2. Les listes chainÃ©es: 

--- Slide 6 ---
6
Selon le chainage existant entre les Ã©lÃ©ments dâ€™une liste, on peut distinguer plusieurs types de listesÂ telles que: 








Dans ce cours, on se limite sur les listes simplement chainÃ©es.
3. Les diffÃ©rents types de listes:
Les listes simplement chainÃ©es
Les listes doublement chainÃ©es
Les listes circulairesÂ 
Nil
&01
&09
&05

--- Slide 7 ---
Dans ce type de liste, chaque Ã©lÃ©ment contient lâ€™adresse de lâ€™Ã©lÃ©ment suivant. Puisque le dernier Ã©lÃ©ment nâ€™a pas un Ã©lÃ©ment suivant. Donc, lâ€™adresse de son suivant est: NIL.
Cette liste est identifiÃ©e par lâ€™adresse de son premier Ã©lÃ©ment qui doit Ãªtre stockÃ©e dans un pointeur, appelÃ© tÃªte ou dÃ©but (par exemple).
Chaque Ã©lÃ©ment de cette liste possÃ¨de:
- Sa partie information.
- Son adresse. 
  Lâ€™adresse de son Ã©lÃ©ment suivant.

7
4 Les listes simplement chainÃ©es: 

--- Slide 8 ---
Exemple:
Supposons que nous avons les Ã©lÃ©ments suivants dans la mÃ©moire centrale: {1, 2, 3, 7}. Ces Ã©lÃ©ments sont Ã©parpillÃ©s dans la mÃ©moire et sont reliÃ©s comme suit:
8

--- Slide 9 ---
La liste prÃ©cÃ©dente est reprÃ©sentÃ©e comme suit:
9

--- Slide 10 ---
10
Remarque:    Â 
La partie information peut Ãªtre du type simple ou du type enregistrement.
1.1 DÃ©claration dâ€™une liste simplement chainÃ©e:

Une liste est un enregistrement. Elle se dÃ©clare comme suit:

--- Slide 11 ---
11
Exemple 1:

Une liste simplement chainÃ©e dont  la partie information est un entier se 
dÃ©clare comme suit:
// Structure element
struct element {
	int var;
	struct element * suivant;
};

--- Slide 12 ---
12
Exemple 2:

Une simplement chainÃ©e dont  la partie information est une date (jour, 
mois et annÃ©e) 

--- Slide 13 ---
13
4.2. DÃ©claration dâ€™un pointeur sur une liste:







Exemple:

P, debut: â†‘element;

--- Slide 14 ---
Chaque Ã©lÃ©ment de la liste est identifiÃ© par une adresse. Donc, lâ€™accÃ¨s Ã  ses diffÃ©rents champs se fait par adresse en utilisant lâ€™une de ces deux possibilitÃ©s suivantes:
1. La flÃ¨che vers le haut  Â«â†‘Â» et le point Â«.Â».
2. La droite flÃ¨che Â«->Â» (la plus utilisÃ©e).
Exemple 1:  
Lâ€™accÃ¨s aux champs de lâ€™exemple 1 se fait comme suit:
Pâ†‘. x;  // ou p -> x
Pâ†‘. suivant; // ou p->suivant










14
4.3. Manipulation dâ€™une liste:

--- Slide 15 ---
Dans cette liste, on a:








tete=&5                         Q=&20
tete->suivant=&10        Q -> suivant=&50
tete ->x=1                      Q -> x=3
15
Q

Exemple 2:

--- Slide 16 ---
Il existe deux mÃ©thodes de crÃ©ation dâ€™une liste simplement chainÃ©e:






Dans ce cours, on sâ€™intÃ©resse Ã  la mÃ©thode FIFO.
16
4.4. CrÃ©ation dâ€™une liste simplement chainÃ©e
2
La mÃ©thode LIFO:
Last In First Out 
1
La mÃ©thode FIFO
First In First Out 
Tableau T

--- Slide 17 ---
Dans cette mÃ©thode, la crÃ©ation peut se faire Ã  lâ€™aide de ces deux possibilitÃ©s:
 Avec deux pointeurs.
 Avec un seul pointeur.
17
4.4. CrÃ©ation dâ€™une liste simplement chainÃ©e:
3.4.1.  La mÃ©thode FIFO:

--- Slide 18 ---
Les instructions de crÃ©ation dâ€™une liste de  5 entiers par exemple sont:

18
3.4. CrÃ©ation dâ€™une liste simplement chainÃ©e
1.  La mÃ©thode FIFO (avec deux pointeurs):

--- Slide 19 ---
Les instructions de crÃ©ation dâ€™une liste de  5 entiers par exemple sont:

19
3.4. CrÃ©ation dâ€™une liste simplement chainÃ©e
2.  La mÃ©thode FIFO (avec un seul pointeur) :

--- Slide 20 ---
Le parcours dâ€™un tableau de taille N se fait Ã  lâ€™aide dâ€™un indice i oÃ¹ i appartient Ã  [1,N] et le passage dâ€™un Ã©lÃ©ment vers un autre se fait avec lâ€™instruction i:i+1.
Par contre, le parcours dâ€™une liste se fait Ã  lâ€™aide dâ€™un pointeur (p par exemple) oÃ¹ p appartient Ã  [tete, NIL[ et le passage dâ€™un Ã©lÃ©ment vers un autre se fait avec lâ€™instruction: 
p:=p->suivant;
20
3.5. Parcours dâ€™une liste simplement chainÃ©e:

--- Slide 21 ---
Exemple:
Afficher la liste crÃ©Ã©e dans lâ€™exemple prÃ©cÃ©dent:
21
3.5. Parcours dâ€™une liste simplement chainÃ©e:

--- Slide 22 ---
A la fin des traitements dâ€™une liste simplement chainÃ©e, on doit libÃ©rer lâ€™espace rÃ©servÃ© pour tous ses Ã©lÃ©ments un par un.
Les instructions de libÃ©ration sont les suivantes:

22
3.6. LibÃ©ration de lâ€™espace rÃ©servÃ© par une liste :

--- Slide 23 ---
Ecrire un algorithme qui permet de crÃ©er une liste dâ€™entiers qui se termine par 0 (0 non inclus dans la liste). Puis, dâ€™afficher tous les Ã©lÃ©ments pairs de cette liste. Enfin, de libÃ©rer lâ€™espace rÃ©servÃ©.
23
Exercice 1:

--- Slide 24 ---
 Ecrire lâ€™action paramÃ©trÃ©e Creer_Liste qui permet de crÃ©er une liste dâ€™entiers qui se termine par 0 (0 non inclus dans la liste).

 Ecrire lâ€™action paramÃ©trÃ©e Afficher qui permet dâ€™afficher tous les Ã©lÃ©ments pairs dâ€™une liste dâ€™entiers. 

3. Ecrire lâ€™action paramÃ©trÃ©e Liberer_Liste qui permet de libÃ©rer lâ€™espace rÃ©servÃ© par une liste dâ€™entiers.

4. Ecrire un algorithme qui permet de crÃ©er une liste dâ€™entiers qui se termine par 0 (0 non inclus dans la liste). Puis, dâ€™afficher tous les Ã©lÃ©ments pairs de cette liste. Enfin, de libÃ©rer lâ€™espace rÃ©servÃ© (utiliser les actions paramÃ©trÃ©es).
24
Exercice 2:

--- Slide 25 ---
Dans cette partie, on prÃ©sente les opÃ©rations de base sur les listes:
- Insertion dâ€™un Ã©lÃ©ment.
- Suppression dâ€™un Ã©lÃ©ment.
- Tri dâ€™une liste.
25
3.7. Quelques opÃ©rations sur les listes simplement chainÃ©es:

--- Slide 26 ---
Pour insÃ©rer un nouvel Ã©lÃ©ment dans une liste, il faut prendre en considÃ©ration les deux cas suivants:
 Lâ€™insertion au dÃ©but de la liste.
 Lâ€™insertion au milieu de la liste.
Lâ€™insertion se fait selon un critÃ¨re. Par exemples: 
- Respecter le tri dâ€™une liste.
- Lâ€™insertion selon une condition (aprÃ¨s  ou avant lâ€™apparition dâ€™une valeur donnÃ©e, dans une position donnÃ©e, â€¦).
26
3.7.1.  Lâ€™opÃ©ration dâ€™insertion:

--- Slide 27 ---
Cas 1: insertion au dÃ©but de la liste
1. RÃ©server un espace pour cet Ã©lÃ©ment et stocker son adresse dans le pointeur Nouv. Par exemple: Nouv:=&80.

27

    &80                                     &30                             â€¦.
tete
Nouv
9


3.7.1.  Lâ€™opÃ©ration dâ€™insertion:

--- Slide 28 ---
Cas 1: insertion au dÃ©but de la liste
2. Mettre Ã  jour son suivant (le suivant de Nouv est tete): Nouv->suivant:=tete;


28

    &80                                   &30                             â€¦.
tete
Nouv
9
&30

3.7.1.  Lâ€™opÃ©ration dâ€™insertion:

--- Slide 29 ---
Cas 1: insertion au dÃ©but de la liste
3. DÃ©placer la tete vers Nouv: tete:=Nouv


29

    &80                                   &30                             â€¦.
tete
Nouv
9
&30

tete

3.7.1.  Lâ€™opÃ©ration dâ€™insertion:

--- Slide 30 ---
Cas 1: insertion au dÃ©but de la liste
Les instructions nÃ©cessaires sont:





30
3.7.1.  Lâ€™opÃ©ration dâ€™insertion:

--- Slide 31 ---
Cas 2: insertion au milieu
On suppose quâ€™on veut insÃ©rer un nouvel Ã©lÃ©ment avant lâ€™Ã©lÃ©ment dâ€™adresse p dans cette liste par exemple. 

31

&30                             &40                               &50                               &60                      
tete
p
pred


3.7.1.  Lâ€™opÃ©ration dâ€™insertion:

--- Slide 32 ---
Cas 2: insertion au milieu
RÃ©server un espace pour cet Ã©lÃ©ment et stocker son adresse dans le pointeur Nouv. Par exemple: Nouv=80. 
32

&30                              &40                               &50                               &60                      
tete
p
pred


3.7.1.  Lâ€™opÃ©ration dâ€™insertion:

--- Slide 33 ---
Cas 2: insertion au milieu
33

&30                             &40                               &50                               &60                      
tete
p
pred


Nouv



&80
Mettre Ã  jour le suivant de pred:
pred->suivant:=Nouv
3.7.1.  Lâ€™opÃ©ration dâ€™insertion:

--- Slide 34 ---
Cas 2: insertion au milieu:

34

&30                             &40                               &50                               &60                      
tete
p
pred


Nouv

&50

&80
Mettre Ã  jour le suivant de Nouv:
Nouv->suiv:=p
3.7.1.  Lâ€™opÃ©ration dâ€™insertion:

--- Slide 35 ---
Cas 2: insertion au milieu (Ã  lâ€™aide de deux pointeurs)
Les instructions nÃ©cessaires sont:





35
3.7.1.  Lâ€™opÃ©ration dâ€™insertion:

--- Slide 36 ---
Ecrire lâ€™action paramÃ©trÃ©e Inserer_Valeur avant la premiÃ¨re apparition de la valeur val dans une liste dâ€™entiers.
Ecrire lâ€™action paramÃ©trÃ©e Inserer_Valeurs_Paires qui insÃ¨re la valeur val aprÃ¨s chaque valeur paire dans une liste dâ€™entiers.
36
Exercice 3:

--- Slide 37 ---
Pour supprimer un Ã©lÃ©ment dâ€™une liste, il faut prendre en considÃ©ration les deux cas suivants:
 La suppression au dÃ©but de la liste.
 La suppression au milieu de la liste.


37
3.7.2.  Lâ€™opÃ©ration de suppression:

--- Slide 38 ---
Cas 1: suppression au dÃ©but de la liste
1. Stocker lâ€™adresse tete dans un pointeur (par exemple p) avant le dÃ©placement (pour ne pas perdre lâ€™adresse).


38

&30                             &40                               &50                               &60                      
tete
p
3.7.2.  Lâ€™opÃ©ration de suppression:

--- Slide 39 ---
Cas 1: suppression au dÃ©but de la liste
2. DÃ©placer la tete vers lâ€™Ã©lÃ©ment suivant: 
tete:=tete->suivant;
39

&30                             &40                               &50                               &60                      
tete
p
tete


3.7.2.  Lâ€™opÃ©ration de suppression:

--- Slide 40 ---
Cas 1: suppression au dÃ©but de la liste
3. LibÃ©rer lâ€™espace occupÃ© par p: liberer(p).
40

&40

&30                             &40                               &50                               &60                      
p
tete

3.7.2.  Lâ€™opÃ©ration de suppression:

--- Slide 41 ---
Cas 1: suppression au dÃ©but de la liste
Les instructions nÃ©cessaires sont:





41
3.7.2.  Lâ€™opÃ©ration de suppression:

--- Slide 42 ---
Cas 2: Suppression au milieu
On veut supprimer lâ€™Ã©lÃ©ment dâ€™adresse p dans cette liste par exemple.

42

&30                             &40                               &50                               &60                      
tete
p
pred


3.7.2.  Lâ€™opÃ©ration de suppression:

--- Slide 43 ---
Cas 2: Suppression au milieu
Modifier le suivant de pred: 
       pred -> suivant:=p -> suivant;

43

&30                             &40                               &50                               &60                      
tete
p
pred


3.7.2.  Lâ€™opÃ©ration de suppression:

--- Slide 44 ---
Cas 2: Suppression au milieu
2. LibÃ©rer lâ€™espace occupÃ© par p: liberer(p)

44

&30                             &40                               &50                               &60                      
tete
p
pred


3.7.2.  Lâ€™opÃ©ration de suppression:

--- Slide 45 ---
Cas 2: Suppression au milieu
Les instructions nÃ©cessaires sont:





45
3.7.2.  Lâ€™opÃ©ration de suppression:

--- Slide 46 ---
Ecrire lâ€™action paramÃ©trÃ©e Supprimer_Une_Occurrence qui supprime la premiÃ¨re apparition de la valeur val Ã  partir dâ€™une liste dâ€™entiers.
Ecrire lâ€™action paramÃ©trÃ©e Supprimer_Toutes_Occurrences  qui supprime toutes les occurrences de la valeur val Ã  partir dâ€™une liste dâ€™entiers.
46
Exercice 4:

--- Slide 47 ---
Trier une liste veut dire ordonner ses Ã©lÃ©ments selon un critÃ¨re en changeant la partie information seulement (sans toucher les adresses).
Lâ€™algorithme de tri par sÃ©lection appliquÃ© sur les tableaux est appliquÃ© aussi sur les listes (manipuler les adresses au lieu de manipuler les indices). 
Lâ€™algorithme de tri par insertion nâ€™est pas applicable car il nÃ©cessite le retour arriÃ¨re.
Lâ€™algorithme de tri par permutation peut Ãªtre applicable mais il nÃ©cessite le calcul du nombre dâ€™Ã©lÃ©ments de la liste dâ€™abord et aussi lâ€™utilisation des indices et des adresses.
47
3.7.3.  Lâ€™opÃ©ration de tri:

--- Slide 48 ---
Ecrire lâ€™action paramÃ©trÃ©e Trier_Liste qui permet de trier une liste simplement chainÃ©e dont la partie information est un entier, selon lâ€™ordre croissant.
48
Exercice 5:

--- Slide 49 ---
Rappel (pour les enseignants):
On rajoute aussi le tri par sÃ©lection pour un tableau dâ€™entiers de taille N.
49

--- Slide 50 ---
50
3.7.3.  Lâ€™opÃ©ration de tri:

--- Slide 51 ---
51
Array vs. Linked List Complexity Comparison


--- Slide 52 ---
Comparaison Tableau VS liste chainÃ©e:
52

--- Slide 53 ---
Allouer un espace pour le premier Ã©lÃ©ment et stocker son adresse dans le pointeur tete. Ensuite, remplir la partie information.
Exemple: adresse de tete est 40 et la partie information est un entier. 
53

tete
&40
4.4. CrÃ©ation dâ€™une liste simplement chainÃ©e
	1.  La mÃ©thode FIFO (avec deux pointeurs):

--- Slide 54 ---
Lâ€™Ã©lÃ©ment suivant nâ€™est pas encore crÃ©Ã©, on ne peut rien mettre dans tete ->suivant. Puisque la tÃªte pointe toujours sur le premier Ã©lÃ©ment, alors on doit utiliser un autre pointeur pour sauvegarder son adresse (pour mettre Ã  jour le chainage)Â :
Q:=teteÂ ;
54

tete
&40
Q
4.4. CrÃ©ation dâ€™une liste simplement chainÃ©e
1.  La mÃ©thode FIFO (avec deux pointeurs):

--- Slide 55 ---
CrÃ©er le deuxiÃ¨me Ã©lÃ©mentÂ : allouer un espace mÃ©moireÂ et stocker son adresse dans le pointeur P. Ensuite, remplir la partie information. 
Exemple: P=50  et P ->x=2
55

tete
&40                             &50
Q

P
4.4. CrÃ©ation dâ€™une liste simplement chainÃ©e
1.  La mÃ©thode FIFO (avec deux pointeurs):

--- Slide 56 ---
Mettre Ã  jour le chainageÂ : stocker lâ€™adresse P dans:
 Q->suivantÂ : Q->suivantÂ :=PÂ ;
Exemple: Q->suivant:=50Â 
56
1
&50

tete
&40                             &50
Q

P
4.4. CrÃ©ation dâ€™une liste simplement chainÃ©e
1.  La mÃ©thode FIFO (avec deux pointeurs):

--- Slide 57 ---
De la mÃªme maniÃ¨re, stocker lâ€™adresse du lâ€™Ã©lÃ©ment crÃ©Ã© pour mettre Ã  jour le chainage. Puisque, on nâ€™aura pas besoin de lâ€™adresse stockÃ©e dans Q. DoncÂ : on le dÃ©placeÂ : Q:=P (pour mettre Ã  jour le chainage pour le prochain Ã©lÃ©ment)
57
1
&50

tete
&40                             &50
Q

P
Q
4.4. CrÃ©ation dâ€™une liste simplement chainÃ©e
1.  La mÃ©thode FIFO (avec deux pointeurs):

--- Slide 58 ---
CrÃ©er le troisiÃ¨me Ã©lÃ©mentÂ : allouer un espace mÃ©moireÂ et stocker son adresse dans le pointeur P. Ensuite, remplir la partie information.
Exemple: P:=60 et P->x:=3Â 
58
1
&50

tete
&40                             &50                              &60                

P
Q

P
4.4. CrÃ©ation dâ€™une liste simplement chainÃ©e
1.  La mÃ©thode FIFO (avec deux pointeurs):

--- Slide 59 ---
Mettre Ã  jour le chainageÂ : stocker lâ€™adresse P dans Q->suivÂ :
Q->suivant:Â =PÂ ;
Exemple: Q->suivantÂ :=60;
59
1
&50

tete
&40                             &50                              &60                
2
&60

Q

P
4.4. CrÃ©ation dâ€™une liste simplement chainÃ©e
1.  La mÃ©thode FIFO (avec deux pointeurs):

--- Slide 60 ---
De la mÃªme maniÃ¨re, on a besoin de stocker lâ€™adresse du lâ€™Ã©lÃ©ment crÃ©Ã© pour mettre Ã  jour le chainage. Puisque, on nâ€™aura pas besoin de lâ€™adresse stockÃ©e dans Q, doncÂ : on  dÃ©place le pointeurÂ : Q:=P
60
1
&50

tete
&40                             &50                             &60                
2
&60
Q

Q

P
4.4. CrÃ©ation dâ€™une liste simplement chainÃ©e
1.  La mÃ©thode FIFO (avec deux pointeurs):

--- Slide 61 ---

Les mÃªmes Ã©tapes sâ€™appliquent pour les autres Ã©lÃ©ments.
61
1
&50

tete
& 40                           &50                           &60                â€¦.                
2
& 60
Q

P
4.4. CrÃ©ation dâ€™une liste simplement chainÃ©e
1.  La mÃ©thode FIFO (avec deux pointeurs):

--- Slide 62 ---
On a terminÃ© la crÃ©ation de la liste. Donc, le suivant du dernier Ã©lÃ©ment contient lâ€™adresse NILÂ :
P->suivantÂ :=NIL ouÂ : Q->suivant:=NIL
62
1
& 50

tete
& 40                       &50                          &60                                 â€¦â€¦â€¦â€¦.. & 90                
2
& 60
3
& 70
Q
7
NIL

P
4.4. CrÃ©ation dâ€™une liste simplement chainÃ©e
1.  La mÃ©thode FIFO (avec deux pointeurs):

--- Slide 63 ---
Allouer un espace pour le premier Ã©lÃ©ment et stocker son adresse dans le pointeur tete. Ensuite, remplir la partie information.
Exemple: lâ€™adresse de tete est 40
63

tete
&40
3.4. CrÃ©ation dâ€™une liste simplement chainÃ©e
2.  La mÃ©thode FIFO(avec un seul pointeur) :

--- Slide 64 ---
Lâ€™Ã©lÃ©ment suivant nâ€™est pas encore crÃ©Ã©, on ne peut rien mettre dans tete ->suivant. Puisque la tete pointe toujours sur le premier Ã©lÃ©ment, alors on doit utiliser un autre pointeur pour sauvegarder son adresse (pour mettre Ã  jour le chainage)Â :
Q:=teteÂ ;
64

tete
&40
Q
3.4. CrÃ©ation dâ€™une liste simplement chainÃ©e
2.  La mÃ©thode FIFO (avec un seul pointeur) :

--- Slide 65 ---
CrÃ©er le deuxiÃ¨me Ã©lÃ©mentÂ : allouer un espace mÃ©moireÂ et stocker son adresse directement dans Q->suivant. 
Exemple: Q->suivant:= 50.
65
1
&50

tete
&40                             &50
Q
3.4. CrÃ©ation dâ€™une liste simplement chainÃ©e
2.  La mÃ©thode FIFO (avec un seul pointeur) :

--- Slide 66 ---
De la mÃªme maniÃ¨re, on nâ€™a pas besoin de lâ€™adresse stockÃ©e dans Q. On doit le dÃ©placer vers lâ€™Ã©lÃ©ment crÃ©Ã© pour remplir sa partie information et aussi pour mettre Ã  jour le chainageÂ : Q:= Q->suivant.
66
1
&50

tete
&40                            &50
Q
Q

3.4. CrÃ©ation dâ€™une liste simplement chainÃ©e
2.  La mÃ©thode FIFO (avec un seul pointeur) :

--- Slide 67 ---
CrÃ©er le troisiÃ¨me Ã©lÃ©mentÂ : allouer un espace mÃ©moireÂ et stocker son adresse directement dans Q->suivant. 
Exemple: Q->suivant:=60.
67
1
&50

tete
&40                             &50                            &60                
2
&60

Q
3.4. CrÃ©ation dâ€™une liste simplement chainÃ©e
2.  La mÃ©thode FIFO (avec un seul pointeur) :

--- Slide 68 ---
De la mÃªme maniÃ¨re, on nâ€™a pas besoin de lâ€™adresse stockÃ©e dans Q. On doit le dÃ©placer vers lâ€™Ã©lÃ©ment crÃ©Ã© pour remplir sa partie information et aussi pour mettre Ã  jour le chainageÂ : Q:= Q->suivant.
68
1
&50

tete
&40                             &50                              &60                
2
&60
Q

Q

3.4. CrÃ©ation dâ€™une liste simplement chainÃ©e
2.  La mÃ©thode FIFO (avec un seul pointeur) :

--- Slide 69 ---

Les mÃªmes Ã©tapes sâ€™appliquent pour les autres Ã©lÃ©ments.
69
1
&50

tete
&40                             &50                              &60                â€¦.                
2
&60
Q

3.4. CrÃ©ation dâ€™une liste simplement chainÃ©e
3.4.2.  La mÃ©thode FIFO (avec un seul pointeur) :

--- Slide 70 ---
On a terminÃ© la crÃ©ation de la liste. Donc, le suivant du dernier Ã©lÃ©ment contient lâ€™adresse NILÂ :
 Q->suivant:Â =NIL
70
1
&50

tete
&40                             &50                           &60                â€¦â€¦â€¦â€¦..             &90                
2
&60
3
&70
Q
7
NIL

3.4. CrÃ©ation dâ€™une liste simplement chainÃ©e
3.4.2.  La mÃ©thode FIFO (avec un seul pointeur) :


=== FILE: Chapitre 9 Les piles version finale.pptx ===

--- Slide 1 ---

Chapitre 9:
Les piles
Ecole Nationale PrÃ©paratoire aux Etudes dâ€™IngÃ©niorat Badji Mokhtar

Docteur: A. MAHANI

--- Slide 2 ---
2
Dans quelques applications informatiques, on nÃ©cessite le traitement des donnÃ©es dans lâ€™ordre inverse de leur arrivÃ©e oÃ¹ la derniÃ¨re donnÃ©e ajoutÃ©e sera la premiÃ¨re traitÃ©e.
Exemple: dans les appels des actions paramÃ©trÃ©es, la derniÃ¨re action paramÃ©trÃ©e appelÃ©e sera la premiÃ¨re exÃ©cutÃ©e. Pour les appels suivants
f1 appelle f2, f2 appelle f3 et f3 appelle f4. Alors, lâ€™ordre de lâ€™exÃ©cution est f4, f3, f2 puis f1.
Donc, il est nÃ©cessaire dâ€™utiliser une nouvelle structure de donnÃ©es, appelÃ©e pile.
1. Introduction:

--- Slide 3 ---
3
Une pile est une structure de donnÃ©es fondÃ©e sur le principe Â« derniÃ¨re donnÃ©e ajoutÃ©e est la premiÃ¨re extraite Â» (LIFO: Last In First Out). Elle contient des donnÃ©es qui sont du mÃªme type (simples ou structurÃ©es).
Le premier Ã©lÃ©ment dâ€™une pile est appelÃ© le sommet qui est le seul Ã©lÃ©ment accessible.



Les opÃ©rations appliquÃ©es sur les piles sont appelÃ©es primitives.  
2. DÃ©finition dâ€™une pile:
Sommet

--- Slide 4 ---
4
Pour les appels prÃ©cÃ©dents des actions paramÃ©trÃ©es, on obtient cette pile:




La derniÃ¨re fonction appelÃ©e est f4. Elle se trouve au sommet de la pile et elle sera la premiÃ¨re exÃ©cutÃ©e.
Exemple:

--- Slide 5 ---
5
Compilation dâ€™un programme (par exemple, vÃ©rifier si une expression est bien parenthÃ©sÃ©e).
Appels des actions paramÃ©trÃ©es dans un programme.
Utilisation des actions paramÃ©trÃ©es rÃ©cursives.
Evaluation des expressions arithmÃ©tiques (va Ãªtre dÃ©taillÃ©e Ã  la fin de ce chapitre). 
 

3. Les domaines dâ€™application des piles:

--- Slide 6 ---










6
4. Les primitives de manipulation:
Pour pouvoir manipuler les piles, on utilise les primitives  suivantes:
 Initialisation dâ€™une pile.
 Ajout dâ€™un Ã©lÃ©ment.
 Retrait dâ€™un Ã©lÃ©ment.
 Consultation du sommet.
 Test de lâ€™Ã©tat de la pile.
Dans ce qui suit, on va dÃ©tailler chaque primitive.




 

--- Slide 7 ---










7
4.1. Initialisation dâ€™une pile:
Permet dâ€™ouvrir une pile vide. Sa syntaxe est:


Exemple:  pour initialiser la pile P, on Ã©crit:


 

--- Slide 8 ---










8
4.2. Ajout dâ€™un Ã©lÃ©ment: 
Permet dâ€™ajouter un Ã©lÃ©ment au sommet de la pile. Sa syntaxe est:


Exemple:  soit la pile vide P et les variables entiÃ¨res x=3 et y=4.


 

--- Slide 9 ---










9
4.3. Retrait dâ€™un Ã©lÃ©ment: 
Permet de retirer un Ã©lÃ©ment de la pile et de rÃ©cupÃ©rer sa valeur dans une variable (lâ€™Ã©lÃ©ment retirÃ© est supprimÃ© de la pile). Sa syntaxe est:

Exemple:  soit la pile  P suivante:


 
x=4

x=3


--- Slide 10 ---










10
4.4. Consultation du sommet:
Permet de consulter ou de rÃ©cupÃ©rer le sommet de la pile dans une variable sans le supprimer. Mais, il faut Ãªtre sÃ»r que la pile nâ€™est pas vide. Sa syntaxe est:


Exemple:  Soit  la pile P. x=SommetPile(P);  


 

x=4

--- Slide 11 ---










11
4.5. Test de lâ€™Ã©tat de la pile:
Permet de vÃ©rifier si une pile est vide ou non. Sa syntaxe est:


Cette fonction retourne la valeur Â«vraiÂ» si la pile est vide. Sinon, elle retourne la valeur Â«fauxÂ».


--- Slide 12 ---
12
Il existe deux types de reprÃ©sentation des piles en mÃ©moire:

 ReprÃ©sentation Ã  lâ€™aide des tableaux.
 ReprÃ©sentation Ã  lâ€™aide des listes simplement chainÃ©es.

Donc, les primitives de manipulation dÃ©pendent de la reprÃ©sentation utilisÃ©e.  
Dans ce chapitre, on va voir seulement la reprÃ©sentation dâ€™une pile par une liste simplement chainÃ©e.
5. ReprÃ©sentation des piles en mÃ©moire:

--- Slide 13 ---
13
6.1. DÃ©claration dâ€™une pile:








La dÃ©claration dâ€™un Ã©lÃ©ment de la pile se fait comme suit:


6. ReprÃ©sentation dâ€™une pile avec une liste simplement chainÃ©e:

--- Slide 14 ---
14
 6.2.1. Initialiser_Pile:
6.2. Les primitives de manipulation:
On considÃ¨re que le type de la partie information de la pile est: <type_element> 

--- Slide 15 ---
Lâ€™empilement dâ€™un Ã©lÃ©ment revient Ã  faire une insertion au dÃ©but de la liste.
15
6.1.2. Empiler:

--- Slide 16 ---
Le dÃ©pilement dâ€™un Ã©lÃ©ment revient Ã  faire une suppression au dÃ©but de la liste en rÃ©cupÃ©rant lâ€™Ã©lÃ©ment supprimÃ©.
16
6.1.3. DÃ©piler:

--- Slide 17 ---
17
6.1.4. SommetPile:

--- Slide 18 ---
18
6.1.5. PileVide:

--- Slide 19 ---
Ecrire lâ€™action paramÃ©trÃ©e Creation qui permet de crÃ©er une pile de N entiers.
Ecrire lâ€™action paramÃ©trÃ©e Recherche qui vÃ©rifie lâ€™existence de la valeur val dans une pile dâ€™entiers. 
Ecrire un algorithme qui permet de crÃ©er une pile de N entiers. Puis, de vÃ©rifier lâ€™existence de la valeur entiÃ¨re val (val est donnÃ©e par lâ€™utilisateur). 
Remarque: Utiliser les primitives de manipulation des piles.
19
Exercice 1:

--- Slide 20 ---
Une expression arithmÃ©tique contient des opÃ©randes, des opÃ©rateurs et des parenthÃ¨ses. Pour lâ€™Ã©valuer, il faut la transformer en forme postfixÃ©e et utiliser une pile.
La forme postfixÃ©e est comme suit:

20
Application aux expressions arithmÃ©tiques: 

--- Slide 21 ---
1. a+b  ---------------  ab+
2. a+b*c-------------abc*+
3. (a+b)*c ---------- ab+c*
4. a+b*2*(c-d) ---------  ab2*cd-*+  
21
Exemples

--- Slide 22 ---
Pour Ã©valuer une expression arithmÃ©tique Ã©crite sous la forme infixÃ©e, on passe par les deux Ã©tapes suivantes:
Transformer cette expression en forme postfixÃ©e et la mettre dans une pile.
Copier le contenu de la pile dans un tableau de caractÃ¨res.
Dans ce qui suit, on donne les algorithmes de transformation en langage naturel.
22
Exemples

--- Slide 23 ---
          
23
Algorithme dâ€™Ã©valuation en langage naturel:

--- Slide 24 ---
          
24
Algorithme dâ€™Ã©valuation en langage naturel:

--- Slide 25 ---
          
25
Exemple 1: abc*+   

--- Slide 26 ---
          
26
Exemple 1 (suite):









--- Slide 27 ---
          
27
Exemple 2: ab2*cd-*+   

--- Slide 28 ---
          
28









=== FILE: Chapitre 9 Les piles version finale2025.pptx ===

--- Slide 1 ---

Chapitre 9:
Les piles
Ecole Nationale PrÃ©paratoire aux Etudes dâ€™IngÃ©niorat Badji Mokhtar

Docteur: A. MAHANI

--- Slide 2 ---
2
Dans quelques applications informatiques, on nÃ©cessite le traitement des donnÃ©es dans lâ€™ordre inverse de leur arrivÃ©e oÃ¹ la derniÃ¨re donnÃ©e ajoutÃ©e sera la premiÃ¨re traitÃ©e.
Exemple: dans les appels des actions paramÃ©trÃ©es, la derniÃ¨re action paramÃ©trÃ©e appelÃ©e sera la premiÃ¨re exÃ©cutÃ©e. Pour les appels suivants
f1 appelle f2, f2 appelle f3 et f3 appelle f4. Alors, lâ€™ordre de lâ€™exÃ©cution est f4, f3, f2 puis f1.
Donc, il est nÃ©cessaire dâ€™utiliser une nouvelle structure de donnÃ©es, appelÃ©e pile.
1. Introduction:

--- Slide 3 ---
3
Une pile est une structure de donnÃ©es fondÃ©e sur le principe Â« derniÃ¨re donnÃ©e ajoutÃ©e est la premiÃ¨re extraite Â» (LIFO: Last In First Out). Elle contient des donnÃ©es qui sont du mÃªme type (simples ou structurÃ©es).
Le premier Ã©lÃ©ment dâ€™une pile est appelÃ© le sommet qui est le seul Ã©lÃ©ment accessible.



Les opÃ©rations appliquÃ©es sur les piles sont appelÃ©es primitives.  
2. DÃ©finition dâ€™une pile:
Sommet

--- Slide 4 ---
4
Pour les appels prÃ©cÃ©dents des actions paramÃ©trÃ©es, on obtient cette pile:




La derniÃ¨re fonction appelÃ©e est f4. Elle se trouve au sommet de la pile et elle sera la premiÃ¨re exÃ©cutÃ©e.
Exemple:

--- Slide 5 ---
5
Compilation dâ€™un programme (par exemple, vÃ©rifier si une expression est bien parenthÃ©sÃ©e).
Appels des actions paramÃ©trÃ©es dans un programme.
Utilisation des actions paramÃ©trÃ©es rÃ©cursives.
Evaluation des expressions arithmÃ©tiques (va Ãªtre dÃ©taillÃ©e Ã  la fin de ce chapitre). 
 

3. Les domaines dâ€™application des piles:

--- Slide 6 ---










6
4. Les primitives de manipulation:
Pour pouvoir manipuler les piles, on utilise les primitives  suivantes:
 Initialisation dâ€™une pile.
 Ajout dâ€™un Ã©lÃ©ment.
 Retrait dâ€™un Ã©lÃ©ment.
 Consultation du sommet.
 Test de lâ€™Ã©tat de la pile.
Dans ce qui suit, on va dÃ©tailler chaque primitive.




 

--- Slide 7 ---










7
4.1. Initialisation dâ€™une pile:
Permet dâ€™ouvrir une pile vide. Sa syntaxe est:


Exemple:  pour initialiser la pile P, on Ã©crit:


 

--- Slide 8 ---










8
4.2. Ajout dâ€™un Ã©lÃ©ment: 
Permet dâ€™ajouter un Ã©lÃ©ment au sommet de la pile. Sa syntaxe est:


Exemple:  soit la pile vide P et les variables entiÃ¨res x=3 et y=4.


 

--- Slide 9 ---










9
4.3. Retrait dâ€™un Ã©lÃ©ment: 
Permet de retirer un Ã©lÃ©ment de la pile et de rÃ©cupÃ©rer sa valeur dans une variable (lâ€™Ã©lÃ©ment retirÃ© est supprimÃ© de la pile). Sa syntaxe est:

Exemple:  soit la pile  P suivante:


 
x=4

x=3


--- Slide 10 ---










10
4.4. Consultation du sommet:
Permet de consulter ou de rÃ©cupÃ©rer le sommet de la pile dans une variable sans le supprimer. Mais, il faut Ãªtre sÃ»r que la pile nâ€™est pas vide. Sa syntaxe est:


Exemple:  Soit  la pile P. x=SommetPile(P);  


 

x=4

--- Slide 11 ---










11
4.5. Test de lâ€™Ã©tat de la pile:
Permet de vÃ©rifier si une pile est vide ou non. Sa syntaxe est:


Cette fonction retourne la valeur Â«vraiÂ» si la pile est vide. Sinon, elle retourne la valeur Â«fauxÂ».


--- Slide 12 ---
12
Il existe deux types de reprÃ©sentation des piles en mÃ©moire:

 ReprÃ©sentation Ã  lâ€™aide des tableaux.
 ReprÃ©sentation Ã  lâ€™aide des listes simplement chainÃ©es.

Donc, les primitives de manipulation dÃ©pendent de la reprÃ©sentation utilisÃ©e.  
Dans ce chapitre, on va voir seulement la reprÃ©sentation dâ€™une pile par une liste simplement chainÃ©e.
5. ReprÃ©sentation des piles en mÃ©moire:

--- Slide 13 ---
13
6.1. DÃ©claration dâ€™une pile:








La dÃ©claration dâ€™un Ã©lÃ©ment de la pile se fait comme suit:


6. ReprÃ©sentation dâ€™une pile avec une liste simplement chainÃ©e:

--- Slide 14 ---
14
 6.2.1. Initialiser_Pile:
6.2. Les primitives de manipulation:
On considÃ¨re que le type de la partie information de la pile est: <type_element> 

--- Slide 15 ---
Lâ€™empilement dâ€™un Ã©lÃ©ment revient Ã  faire une insertion au dÃ©but de la liste.
15
6.1.2. Empiler:

--- Slide 16 ---
Le dÃ©pilement dâ€™un Ã©lÃ©ment revient Ã  faire une suppression au dÃ©but de la liste en rÃ©cupÃ©rant lâ€™Ã©lÃ©ment supprimÃ©.
16
6.1.3. DÃ©piler:

--- Slide 17 ---
17
6.1.4. SommetPile:

--- Slide 18 ---
18
6.1.5. PileVide:

--- Slide 19 ---
Ecrire lâ€™action paramÃ©trÃ©e Creation qui permet de crÃ©er une pile de N entiers.
Ecrire lâ€™action paramÃ©trÃ©e Recherche qui vÃ©rifie lâ€™existence de la valeur val dans une pile dâ€™entiers. 
Ecrire un algorithme qui permet de crÃ©er une pile de N entiers. Puis, de vÃ©rifier lâ€™existence de la valeur entiÃ¨re val (val est donnÃ©e par lâ€™utilisateur). 
Remarque: Utiliser les primitives de manipulation des piles.
19
Exercice 1:

--- Slide 20 ---
Une expression arithmÃ©tique contient des opÃ©randes, des opÃ©rateurs et des parenthÃ¨ses. Pour lâ€™Ã©valuer, il faut la transformer en forme postfixÃ©e et utiliser une pile.
La forme postfixÃ©e est comme suit:

20
Application aux expressions arithmÃ©tiques: 

--- Slide 21 ---
1. a+b  ---------------  ab+
2. a+b*c-------------abc*+
3. (a+b)*c ---------- ab+c*
4. a+b*2*(c-d) ---------  ab2*cd-*+  
21
Exemples

--- Slide 22 ---
Pour Ã©valuer une expression arithmÃ©tique Ã©crite sous la forme infixÃ©e, on passe par les deux Ã©tapes suivantes:
Transformer cette expression en forme postfixÃ©e et la mettre dans une pile.
Copier le contenu de la pile dans un tableau de caractÃ¨res.
Dans ce qui suit, on donne les algorithmes de transformation en langage naturel.
22
Exemples

--- Slide 23 ---
          
23
Algorithme dâ€™Ã©valuation en langage naturel:

--- Slide 24 ---
          
24
Algorithme dâ€™Ã©valuation en langage naturel:

--- Slide 25 ---
          
25
Exemple 1: abc*+   

--- Slide 26 ---
          
26
Exemple 1 (suite):









--- Slide 27 ---
          
27
Exemple 2: ab2*cd-*+   

--- Slide 28 ---
          
28








--- Slide 29 ---
29
ğŸ² On va jouer Ã  un jeu ! ğŸ§ 

Je vous donne une liste d'exercices (sur les listes chaÃ®nÃ©es, piles, files, etc.).ğŸ“Œ Pendant lâ€™affichage, vous choisissez un exercice Ã  tour de rÃ´le.ğŸ‘‰ Une fois quâ€™un exercice est passÃ©, on ne revient plus dessus !

â¡ï¸ Le premier qui trouve la bonne solution lâ€™Ã©crit au tableau.	âœ”ï¸ Si la solution est correcte, il gagne +5 points au contrÃ´le.	âŒ Si elle est fausse, celui qui la corrige correctement gagne les +5 points Ã  la place 

--- Slide 30 ---
30
ğŸ’¡ Attention, choisissez la bonne stratÃ©gie 

Si tu vises les premiers exercices, la concurrence sera rude ! ğŸ˜ˆ
Si tu tâ€™attaques aux derniers, il y aura peut-Ãªtre moins de pression, maisâ€¦ aura-t-on le temps ? ğŸ•
Si tu vas trop vite, tu risques de faire des erreurs ! ğŸ˜¬
Si tu es trop lent, tu risques de rater ta chance ! ğŸ˜­

ğŸ‘‰ Ã€ toi de trouver la meilleure stratÃ©gie !Vitesse ? PrÃ©cision ? Ou coup malin ?
PrÃªt(e) Ã  relever le dÃ©fi ? ğŸ˜

--- Slide 31 ---
31
ğŸ“ Exercice 1 â€“ Rotation d'une liste chaÃ®nÃ©e vers la droite
Ã‰tant donnÃ©e une liste chaÃ®nÃ©e et un entier k, effectuez une rotation vers la droite de la liste de k positions.Cela signifie que les k derniers Ã©lÃ©ments deviennent les premiers, dans l'ordre.

Exemple :Liste : 1 â†’ 2 â†’ 3 â†’ 4 â†’ 5, k = 2RÃ©sultat attendu : 4 â†’ 5 â†’ 1 â†’ 2 â†’ 3

--- Slide 32 ---
32
ğŸ“ Exercice 2 â€“ Addition de deux nombres reprÃ©sentÃ©s par des listes chaÃ®nÃ©es

Ã‰noncÃ© :Deux nombres sont reprÃ©sentÃ©s par des listes chaÃ®nÃ©es, chaque nÅ“ud contenant un seul chiffre, dans lâ€™ordre inverse (le chiffre des unitÃ©s vient en premier).Additionnez les deux nombres et retournez le rÃ©sultat sous forme d'une nouvelle liste chaÃ®nÃ©e.

Exemple :Liste 1 : 2 â†’ 4 â†’ 3 (342)Liste 2 : 5 â†’ 6 â†’ 4 (465)RÃ©sultat attendu : 7 â†’ 0 â†’ 8 (807)

--- Slide 33 ---
33
ğŸ“ Exercice 3 â€“ DÃ©codage de chaÃ®ne avec crochets imbriquÃ©s

Ã‰noncÃ© :DÃ©coder une chaÃ®ne contenant des expressions avec des crochets. Chaque expression suit le format k[expression] oÃ¹ k est le nombre de rÃ©pÃ©titions.

Exemple :EntrÃ©e : "3[a2[c]]"InterprÃ©tation : "a2[c]" devient "acc", rÃ©pÃ©tÃ© 3 fois â†’ RÃ©sultat : "accaccacc"

--- Slide 34 ---
34
ğŸ“ Exercice 4 â€“ Partition d'une liste autour d'une valeur

Ã‰noncÃ© :RÃ©organisez une liste chaÃ®nÃ©e de sorte que tous les Ã©lÃ©ments infÃ©rieurs Ã  une valeur x apparaissent avant ceux supÃ©rieurs ou Ã©gaux Ã  x. Lâ€™ordre relatif des Ã©lÃ©ments doit Ãªtre conservÃ©.

Exemple :Liste : 1 â†’ 4 â†’ 3 â†’ 2 â†’ 5 â†’ 2, x = 3RÃ©sultat attendu : 1 â†’ 2 â†’ 2 â†’ 4 â†’ 3 â†’ 5

--- Slide 35 ---
35
ğŸ“ Exercice 5 â€“ Conversion d'un nombre binaire reprÃ©sentÃ© par une liste en entire

Ã‰noncÃ© :Une liste chaÃ®nÃ©e reprÃ©sente un nombre binaire, chaque nÅ“ud contenant 0 ou 1, avec le bit de poids fort en premier. Calculez sa valeur dÃ©cimale.

Exemple :Liste : 1 â†’ 0 â†’ 1Valeur dÃ©cimale : 1Ã—2Â² + 0Ã—2Â¹ + 1Ã—2â° = 5

--- Slide 36 ---
36
ğŸ“ Exercice 6 â€“ Miroir dâ€™une file (queue)

Ã‰noncÃ© :Ã‰tant donnÃ©e une file contenant des Ã©lÃ©ments, dupliquez-la en ajoutant Ã  la fin une copie en ordre inverse des Ã©lÃ©ments dâ€™origine.

Exemple :File initiale : [1, 2, 3]File aprÃ¨s opÃ©ration : [1, 2, 3, 3, 2, 1]

