{
  "id": "tableaux",
  "title": "Chapitre 2: Tableaux et Matrices",
  "sections": [
    {
      "title": "Introduction: pourquoi utiliser un tableau ?",
      "content": "[[DEF]] Un **tableau** est une structure qui stocke plusieurs valeurs de même type sous un seul nom, accessibles par indice.\n\nAu lieu de créer 30 variables (`n1`, `n2`, `n3`, ...), on crée un seul tableau `T`.\n\n### Exemple concret\nSi vous voulez enregistrer les notes de 30 étudiants:\n- sans tableau: beaucoup de variables et code répétitif;\n- avec tableau: une boucle suffit pour lire et afficher les notes.\n\n### Avantages\n- code plus court;\n- traitement automatique avec boucles;\n- base de nombreux algorithmes (recherche, tri, statistiques)."
    },
    {
      "title": "Déclaration d'un tableau et indices",
      "content": "On fixe une convention d'indices (ici: `0` à `n-1`) et on la garde partout.\n\n[[ALERT]] La plupart des erreurs viennent des indices hors bornes (`i < 0` ou `i >= n`).",
      "code": "Algorithme DeclarationTableau;\nVar\n    T[10] : Entier;\n    i : Entier;\nDebut\n    Pour i := 0 a 9 Faire\n        T[i] := 0;\n    Fin Pour;\nFin."
    },
    {
      "title": "Parcours d'un tableau",
      "content": "Le parcours séquentiel lit ou modifie les éléments un par un, de gauche à droite.\n\nUsages classiques:\n- calculer somme/moyenne;\n- trouver min/max;\n- compter les valeurs vérifiant une condition.",
      "code": "Algorithme ParcoursTableau;\nVar\n    T[100] : Entier;\n    n, i, somme, maxv : Entier;\nDebut\n    Lire(n);\n    somme := 0;\n\n    Pour i := 0 a n-1 Faire\n        Lire(T[i]);\n        somme := somme + T[i];\n\n        Si i = 0 Ou T[i] > maxv Alors\n            maxv := T[i];\n        Fin Si;\n    Fin Pour;\n\n    Ecrire(\"Somme=\", somme, \" Max=\", maxv);\nFin."
    },
    {
      "title": "Recherche séquentielle (linéaire)",
      "content": "On teste chaque case du tableau, de la première à la dernière, jusqu'à trouver la valeur recherchée.\n\n### Quand l'utiliser ?\n- tableau non trié;\n- petite taille;\n- simplicité prioritaire;\n- besoin d'une méthode facile à expliquer et à déboguer.\n\n### Détail du fonctionnement\n1. On compare `x` avec `T[0]`, puis `T[1]`, etc.\n2. Si on trouve `x`, on s'arrête et on retourne la position.\n3. Si on atteint la fin sans correspondance, la valeur est absente.\n\n### Complexité\n- meilleur cas: `O(1)` (élément au début);\n- pire cas: `O(n)` (élément absent ou en fin);\n- cas moyen: `O(n)`.\n\n[[NOTE]] C'est souvent le meilleur choix pédagogique pour une première recherche.",
      "code": "Algorithme RechercheSequentielle;\nVar\n    T[100] : Entier;\n    n, i, x, pos : Entier;\nDebut\n    Lire(n);\n    Pour i := 0 a n-1 Faire\n        Lire(T[i]);\n    Fin Pour;\n\n    Lire(x);\n    pos := -1;\n\n    Pour i := 0 a n-1 Faire\n        Si T[i] = x Alors\n            pos := i;\n            i := n; // sortie logique de la boucle\n        Fin Si;\n    Fin Pour;\n\n    Ecrire(\"Position=\", pos);\nFin."
    },
    {
      "title": "Recherche dichotomique (binaire)",
      "content": "La recherche dichotomique coupe la zone de recherche en deux à chaque étape.\n\n[[ALERT]] Précondition obligatoire: le tableau doit être **trié**.\n\n### Détail du fonctionnement\n1. On calcule le milieu `m`.\n2. Si `T[m] = x`, on a trouvé.\n3. Si `x < T[m]`, on continue à gauche.\n4. Sinon, on continue à droite.\n\nÀ chaque étape, on élimine environ la moitié des éléments restants.\n\n### Complexité\n- meilleur cas: `O(1)` (valeur trouvée directement au milieu);\n- pire cas: `O(log n)`;\n- cas moyen: proche de `O(log n)`.\n\nSur de grands tableaux triés, elle est beaucoup plus rapide que la recherche séquentielle.",
      "code": "Algorithme RechercheDichotomique;\nVar\n    T[100] : Entier;\n    n, i, x : Entier;\n    g, d, m, pos : Entier;\nDebut\n    Lire(n);\n    Pour i := 0 a n-1 Faire\n        Lire(T[i]);\n    Fin Pour;\n\n    Lire(x);\n    g := 0;\n    d := n - 1;\n    pos := -1;\n\n    Tantque g <= d Faire\n        m := (g + d) div 2;\n\n        Si T[m] = x Alors\n            pos := m;\n            g := d + 1; // sortie logique\n        Sinon\n            Si x < T[m] Alors\n                d := m - 1;\n            Sinon\n                g := m + 1;\n            Fin Si;\n        Fin Si;\n    Fin Tantque;\n\n    Ecrire(\"Position=\", pos);\nFin."
    },
    {
      "title": "Pourquoi trier avant une recherche dichotomique ?",
      "content": "La dichotomie compare la cible à l'élément du milieu, puis élimine une moitié.\n\nCette élimination n'est correcte **que si les valeurs sont ordonnées**:\n- si `x < T[m]`, alors `x` ne peut être qu'à gauche;\n- si `x > T[m]`, alors `x` ne peut être qu'à droite.\n\nSans tri, cette logique est fausse et l'algorithme peut rater un élément existant.\n\n[[NOTE]] En pratique:\n- une seule recherche: séquentielle peut suffire;\n- plusieurs recherches: trier une fois puis utiliser dichotomie est souvent meilleur."
    },
    {
      "title": "Tri: idée générale et objectifs",
      "content": "Trier, c'est réorganiser les valeurs (croissant/décroissant) pour faciliter:\n- la recherche rapide;\n- la lecture des résultats;\n- des traitements ultérieurs (médiane, fusion, comparaison).\n\n### Critères pour comparer les tris\n- vitesse (complexité temps);\n- mémoire supplémentaire;\n- stabilité (conserve ou non l'ordre des égalités);\n- simplicité d'implémentation."
    },
    {
      "title": "Tri par sélection",
      "content": "Principe: à chaque position `i`, chercher le minimum dans la partie non triée, puis échanger avec `T[i]`.\n\n### Points clés\n- simple à comprendre;\n- peu d'échanges;\n- généralement non stable.\n\n### Complexité\n- comparaisons: `O(n^2)`;\n- échanges: `O(n)`.",
      "code": "Algorithme TriSelection;\nVar\n    T[100] : Entier;\n    n, i, j, imin, tmp : Entier;\nDebut\n    Lire(n);\n    Pour i := 0 a n-1 Faire\n        Lire(T[i]);\n    Fin Pour;\n\n    Pour i := 0 a n-2 Faire\n        imin := i;\n        Pour j := i+1 a n-1 Faire\n            Si T[j] < T[imin] Alors\n                imin := j;\n            Fin Si;\n        Fin Pour;\n\n        tmp := T[i];\n        T[i] := T[imin];\n        T[imin] := tmp;\n    Fin Pour;\n\n    Pour i := 0 a n-1 Faire\n        Ecrire(T[i]);\n    Fin Pour;\nFin."
    },
    {
      "title": "Tri par insertion",
      "content": "Principe: on maintient une partie gauche déjà triée, puis on insère chaque nouvelle valeur à la bonne place.\n\n### Points clés\n- très bon si le tableau est presque trié;\n- stable;\n- pédagogique pour comprendre le décalage d'éléments.\n\n### Complexité\n- meilleur cas: `O(n)`;\n- pire cas: `O(n^2)`.",
      "code": "Algorithme TriInsertion;\nVar\n    T[100] : Entier;\n    n, i, j, cle : Entier;\nDebut\n    Lire(n);\n    Pour i := 0 a n-1 Faire\n        Lire(T[i]);\n    Fin Pour;\n\n    Pour i := 1 a n-1 Faire\n        cle := T[i];\n        j := i - 1;\n\n        Tantque (j >= 0) Et (T[j] > cle) Faire\n            T[j+1] := T[j];\n            j := j - 1;\n        Fin Tantque;\n\n        T[j+1] := cle;\n    Fin Pour;\n\n    Pour i := 0 a n-1 Faire\n        Ecrire(T[i]);\n    Fin Pour;\nFin."
    },
    {
      "title": "Tri à bulles",
      "content": "Principe: on compare les voisins et on permute s'ils sont dans le mauvais ordre. Après chaque passage, le plus grand remonte à droite.\n\n### Version optimisée\nSi aucun échange n'est fait pendant un passage, le tableau est déjà trié et on s'arrête.\n\n### Complexité\n- meilleur cas (optimisé): `O(n)`;\n- pire cas: `O(n^2)`.",
      "code": "Algorithme TriBulles;\nVar\n    T[100] : Entier;\n    n, i, j, tmp : Entier;\n    permute : Booleen;\nDebut\n    Lire(n);\n    Pour i := 0 a n-1 Faire\n        Lire(T[i]);\n    Fin Pour;\n\n    Pour i := 0 a n-2 Faire\n        permute := Faux;\n        Pour j := 0 a n-2-i Faire\n            Si T[j] > T[j+1] Alors\n                tmp := T[j];\n                T[j] := T[j+1];\n                T[j+1] := tmp;\n                permute := Vrai;\n            Fin Si;\n        Fin Pour;\n\n        Si permute = Faux Alors\n            i := n; // sortie logique\n        Fin Si;\n    Fin Pour;\n\n    Pour i := 0 a n-1 Faire\n        Ecrire(T[i]);\n    Fin Pour;\nFin."
    },
    {
      "title": "Complexité: explication détaillée",
      "content": "La complexité mesure comment le coût d'un algorithme grandit quand la taille `n` des données augmente.\n\n### Complexité temps\nNombre d'opérations principales (comparaisons, affectations, etc.).\n\n### Complexité mémoire\nMémoire supplémentaire utilisée pendant l'exécution.\n\n### Notation O( )\n`O(f(n))` donne un ordre de grandeur asymptotique:\n- `O(1)` constant;\n- `O(log n)` augmente lentement;\n- `O(n)` linéaire;\n- `O(n^2)` quadratique.\n\nQuand `n` devient grand, la différence entre `O(n)` et `O(n^2)` est énorme."
    },
    {
      "title": "Tableau comparatif des algorithmes",
      "content": "<div class=\"course-table-wrap\">\n<table class=\"course-table\">\n  <thead>\n    <tr>\n      <th>Algorithme</th>\n      <th>Précondition</th>\n      <th>Complexité temps</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr><td>Recherche séquentielle</td><td>Aucune</td><td>O(n)</td></tr>\n    <tr><td>Recherche dichotomique</td><td>Tableau trié</td><td>O(log n)</td></tr>\n    <tr><td>Tri sélection</td><td>Aucune</td><td>O(n^2)</td></tr>\n    <tr><td>Tri insertion</td><td>Aucune</td><td>O(n) à O(n^2)</td></tr>\n    <tr><td>Tri à bulles</td><td>Aucune</td><td>O(n) à O(n^2)</td></tr>\n  </tbody>\n</table>\n</div>"
    },
    {
      "title": "Matrices: introduction",
      "content": "Une **matrice** est un tableau à deux dimensions (`lignes x colonnes`).\n\nOn l'utilise pour:\n- notes de plusieurs classes;\n- images (grille de pixels);\n- tableaux de mesures (jour x capteur)."
    },
    {
      "title": "Déclaration et parcours d'une matrice",
      "content": "On parcourt généralement ligne par ligne avec deux boucles imbriquées.\n\nComplexité d'un parcours complet `L x C`: `O(L*C)`.",
      "code": "Algorithme MatriceParcours;\nVar\n    M[3][4] : Reel;\n    i, j : Entier;\nDebut\n    // Lecture\n    Pour i := 0 a 2 Faire\n        Pour j := 0 a 3 Faire\n            Lire(M[i][j]);\n        Fin Pour;\n    Fin Pour;\n\n    // Affichage\n    Pour i := 0 a 2 Faire\n        Pour j := 0 a 3 Faire\n            Ecrire(M[i][j]);\n        Fin Pour;\n    Fin Pour;\nFin."
    },
    {
      "title": "Exercices pratiques",
      "content": "<div class=\"course-exercise\">\n<div class=\"course-exercise-title\"><i class=\"fas fa-pen\"></i> Exercice 1: Somme et maximum d'un tableau</div>\n<p>Objectif: lire <code class=\"course-inline-code\">n</code> valeurs, calculer la somme et le maximum, puis afficher le résultat.</p>\n<details class=\"course-solution-details\"><summary>Voir la solution complète</summary><pre class=\"course-solution-code\">Algorithme ExoSommeMax;\nVar\n    T[100] : Entier;\n    n, i, somme, maxv : Entier;\nDebut\n    Lire(n);\n    somme := 0;\n\n    Pour i := 0 a n-1 Faire\n        Lire(T[i]);\n        somme := somme + T[i];\n\n        Si i = 0 Ou T[i] > maxv Alors\n            maxv := T[i];\n        Fin Si;\n    Fin Pour;\n\n    Ecrire(\"Somme=\", somme, \" Max=\", maxv);\nFin.</pre><button class=\"course-solution-run\" data-code=\"Algorithme ExoSommeMax;\\nVar\\n    T[100] : Entier;\\n    n, i, somme, maxv : Entier;\\nDebut\\n    Lire(n);\\n    somme := 0;\\n    Pour i := 0 a n-1 Faire\\n        Lire(T[i]);\\n        somme := somme + T[i];\\n        Si i = 0 Ou T[i] > maxv Alors\\n            maxv := T[i];\\n        Fin Si;\\n    Fin Pour;\\n    Ecrire('Somme=', somme, ' Max=', maxv);\\nFin.\">Exécuter cette solution</button></details>\n</div>\n\n<div class=\"course-exercise\">\n<div class=\"course-exercise-title\"><i class=\"fas fa-pen\"></i> Exercice 2: Recherche séquentielle</div>\n<p>Objectif: chercher <code class=\"course-inline-code\">x</code> dans le tableau non trié et afficher sa position (ou <code class=\"course-inline-code\">-1</code>).</p>\n<details class=\"course-solution-details\"><summary>Voir la solution complète</summary><pre class=\"course-solution-code\">Algorithme ExoRechercheSeq;\nVar\n    T[100] : Entier;\n    n, i, x, pos : Entier;\nDebut\n    Lire(n);\n    Pour i := 0 a n-1 Faire\n        Lire(T[i]);\n    Fin Pour;\n\n    Lire(x);\n    pos := -1;\n\n    Pour i := 0 a n-1 Faire\n        Si T[i] = x Alors\n            pos := i;\n            i := n;\n        Fin Si;\n    Fin Pour;\n\n    Ecrire(\"Position=\", pos);\nFin.</pre><button class=\"course-solution-run\" data-code=\"Algorithme ExoRechercheSeq;\\nVar\\n    T[100] : Entier;\\n    n, i, x, pos : Entier;\\nDebut\\n    Lire(n);\\n    Pour i := 0 a n-1 Faire\\n        Lire(T[i]);\\n    Fin Pour;\\n    Lire(x);\\n    pos := -1;\\n    Pour i := 0 a n-1 Faire\\n        Si T[i] = x Alors\\n            pos := i;\\n            i := n;\\n        Fin Si;\\n    Fin Pour;\\n    Ecrire('Position=', pos);\\nFin.\">Exécuter cette solution</button></details>\n</div>\n\n<div class=\"course-exercise\">\n<div class=\"course-exercise-title\"><i class=\"fas fa-pen\"></i> Exercice 3: Tri par insertion</div>\n<p>Objectif: trier un tableau d'entiers en ordre croissant puis afficher le tableau trié.</p>\n<details class=\"course-solution-details\"><summary>Voir la solution complète</summary><pre class=\"course-solution-code\">Algorithme ExoTriInsertion;\nVar\n    T[100] : Entier;\n    n, i, j, cle : Entier;\nDebut\n    Lire(n);\n    Pour i := 0 a n-1 Faire\n        Lire(T[i]);\n    Fin Pour;\n\n    Pour i := 1 a n-1 Faire\n        cle := T[i];\n        j := i - 1;\n\n        Tantque (j >= 0) Et (T[j] > cle) Faire\n            T[j+1] := T[j];\n            j := j - 1;\n        Fin Tantque;\n\n        T[j+1] := cle;\n    Fin Pour;\n\n    Pour i := 0 a n-1 Faire\n        Ecrire(T[i]);\n    Fin Pour;\nFin.</pre><button class=\"course-solution-run\" data-code=\"Algorithme ExoTriInsertion;\\nVar\\n    T[100] : Entier;\\n    n, i, j, cle : Entier;\\nDebut\\n    Lire(n);\\n    Pour i := 0 a n-1 Faire\\n        Lire(T[i]);\\n    Fin Pour;\\n    Pour i := 1 a n-1 Faire\\n        cle := T[i];\\n        j := i - 1;\\n        Tantque (j >= 0) Et (T[j] > cle) Faire\\n            T[j+1] := T[j];\\n            j := j - 1;\\n        Fin Tantque;\\n        T[j+1] := cle;\\n    Fin Pour;\\n    Pour i := 0 a n-1 Faire\\n        Ecrire(T[i]);\\n    Fin Pour;\\nFin.\">Exécuter cette solution</button></details>\n</div>\n\n<div class=\"course-exercise\">\n<div class=\"course-exercise-title\"><i class=\"fas fa-pen\"></i> Exercice 4: Somme des éléments d'une matrice</div>\n<p>Objectif: lire une matrice <code class=\"course-inline-code\">L x C</code> puis afficher la somme de tous ses éléments.</p>\n<details class=\"course-solution-details\"><summary>Voir la solution complète</summary><pre class=\"course-solution-code\">Algorithme ExoSommeMatrice;\nVar\n    M[20][20] : Entier;\n    L, C, i, j, somme : Entier;\nDebut\n    Lire(L);\n    Lire(C);\n    somme := 0;\n\n    Pour i := 0 a L-1 Faire\n        Pour j := 0 a C-1 Faire\n            Lire(M[i][j]);\n            somme := somme + M[i][j];\n        Fin Pour;\n    Fin Pour;\n\n    Ecrire(\"Somme matrice=\", somme);\nFin.</pre><button class=\"course-solution-run\" data-code=\"Algorithme ExoSommeMatrice;\\nVar\\n    M[20][20] : Entier;\\n    L, C, i, j, somme : Entier;\\nDebut\\n    Lire(L);\\n    Lire(C);\\n    somme := 0;\\n    Pour i := 0 a L-1 Faire\\n        Pour j := 0 a C-1 Faire\\n            Lire(M[i][j]);\\n            somme := somme + M[i][j];\\n        Fin Pour;\\n    Fin Pour;\\n    Ecrire('Somme matrice=', somme);\\nFin.\">Exécuter cette solution</button></details>\n</div>"
    }
  ]
}